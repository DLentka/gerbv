<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gerbv: src/batch.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8-20040928 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a></div>
<h1>batch.c</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * gEDA - GNU Electronic Design Automation</span>
00003 <span class="comment"> * This file is a part of gerbv.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> *   Copyright (C) 2000-2002 Stefan Petersen (spe@stacken.kth.se)</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> * $Id$</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
00010 <span class="comment"> * it under the terms of the GNU General Public License as published by</span>
00011 <span class="comment"> * the Free Software Foundation; either version 2 of the License, or</span>
00012 <span class="comment"> * (at your option) any later version.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
00015 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00016 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00017 <span class="comment"> * GNU General Public License for more details.</span>
00018 <span class="comment"> *</span>
00019 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
00020 <span class="comment"> * along with this program; if not, write to the Free Software</span>
00021 <span class="comment"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA</span>
00022 <span class="comment"> */</span>
00023 
00024 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00025 <span class="preprocessor"></span><span class="preprocessor">#include &lt;config.h&gt;</span>
00026 <span class="preprocessor">#endif</span>
00027 <span class="preprocessor"></span>
00028 <span class="preprocessor">#ifdef GUILE_IN_USE </span>
00029 <span class="preprocessor"></span>
00030 <span class="preprocessor">#ifdef HAVE_STRING_H</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#include &lt;string.h&gt;</span>
00032 <span class="preprocessor">#endif</span>
00033 <span class="preprocessor"></span>
00034 <span class="preprocessor">#ifdef HAVE_UNISTD_H</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#include &lt;unistd.h&gt;</span>
00036 <span class="preprocessor">#endif</span>
00037 <span class="preprocessor"></span>
00038 <span class="preprocessor">#include &lt;libguile.h&gt;</span>
00039 <span class="preprocessor">#include &lt;guile/gh.h&gt;</span> <span class="comment">/* To be deprecated */</span>
00040 
00041 <span class="preprocessor">#include "gerber.h"</span>
00042 <span class="preprocessor">#include "drill.h"</span>
00043 <span class="preprocessor">#include "gerb_image.h"</span>
00044 
00045 <span class="preprocessor">#ifndef err</span>
00046 <span class="preprocessor"></span><span class="preprocessor">#define err(errcode, a...) \</span>
00047 <span class="preprocessor">     do { \</span>
00048 <span class="preprocessor">           fprintf(stderr, ##a); \</span>
00049 <span class="preprocessor">           exit(errcode);\</span>
00050 <span class="preprocessor">     } while (0)</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00052 <span class="preprocessor"></span>
00053 
00054 <span class="keyword">static</span> SCM
00055 scm_aperture2scm(<span class="keyword">enum</span> aperture_t a)
00056 {
00057     <span class="keywordflow">switch</span> (a) {
00058     <span class="keywordflow">case</span> CIRCLE :
00059        <span class="keywordflow">return</span> gh_symbol2scm(<span class="stringliteral">"circle\0"</span>);
00060     <span class="keywordflow">case</span> RECTANGLE :
00061        <span class="keywordflow">return</span> gh_symbol2scm(<span class="stringliteral">"rectangle\0"</span>);
00062     <span class="keywordflow">case</span> OVAL :
00063        <span class="keywordflow">return</span> gh_symbol2scm(<span class="stringliteral">"oval\0"</span>);
00064     <span class="keywordflow">case</span> POLYGON :
00065        <span class="keywordflow">return</span> gh_symbol2scm(<span class="stringliteral">"polygon\0"</span>);
00066     <span class="keywordflow">case</span> MACRO :
00067        <span class="keywordflow">return</span> gh_symbol2scm(<span class="stringliteral">"macro\0"</span>);
00068     <span class="keywordflow">default</span> :
00069        err(1, <span class="stringliteral">"Unhandled aperture type\n"</span>);
00070     }
00071 } <span class="comment">/* scm_aperture2scm */</span>
00072 
00073 
00074 <span class="keyword">static</span> SCM
00075 scm_aperture_state2scm(<span class="keyword">enum</span> aperture_state_t aperture_state)
00076 {
00077     <span class="keywordflow">switch</span> (aperture_state) {
00078     <span class="keywordflow">case</span> OFF:
00079        <span class="keywordflow">return</span> gh_symbol2scm(<span class="stringliteral">"exposure-off\0"</span>);
00080     <span class="keywordflow">case</span> ON:
00081        <span class="keywordflow">return</span> gh_symbol2scm(<span class="stringliteral">"exposure-on\0"</span>);
00082     <span class="keywordflow">case</span> FLASH:
00083        <span class="keywordflow">return</span> gh_symbol2scm(<span class="stringliteral">"exposure-flash\0"</span>);
00084     <span class="keywordflow">default</span> :
00085        err(1, <span class="stringliteral">"Unhandled aperture type\n"</span>);
00086     }
00087 } <span class="comment">/* scm_aperture_state2scm */</span>
00088 
00089 
00090 <span class="keyword">static</span> SCM
00091 scm_interpolation2scm(<span class="keyword">enum</span> interpolation_t interpolation)
00092 {
00093     <span class="keywordflow">switch</span> (interpolation) {
00094     <span class="keywordflow">case</span> LINEARx1 :
00095        <span class="keywordflow">return</span> gh_symbol2scm(<span class="stringliteral">"linear-x1"</span>);
00096     <span class="keywordflow">case</span> LINEARx10 :
00097        <span class="keywordflow">return</span> gh_symbol2scm(<span class="stringliteral">"linear-x10"</span>);
00098     <span class="keywordflow">case</span> LINEARx01 : 
00099        <span class="keywordflow">return</span> gh_symbol2scm(<span class="stringliteral">"linear-x01"</span>);
00100     <span class="keywordflow">case</span> LINEARx001 : 
00101        <span class="keywordflow">return</span> gh_symbol2scm(<span class="stringliteral">"linear-x001"</span>);
00102     <span class="keywordflow">case</span> CW_CIRCULAR : 
00103        <span class="keywordflow">return</span> gh_symbol2scm(<span class="stringliteral">"cw-circular"</span>);
00104     <span class="keywordflow">case</span> CCW_CIRCULAR : 
00105        <span class="keywordflow">return</span> gh_symbol2scm(<span class="stringliteral">"ccw-circular"</span>);
00106     <span class="keywordflow">case</span> PAREA_START :
00107        <span class="keywordflow">return</span> gh_symbol2scm(<span class="stringliteral">"polygon-area-start"</span>);
00108     <span class="keywordflow">case</span> PAREA_END :
00109        <span class="keywordflow">return</span> gh_symbol2scm(<span class="stringliteral">"polygon-area-end"</span>);
00110     <span class="keywordflow">default</span> :
00111        <span class="keywordflow">return</span> SCM_BOOL_F;
00112     }
00113 } <span class="comment">/* scm_interpolation2scm */</span>
00114 
00115 
00116 <span class="keyword">static</span> SCM
00117 scm_omit_zeros2scm(<span class="keyword">enum</span> omit_zeros_t omit_zeros)
00118 {
00119 
00120     <span class="keywordflow">switch</span> (omit_zeros) {
00121     <span class="keywordflow">case</span> LEADING :
00122        <span class="keywordflow">return</span> gh_symbol2scm(<span class="stringliteral">"leading"</span>);
00123     <span class="keywordflow">case</span> TRAILING :
00124        <span class="keywordflow">return</span> gh_symbol2scm(<span class="stringliteral">"trailing"</span>);
00125     <span class="keywordflow">case</span> EXPLICIT :
00126        <span class="keywordflow">return</span> gh_symbol2scm(<span class="stringliteral">"explicit"</span>);
00127     <span class="keywordflow">default</span>:
00128        <span class="keywordflow">return</span> SCM_BOOL_F;
00129     }
00130 } <span class="comment">/* scm_omit_zeros2scm */</span>
00131 
00132 
00133 <span class="keyword">static</span> SCM
00134 scm_image2scm(gerb_image_t *image, <span class="keywordtype">char</span> *filename)
00135 {
00136     gerb_net_t *net;
00137     <span class="keywordtype">int</span> i,j;
00138     SCM cirseg   = SCM_EOL;
00139     SCM netlist  = SCM_EOL;
00140     SCM aperture = SCM_EOL;
00141     SCM format   = SCM_EOL;
00142     SCM info     = SCM_EOL;
00143     
00144     <span class="comment">/*</span>
00145 <span class="comment">     * Convert the netlist </span>
00146 <span class="comment">     */</span>
00147     <span class="keywordflow">for</span> (net = image-&gt;netlist-&gt;next; net != NULL; net = net-&gt;next) {
00148 
00149        <span class="keywordflow">if</span> (net-&gt;cirseg)
00150            cirseg = scm_listify(scm_cons(scm_make_real(net-&gt;cirseg-&gt;cp_x),
00151                                      scm_make_real(net-&gt;cirseg-&gt;cp_y)),
00152                              scm_cons(scm_make_real(net-&gt;cirseg-&gt;width),
00153                                      scm_make_real(net-&gt;cirseg-&gt;height)),
00154                              scm_cons(SCM_MAKINUM(net-&gt;cirseg-&gt;angle1),
00155                                      SCM_MAKINUM(net-&gt;cirseg-&gt;angle2)),
00156                              SCM_UNDEFINED);
00157        <span class="keywordflow">else</span>
00158            cirseg = SCM_EOL;
00159 
00160        netlist = scm_cons(scm_listify(scm_cons(scm_make_real(net-&gt;start_x), 
00161                                           scm_make_real(net-&gt;start_y)),
00162                                    scm_cons(scm_make_real(net-&gt;stop_x), 
00163                                           scm_make_real(net-&gt;stop_y)),
00164                                    scm_cons(SCM_MAKINUM(net-&gt;aperture), 
00165                                           scm_aperture_state2scm(net-&gt;aperture_state)),
00166                                    scm_interpolation2scm(net-&gt;interpolation),
00167                                    cirseg,
00168                                    SCM_UNDEFINED),
00169                         netlist);
00170     }
00171     
00172     <span class="comment">/*</span>
00173 <span class="comment">     * Convert aperture definitions</span>
00174 <span class="comment">     */</span>
00175     <span class="keywordflow">for</span> (i = 0; i &lt; APERTURE_MAX; i++) {
00176        <span class="keywordflow">if</span> (image-&gt;aperture[i] != NULL) {
00177            SCM a = SCM_EOL;
00178            <span class="keywordflow">for</span> (j = image-&gt;aperture[i]-&gt;nuf_parameters; j != 0; j--)
00179               a = scm_cons(scm_make_real(image-&gt;aperture[i]-&gt;parameter[j - 1]), a);
00180            a = scm_cons(scm_aperture2scm(image-&gt;aperture[i]-&gt;type), a);
00181            a = scm_cons(SCM_MAKINUM(i), a);
00182            aperture = scm_cons(a, aperture);
00183        }
00184     }
00185     <span class="comment">/*</span>
00186 <span class="comment">     * Convert format specification</span>
00187 <span class="comment">     */</span>
00188     <span class="keywordflow">if</span> (image-&gt;format != NULL) {
00189        format = scm_listify(scm_cons(gh_symbol2scm(<span class="stringliteral">"omit-zeros\0"</span>),
00190                                   scm_omit_zeros2scm(image-&gt;format-&gt;omit_zeros)),
00191                           scm_cons(gh_symbol2scm(<span class="stringliteral">"coordinate\0"</span>),
00192                                   gh_symbol2scm((image-&gt;format-&gt;coordinate == ABSOLUTE) ? 
00193                                               <span class="stringliteral">"absolute"</span> : <span class="stringliteral">"incremental"</span>)),
00194                           scm_cons(gh_symbol2scm(<span class="stringliteral">"x-integer\0"</span>), 
00195                                   SCM_MAKINUM(image-&gt;format-&gt;x_int)),
00196                           scm_cons(gh_symbol2scm(<span class="stringliteral">"x-decimal\0"</span>), 
00197                                   SCM_MAKINUM(image-&gt;format-&gt;x_dec)),
00198                           scm_cons(gh_symbol2scm(<span class="stringliteral">"y-integer\0"</span>), 
00199                                   SCM_MAKINUM(image-&gt;format-&gt;y_int)),
00200                           scm_cons(gh_symbol2scm(<span class="stringliteral">"y-decimal\0"</span>), 
00201                                   SCM_MAKINUM(image-&gt;format-&gt;y_dec)),
00202                           SCM_UNDEFINED);
00203     }
00204     
00205     <span class="comment">/*</span>
00206 <span class="comment">     * Convert image information </span>
00207 <span class="comment">     */</span>
00208     <span class="keywordflow">if</span> (image-&gt;info-&gt;polarity == NEGATIVE) 
00209        info = scm_cons(scm_cons(gh_symbol2scm(<span class="stringliteral">"polarity"</span>),
00210                              gh_symbol2scm(<span class="stringliteral">"negative"</span>)),
00211                      info);
00212     <span class="keywordflow">else</span>
00213        info = scm_cons(scm_cons(gh_symbol2scm(<span class="stringliteral">"polarity"</span>),
00214                              gh_symbol2scm(<span class="stringliteral">"positive"</span>)),
00215                      info);
00216     
00217     info = scm_cons(scm_cons(gh_symbol2scm(<span class="stringliteral">"unit"</span>),
00218                           gh_symbol2scm((image-&gt;info-&gt;unit == MM) ? <span class="stringliteral">"mm"</span> : <span class="stringliteral">"inch"</span>)),
00219                   info);
00220     
00221     info = scm_cons(scm_cons(gh_symbol2scm(<span class="stringliteral">"min-x"</span>),
00222                           scm_make_real(image-&gt;info-&gt;min_x)),
00223                   info);
00224     info = scm_cons(scm_cons(gh_symbol2scm(<span class="stringliteral">"min-y"</span>),
00225                           scm_make_real(image-&gt;info-&gt;min_y)),
00226                   info);
00227     info = scm_cons(scm_cons(gh_symbol2scm(<span class="stringliteral">"max-x"</span>),
00228                           scm_make_real(image-&gt;info-&gt;max_x)),
00229                   info);
00230     info = scm_cons(scm_cons(gh_symbol2scm(<span class="stringliteral">"max-y"</span>),
00231                           scm_make_real(image-&gt;info-&gt;max_y)),
00232                   info);
00233     
00234     info = scm_cons(scm_cons(gh_symbol2scm(<span class="stringliteral">"offset-a"</span>),
00235                           scm_make_real(image-&gt;info-&gt;offset_a)),
00236                   info);
00237     
00238     info = scm_cons(scm_cons(gh_symbol2scm(<span class="stringliteral">"offset-b"</span>),
00239                           scm_make_real(image-&gt;info-&gt;offset_b)),
00240                   info);
00241     
00242     
00243     <span class="keywordflow">return</span> scm_listify(netlist, aperture, info, format, 
00244                      scm_makfrom0str(filename), SCM_UNDEFINED);
00245     
00246 } <span class="comment">/* scm_image2scm */</span>
00247 
00248 
00249 <span class="keywordtype">void</span>
00250 batch(<span class="keywordtype">char</span> *backend, <span class="keywordtype">char</span> *filename)
00251 {
00252     <span class="keywordtype">char</span>         *path[3];
00253     <span class="keywordtype">char</span>       *complete_path;
00254     <span class="keywordtype">char</span>         *home;
00255     <span class="keywordtype">int</span>                i;
00256     gerb_file_t  *fd;
00257     gerb_image_t *image;
00258     gerb_verify_error_t error = GERB_IMAGE_OK;
00259     SCM                 scm_image;
00260 
00261     <span class="keywordflow">if</span> ((home = getenv(<span class="stringliteral">"HOME"</span>)) == NULL)
00262        err(1, <span class="stringliteral">"HOME not set\n"</span>);
00263 
00264     <span class="comment">/*</span>
00265 <span class="comment">     * Define the paths to look for backend in:</span>
00266 <span class="comment">     * path[0] = current directory where gerbv was invoked from</span>
00267 <span class="comment">     * path[1] = $HOME/.gerbv/scheme</span>
00268 <span class="comment">     * path[2] = BACKEND_DIR defined with ./configure --with-backend-dir=XX,</span>
00269 <span class="comment">     *           default /usr/local/share/gerbv/scheme</span>
00270 <span class="comment">     */</span>
00271     <span class="keywordflow">if</span> ((path[0] = (<span class="keywordtype">char</span> *)malloc(strlen(<span class="stringliteral">"."</span>) + 1)) == NULL)
00272        err(1, <span class="stringliteral">"Malloc failed\n"</span>);
00273     strcpy(path[0], <span class="stringliteral">"."</span>);
00274 
00275     <span class="keywordflow">if</span> ((path[1] = (<span class="keywordtype">char</span> *)malloc(strlen(home) + strlen(<span class="stringliteral">"/.gerbv/scheme"</span>) + 1)) == NULL)
00276        err(1, <span class="stringliteral">"Malloc failed\n"</span>);
00277     strcpy(path[1], home);
00278     strcat(path[1], <span class="stringliteral">"/.gerbv/scheme"</span>);
00279 
00280     <span class="keywordflow">if</span> ((path[2] = (<span class="keywordtype">char</span> *)malloc(strlen(BACKEND_DIR) + 1)) == NULL)
00281        err(1, <span class="stringliteral">"Malloc failed\n"</span>);
00282     strcpy(path[2], BACKEND_DIR);
00283 
00284     <span class="comment">/*</span>
00285 <span class="comment">     * Search for backend along the paths. Break when you find one.</span>
00286 <span class="comment">     */</span>
00287     <span class="keywordflow">for</span> (i = 0; i &lt; <span class="keyword">sizeof</span>(path)/<span class="keyword">sizeof</span>(path[0]); i++) {
00288        complete_path = (<span class="keywordtype">char</span> *)malloc(strlen(path[i]) + strlen(backend) + 2);
00289        strcpy(complete_path, path[i]);
00290        strcat(complete_path, <span class="stringliteral">"/"</span>);
00291        strcat(complete_path, backend);
00292        <span class="keywordflow">if</span> (access(complete_path, R_OK) != -1)
00293            <span class="keywordflow">break</span>;
00294        free(complete_path);
00295        complete_path = NULL;
00296     }
00297 
00298     <span class="comment">/*</span>
00299 <span class="comment">     * Make sure all allocated path strings above are deallocated</span>
00300 <span class="comment">     */</span>
00301     <span class="keywordflow">for</span> (i = 0; i &lt; <span class="keyword">sizeof</span>(path)/<span class="keyword">sizeof</span>(path[0]); i++) {
00302        free(path[i]);
00303        path[i] = NULL;
00304     }
00305 
00306     <span class="comment">/*</span>
00307 <span class="comment">     * Did we find a backend?</span>
00308 <span class="comment">     */</span>
00309     <span class="keywordflow">if</span> (complete_path == NULL) {
00310        printf(<span class="stringliteral">"Backend not found\n"</span>);
00311        <span class="keywordflow">return</span>;
00312     } <span class="keywordflow">else</span> {
00313        printf(<span class="stringliteral">"Backend is [%s]\n"</span>, complete_path);
00314     }
00315 
00316     <span class="comment">/*</span>
00317 <span class="comment">     * Read and parse Gerberfile</span>
00318 <span class="comment">     */</span>
00319     fd = gerb_fopen(filename);
00320     <span class="keywordflow">if</span> (fd == NULL) {
00321        fprintf(stderr, <span class="stringliteral">"Trying to open %s: "</span>, filename);
00322        perror(<span class="stringliteral">"gerbv:batch"</span>);
00323        <span class="keywordflow">return</span>;
00324     }
00325 
00326     <span class="keywordflow">if</span> (drill_file_p(fd))
00327        image = parse_drillfile(fd);
00328     <span class="keywordflow">else</span>
00329        image = parse_gerb(fd);
00330     
00331     gerb_fclose(fd);
00332 
00333     <span class="comment">/*</span>
00334 <span class="comment">     * Do error check before continuing</span>
00335 <span class="comment">     */</span>
00336     error = gerb_image_verify(image);
00337     <span class="keywordflow">if</span> (error) {
00338        fprintf(stderr, <span class="stringliteral">"%s: Parse error: "</span>, filename);
00339        <span class="keywordflow">if</span> (error &amp; GERB_IMAGE_MISSING_NETLIST)
00340            fprintf(stderr, <span class="stringliteral">"Missing netlist "</span>);
00341        <span class="keywordflow">if</span> (error &amp; GERB_IMAGE_MISSING_FORMAT)
00342            fprintf(stderr, <span class="stringliteral">"Missing format "</span>);
00343        <span class="keywordflow">if</span> (error &amp; GERB_IMAGE_MISSING_APERTURES) 
00344            fprintf(stderr, <span class="stringliteral">"Missing apertures/drill sizes "</span>);
00345        <span class="keywordflow">if</span> (error &amp; GERB_IMAGE_MISSING_INFO)
00346            fprintf(stderr, <span class="stringliteral">"Missing info "</span>);
00347        fprintf(stderr, <span class="stringliteral">"\n"</span>);
00348        exit(1);
00349     }
00350    
00351     <span class="comment">/*</span>
00352 <span class="comment">     * Convert it to Scheme</span>
00353 <span class="comment">     */</span>
00354     scm_image = scm_image2scm(image, filename);
00355     
00356     <span class="comment">/*</span>
00357 <span class="comment">     * Call external Scheme function in found backend</span>
00358 <span class="comment">     */</span>
00359     scm_primitive_load(scm_makfrom0str(complete_path));
00360     scm_apply(scm_eval(gh_symbol2scm(<span class="stringliteral">"main"</span>)), scm_image, SCM_EOL);
00361     
00362     <span class="comment">/*</span>
00363 <span class="comment">     * Cleanup</span>
00364 <span class="comment">     */</span>
00365     free(complete_path);
00366     complete_path = NULL;
00367     
00368     free_gerb_image(image);
00369     
00370     <span class="keywordflow">return</span>;
00371 } <span class="comment">/* batch */</span>
00372 
00373 <span class="preprocessor">#endif </span><span class="comment">/* GUILE_IN_USE */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Oct 13 16:09:18 2004 for gerbv by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.8-20040928 </small></address>
</body>
</html>
