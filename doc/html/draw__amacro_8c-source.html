<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gerbv: src/draw_amacro.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8-20040928 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a></div>
<h1>draw_amacro.c</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * gEDA - GNU Electronic Design Automation</span>
00003 <span class="comment"> * This file is a part of gerbv.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> *   Copyright (C) 2000-2002 Stefan Petersen (spe@stacken.kth.se)</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> * $Id$</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
00010 <span class="comment"> * it under the terms of the GNU General Public License as published by</span>
00011 <span class="comment"> * the Free Software Foundation; either version 2 of the License, or</span>
00012 <span class="comment"> * (at your option) any later version.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
00015 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00016 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00017 <span class="comment"> * GNU General Public License for more details.</span>
00018 <span class="comment"> *</span>
00019 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
00020 <span class="comment"> * along with this program; if not, write to the Free Software</span>
00021 <span class="comment"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA</span>
00022 <span class="comment"> */</span>
00023 
00024 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00025 <span class="preprocessor"></span><span class="preprocessor">#include &lt;config.h&gt;</span>
00026 <span class="preprocessor">#endif</span>
00027 <span class="preprocessor"></span>
00028 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00029 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00030 <span class="preprocessor">#include &lt;math.h&gt;</span> <span class="comment">/* M_PI */</span>
00031 
00032 <span class="preprocessor">#ifdef HAVE_STRING_H</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#include &lt;string.h&gt;</span>
00034 <span class="preprocessor">#endif</span>
00035 <span class="preprocessor"></span>
00036 <span class="preprocessor">#include &lt;gtk/gtk.h&gt;</span>
00037 
00038 <span class="preprocessor">#include "draw_amacro.h"</span>
00039 
00040 <span class="preprocessor">#undef round</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#define round(x) floor((double)(x) + 0.5)</span>
00042 <span class="preprocessor"></span>
00043 
00044 <span class="comment">/*</span>
00045 <span class="comment"> * Stack declarations and operations to be used by the simple engine that</span>
00046 <span class="comment"> * executes the parsed aperture macros.</span>
00047 <span class="comment"> */</span>
00048 <span class="keyword">typedef</span> <span class="keyword">struct </span>{
00049     <span class="keywordtype">double</span> *stack;
00050     <span class="keywordtype">int</span> sp;
00051 } stack_t;
00052 
00053 
00054 <span class="keyword">static</span> stack_t *
00055 new_stack(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nuf_push)
00056 {
00057     <span class="keyword">const</span> <span class="keywordtype">int</span> extra_stack_size = 10;
00058     stack_t *s;
00059 
00060     s = (stack_t *)malloc(<span class="keyword">sizeof</span>(stack_t));
00061     <span class="keywordflow">if</span> (!s) {
00062        free(s);
00063        <span class="keywordflow">return</span> NULL;
00064     }
00065     memset(s, 0, <span class="keyword">sizeof</span>(stack_t));
00066 
00067     s-&gt;stack = (<span class="keywordtype">double</span> *)malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) * (nuf_push + extra_stack_size));
00068     <span class="keywordflow">if</span> (!s-&gt;stack) {
00069        free(s-&gt;stack);
00070        <span class="keywordflow">return</span> NULL;
00071     }
00072 
00073     memset(s-&gt;stack, 0, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) * (nuf_push + extra_stack_size));
00074     s-&gt;sp = 0;
00075 
00076     <span class="keywordflow">return</span> s;
00077 } <span class="comment">/* new_stack */</span>
00078 
00079 
00080 <span class="keyword">static</span> <span class="keywordtype">void</span>
00081 free_stack(stack_t *s)
00082 {
00083     <span class="keywordflow">if</span> (s &amp;&amp; s-&gt;stack)
00084        free(s-&gt;stack);
00085 
00086     <span class="keywordflow">if</span> (s)
00087        free(s);
00088 
00089     <span class="keywordflow">return</span>;
00090 } <span class="comment">/* free_stack */</span>
00091 
00092 
00093 <span class="keyword">static</span> <span class="keywordtype">void</span>
00094 push(stack_t *s, <span class="keywordtype">double</span> val)
00095 {
00096     s-&gt;stack[s-&gt;sp++] = val;
00097     <span class="keywordflow">return</span>;
00098 } <span class="comment">/* push */</span>
00099 
00100 
00101 <span class="keyword">static</span> <span class="keywordtype">double</span>
00102 pop(stack_t *s)
00103 {
00104     <span class="keywordflow">return</span> s-&gt;stack[--s-&gt;sp];
00105 } <span class="comment">/* pop */</span>
00106 
00107 
00108 <span class="comment">/*</span>
00109 <span class="comment"> * If you want to rotate a</span>
00110 <span class="comment"> * column vector v by t degrees using matrix M, use</span>
00111 <span class="comment"> *</span>
00112 <span class="comment"> *   M = {{cos t, -sin t}, {sin t, cos t}} in M*v.</span>
00113 <span class="comment"> *</span>
00114 <span class="comment"> * From comp.graphics.algorithms Frequently Asked Questions</span>
00115 <span class="comment"> *</span>
00116 <span class="comment"> * Due reverse defintion of X-axis in GTK you have to negate</span>
00117 <span class="comment"> * angels.</span>
00118 <span class="comment"> *</span>
00119 <span class="comment"> */</span>
00120 <span class="keyword">static</span> GdkPoint 
00121 rotate_point(GdkPoint point, <span class="keywordtype">int</span> angle)
00122 {
00123     <span class="keywordtype">double</span> sint, cost;
00124     GdkPoint returned;
00125     
00126     <span class="keywordflow">if</span> (angle == 0)
00127        <span class="keywordflow">return</span> point;
00128 
00129     sint = sin(-(<span class="keywordtype">double</span>)angle * M_PI / 180.0);
00130     cost = cos(-(<span class="keywordtype">double</span>)angle * M_PI / 180.0);
00131     
00132     returned.x = (int)round(cost * (<span class="keywordtype">double</span>)point.x - sint * (<span class="keywordtype">double</span>)point.y);
00133     returned.y = (int)round(sint * (<span class="keywordtype">double</span>)point.x + cost * (<span class="keywordtype">double</span>)point.y);
00134     
00135     <span class="keywordflow">return</span> returned;
00136 }
00137 
00138 
00139 <span class="comment">/*</span>
00140 <span class="comment"> * Doesn't handle explicit x,y yet</span>
00141 <span class="comment"> */</span>
00142 <span class="keyword">static</span> <span class="keywordtype">void</span>
00143 gerbv_draw_prim1(GdkPixmap *pixmap, GdkGC *gc, stack_t *s, <span class="keywordtype">int</span> scale,
00144                gint x, gint y)
00145 {
00146     <span class="keyword">const</span> <span class="keywordtype">int</span> exposure_idx = 0;
00147     <span class="keyword">const</span> <span class="keywordtype">int</span> diameter_idx = 1;
00148     <span class="keyword">const</span> gint full_circle = 23360;
00149     GdkGC *local_gc = gdk_gc_new(pixmap);
00150     gint dia    = round(fabs(s-&gt;stack[diameter_idx] * scale));
00151     gint real_x = x - dia / 2;
00152     gint real_y = y - dia / 2;
00153     GdkColor color;
00154 
00155     gdk_gc_copy(local_gc, gc);
00156 
00157     <span class="comment">/* Exposure */</span>
00158     <span class="keywordflow">if</span> (s-&gt;stack[exposure_idx] == 0.0) {
00159        color.pixel = 0;
00160        gdk_gc_set_foreground(local_gc, &amp;color);
00161     }
00162 
00163     gdk_gc_set_line_attributes(local_gc, 
00164                             1, <span class="comment">/* outline always 1 pixels */</span>
00165                             GDK_LINE_SOLID, 
00166                             GDK_CAP_BUTT, 
00167                             GDK_JOIN_MITER);
00168 
00169     <span class="comment">/* </span>
00170 <span class="comment">     * A filled circle </span>
00171 <span class="comment">     */</span>
00172     gdk_draw_arc(pixmap, local_gc, 1, real_x, real_y, dia, dia, 
00173                0, full_circle);
00174 
00175     gdk_gc_unref(local_gc);
00176 
00177     <span class="keywordflow">return</span>;
00178 } <span class="comment">/* gerbv_draw_prim1 */</span>
00179 
00180 
00181 <span class="comment">/*</span>
00182 <span class="comment"> * Doesn't handle explicit x,y yet</span>
00183 <span class="comment"> * Questions:</span>
00184 <span class="comment"> *  - should start point be included in number of points?</span>
00185 <span class="comment"> *  - how thick is the outline?</span>
00186 <span class="comment"> */</span>
00187 <span class="keyword">static</span> <span class="keywordtype">void</span>
00188 gerbv_draw_prim4(GdkPixmap *pixmap, GdkGC *gc, stack_t *s, <span class="keywordtype">int</span> scale,
00189                gint x, gint y)
00190 {
00191     <span class="keyword">const</span> <span class="keywordtype">int</span> exposure_idx = 0;
00192     <span class="keyword">const</span> <span class="keywordtype">int</span> nuf_points_idx = 1;
00193     <span class="keyword">const</span> <span class="keywordtype">int</span> first_x_idx = 2;
00194     <span class="keyword">const</span> <span class="keywordtype">int</span> first_y_idx = 3;
00195     <span class="keyword">const</span> <span class="keywordtype">int</span> rotext_idx = 4;
00196     GdkGC *local_gc = gdk_gc_new(pixmap);
00197     <span class="keywordtype">int</span> nuf_points, point, closed_shape;
00198     <span class="keywordtype">double</span> rotation;
00199     GdkPoint *points;
00200     GdkColor color;
00201 
00202 
00203     nuf_points = (int)s-&gt;stack[nuf_points_idx];
00204     points = (GdkPoint *)malloc(<span class="keyword">sizeof</span>(GdkPoint) * nuf_points);
00205     <span class="keywordflow">if</span> (!points) {
00206        free(points);
00207        <span class="keywordflow">return</span>;
00208     }
00209 
00210     <span class="comment">/*</span>
00211 <span class="comment">     * Closed (ie filled as I interpret it) shape if first and last point</span>
00212 <span class="comment">     * are the same.</span>
00213 <span class="comment">     */</span>
00214     closed_shape = 
00215        (fabs(s-&gt;stack[first_x_idx] - s-&gt;stack[nuf_points * 2 + first_x_idx]) &lt; 0.0001) &amp;&amp;
00216        (fabs(s-&gt;stack[first_y_idx] - s-&gt;stack[nuf_points * 2 + first_y_idx]) &lt; 0.0001);
00217 
00218     rotation = s-&gt;stack[nuf_points * 2 + rotext_idx];
00219     <span class="keywordflow">for</span> (point = 0; point &lt; nuf_points; point++) {
00220        points[point].x = (int)round(scale * s-&gt;stack[point * 2 + first_x_idx]);
00221        points[point].y = -(int)round(scale * s-&gt;stack[point * 2 + first_y_idx]);
00222        <span class="keywordflow">if</span> (rotation &gt; 0.1)
00223            points[point] = rotate_point(points[point], rotation);
00224        points[point].x += x;
00225        points[point].y += y;
00226     }
00227 
00228     gdk_gc_copy(local_gc, gc);
00229 
00230     <span class="comment">/* Exposure */</span>
00231     <span class="keywordflow">if</span> (s-&gt;stack[exposure_idx] == 0.0) {
00232        color.pixel = 0;
00233        gdk_gc_set_foreground(local_gc, &amp;color);
00234     }
00235 
00236     gdk_gc_set_line_attributes(local_gc, 
00237                             1, <span class="comment">/* outline always 1 pixels */</span>
00238                             GDK_LINE_SOLID, 
00239                             GDK_CAP_BUTT, 
00240                             GDK_JOIN_MITER);
00241     gdk_draw_polygon(pixmap, local_gc, closed_shape, points, nuf_points);
00242 
00243     free(points);
00244 
00245     gdk_gc_unref(local_gc);
00246 
00247     <span class="keywordflow">return</span>;
00248 } <span class="comment">/* gerbv_draw_prim4 */</span>
00249 
00250 
00251 <span class="comment">/*</span>
00252 <span class="comment"> * Doesn't handle explicit x,y yet</span>
00253 <span class="comment"> */</span>
00254 <span class="keyword">static</span> <span class="keywordtype">void</span>
00255 gerbv_draw_prim5(GdkPixmap *pixmap, GdkGC *gc, stack_t *s, <span class="keywordtype">int</span> scale,
00256                gint x, gint y)
00257 {
00258     <span class="keyword">const</span> <span class="keywordtype">int</span> exposure_idx = 0;
00259     <span class="keyword">const</span> <span class="keywordtype">int</span> nuf_vertices_idx = 1;
00260     <span class="keyword">const</span> <span class="keywordtype">int</span> diameter_idx = 4;
00261     <span class="keyword">const</span> <span class="keywordtype">int</span> rotation_idx = 5;
00262     <span class="keywordtype">int</span> nuf_vertices, i;
00263     <span class="keywordtype">double</span> vertex, tick, rotation, radius;
00264     GdkPoint *points;
00265     GdkGC *local_gc = gdk_gc_new(pixmap);
00266     GdkColor color;
00267 
00268     <span class="keywordflow">if</span> (s-&gt;sp != 6)
00269        <span class="keywordflow">return</span>;
00270 
00271     nuf_vertices = (int)s-&gt;stack[nuf_vertices_idx];
00272     points = (GdkPoint *)malloc(<span class="keyword">sizeof</span>(GdkPoint) * nuf_vertices);
00273     <span class="keywordflow">if</span> (!points) {
00274        free(points);
00275        <span class="keywordflow">return</span>;
00276     }
00277 
00278     <span class="comment">/* Exposure */</span>
00279     <span class="keywordflow">if</span> (s-&gt;stack[exposure_idx] == 0.0) {
00280        color.pixel = 0;
00281        gdk_gc_set_foreground(local_gc, &amp;color);
00282     }
00283 
00284     tick = 2 * M_PI / (double)nuf_vertices;
00285     rotation = -s-&gt;stack[rotation_idx] * M_PI / 180.0;
00286     radius = s-&gt;stack[diameter_idx] / 2.0;
00287     <span class="keywordflow">for</span> (i = 0; i &lt; nuf_vertices; i++) {
00288        vertex =  tick * (double)i + rotation;
00289        points[i].x = (int)round(scale * radius * cos(vertex)) + x;
00290        points[i].y = (int)round(scale * radius * sin(vertex)) + y;
00291     }
00292 
00293     gdk_draw_polygon(pixmap, gc, 1, points, nuf_vertices);
00294 
00295     gdk_gc_unref(local_gc);
00296 
00297     free(points);
00298     <span class="keywordflow">return</span>;
00299 } <span class="comment">/* gerbv_draw_prim5 */</span>
00300 
00301 
00302 <span class="comment">/*</span>
00303 <span class="comment"> * Doesn't handle and explicit x,y yet</span>
00304 <span class="comment"> * Questions:</span>
00305 <span class="comment"> *  - is "gap" distance between edges of circles or distance between</span>
00306 <span class="comment"> *    center of line of circle?</span>
00307 <span class="comment"> */</span>
00308 <span class="keyword">static</span> <span class="keywordtype">void</span>
00309 gerbv_draw_prim6(GdkPixmap *pixmap, GdkGC *gc, stack_t *s, <span class="keywordtype">int</span> scale,
00310                gint x, gint y)
00311 {
00312     <span class="keyword">const</span> <span class="keywordtype">int</span> outside_dia_idx = 2;
00313     <span class="keyword">const</span> <span class="keywordtype">int</span> ci_thickness_idx = 3;
00314     <span class="keyword">const</span> <span class="keywordtype">int</span> gap_idx = 4;
00315     <span class="keyword">const</span> <span class="keywordtype">int</span> nuf_circles_idx = 5;
00316     <span class="keyword">const</span> <span class="keywordtype">int</span> ch_thickness_idx = 6;
00317     <span class="keyword">const</span> <span class="keywordtype">int</span> ch_length_idx = 7;
00318     <span class="keyword">const</span> <span class="keywordtype">int</span> rotation_idx = 8;
00319     GdkGC *local_gc = gdk_gc_new(pixmap);
00320     <span class="keywordtype">double</span> real_dia;
00321     <span class="keywordtype">double</span> real_gap;
00322     <span class="keywordtype">int</span> circle;
00323     GdkPoint crosshair[4];
00324     <span class="keywordtype">int</span> point;
00325 
00326     gdk_gc_copy(local_gc, gc);
00327     gdk_gc_set_line_attributes(local_gc, 
00328                             (<span class="keywordtype">int</span>)round(scale * s-&gt;stack[ci_thickness_idx]),
00329                             GDK_LINE_SOLID, 
00330                             GDK_CAP_BUTT, 
00331                             GDK_JOIN_MITER);
00332 
00333     real_dia = s-&gt;stack[outside_dia_idx] -  s-&gt;stack[ci_thickness_idx] / 2.0;
00334     real_gap = s-&gt;stack[gap_idx] + s-&gt;stack[ci_thickness_idx];
00335 
00336     <span class="keywordflow">for</span> (circle = 0; circle != (int)s-&gt;stack[nuf_circles_idx];  circle++) {
00337        <span class="comment">/* </span>
00338 <span class="comment">        * Non filled circle </span>
00339 <span class="comment">        */</span>
00340        <span class="keyword">const</span> gint full_circle = 23360;
00341        gint dia = (real_dia - real_gap * circle) * scale;
00342        gdk_draw_arc(pixmap, local_gc, 0, x - dia / 2, y - dia / 2, 
00343                    dia, dia, 0, full_circle);
00344                        
00345     }
00346 
00347     <span class="comment">/*</span>
00348 <span class="comment">     * Cross Hair </span>
00349 <span class="comment">     */</span>
00350     memset(crosshair, 0, <span class="keyword">sizeof</span>(GdkPoint) * 4);
00351     crosshair[0].x = (int)((s-&gt;stack[ch_length_idx] / 2.0) * scale);
00352     <span class="comment">/*crosshair[0].y = 0;*/</span>
00353     crosshair[1].x = -crosshair[0].x;
00354     <span class="comment">/*crosshair[1].y = 0;*/</span>
00355     <span class="comment">/*crosshair[2].x = 0;*/</span>
00356     crosshair[2].y = crosshair[0].x;
00357     <span class="comment">/*crosshair[3].x = 0;*/</span>
00358     crosshair[3].y = -crosshair[0].x;
00359 
00360     gdk_gc_set_line_attributes(local_gc, 
00361                             (<span class="keywordtype">int</span>)round(scale * s-&gt;stack[ch_thickness_idx]),
00362                             GDK_LINE_SOLID, 
00363                             GDK_CAP_BUTT, 
00364                             GDK_JOIN_MITER);
00365 
00366     <span class="keywordflow">for</span> (point = 0; point &lt; 4; point++) {
00367        crosshair[point] = rotate_point(crosshair[point], 
00368                                    s-&gt;stack[rotation_idx]);
00369        crosshair[point].x += x;
00370        crosshair[point].y += y;
00371     }
00372     gdk_draw_line(pixmap, local_gc, 
00373                 crosshair[0].x, crosshair[0].y, 
00374                 crosshair[1].x, crosshair[1].y);
00375     gdk_draw_line(pixmap, local_gc, 
00376                 crosshair[2].x, crosshair[2].y, 
00377                 crosshair[3].x, crosshair[3].y);
00378 
00379     gdk_gc_unref(local_gc);
00380 
00381     <span class="keywordflow">return</span>;
00382 } <span class="comment">/* gerbv_draw_prim6 */</span>
00383 
00384 
00385 <span class="keyword">static</span> <span class="keywordtype">void</span>
00386 gerbv_draw_prim7(GdkPixmap *pixmap, GdkGC *gc, stack_t *s, <span class="keywordtype">int</span> scale,
00387                gint x, gint y)
00388 {
00389     <span class="keyword">const</span> <span class="keywordtype">int</span> outside_dia_idx = 2;
00390     <span class="keyword">const</span> <span class="keywordtype">int</span> inside_dia_idx = 3;
00391     <span class="keyword">const</span> <span class="keywordtype">int</span> ch_thickness_idx = 4;
00392     <span class="keyword">const</span> <span class="keywordtype">int</span> rotation_idx = 5;
00393     <span class="keyword">const</span> gint full_circle = 23360;
00394     GdkGCValues gc_val;
00395     <span class="keywordtype">int</span> diameter, i;
00396     GdkGC *local_gc = gdk_gc_new(pixmap);
00397     GdkPoint point[4];
00398     <span class="keywordtype">double</span> ci_thickness = (s-&gt;stack[outside_dia_idx] - 
00399                      s-&gt;stack[inside_dia_idx]) / 2.0;
00400 
00401     gdk_gc_copy(local_gc, gc);
00402     gdk_gc_set_line_attributes(local_gc, 
00403                             (<span class="keywordtype">int</span>)round(scale * ci_thickness),
00404                             GDK_LINE_SOLID, 
00405                             GDK_CAP_BUTT, 
00406                             GDK_JOIN_MITER);
00407 
00408     <span class="comment">/* </span>
00409 <span class="comment">     * Non filled circle </span>
00410 <span class="comment">     */</span>
00411     diameter = (s-&gt;stack[inside_dia_idx] + ci_thickness) * scale;
00412     gdk_draw_arc(pixmap, local_gc, 0, x - diameter / 2, y - diameter / 2, 
00413                diameter, diameter, 0, full_circle);
00414 
00415     <span class="comment">/*</span>
00416 <span class="comment">     * Cross hair</span>
00417 <span class="comment">     */</span> 
00418     <span class="comment">/* Calculate the end points of the crosshair */</span>    
00419     <span class="comment">/* GDK doesn't always remove all of the circle (round of error probably)</span>
00420 <span class="comment">       I extend the crosshair line with 2 (one pixel in each end) to make </span>
00421 <span class="comment">       sure all of the circle is removed with the crosshair */</span>
00422     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
00423        point[i].x = round((s-&gt;stack[outside_dia_idx] / 2.0) * scale) + 2;
00424        point[i].y = 0;
00425        point[i] = rotate_point(point[i], s-&gt;stack[rotation_idx] + 90 * i);
00426        point[i].x += x;
00427        point[i].y += y;
00428     }
00429 
00430     gdk_gc_set_line_attributes(local_gc, 
00431                             (<span class="keywordtype">int</span>)round(scale * s-&gt;stack[ch_thickness_idx]),
00432                             GDK_LINE_SOLID, 
00433                             GDK_CAP_BUTT, 
00434                             GDK_JOIN_MITER);
00435 
00436     <span class="comment">/* The cross hair should "cut out" parts of the circle, hence inverse */</span>
00437     gdk_gc_get_values(local_gc, &amp;gc_val);
00438     <span class="keywordflow">if</span> (gc_val.foreground.pixel == 1)
00439        gc_val.foreground.pixel = 0;
00440     <span class="keywordflow">else</span>
00441        gc_val.foreground.pixel = 1;
00442     gdk_gc_set_foreground(local_gc, &amp;(gc_val.foreground));
00443 
00444     <span class="comment">/* Draw the actual cross */</span>
00445     gdk_draw_line(pixmap, local_gc, 
00446                 point[0].x, point[0].y, point[2].x, point[2].y);
00447     gdk_draw_line(pixmap, local_gc,
00448                 point[1].x, point[1].y, point[3].x, point[3].y);
00449 
00450     gdk_gc_unref(local_gc);
00451 
00452     <span class="keywordflow">return</span>;
00453 } <span class="comment">/* gerbv_draw_prim7 */</span>
00454 
00455 
00456 <span class="comment">/*</span>
00457 <span class="comment"> * Doesn't handle and explicit x,y yet</span>
00458 <span class="comment"> */</span>
00459 <span class="keyword">static</span> <span class="keywordtype">void</span>
00460 gerbv_draw_prim20(GdkPixmap *pixmap, GdkGC *gc, stack_t *s, <span class="keywordtype">int</span> scale,
00461                 gint x, gint y)
00462 {
00463     <span class="keyword">const</span> <span class="keywordtype">int</span> exposure_idx = 0;
00464     <span class="keyword">const</span> <span class="keywordtype">int</span> linewidth_idx = 1;
00465     <span class="keyword">const</span> <span class="keywordtype">int</span> start_x_idx = 2;
00466     <span class="keyword">const</span> <span class="keywordtype">int</span> start_y_idx = 3;
00467     <span class="keyword">const</span> <span class="keywordtype">int</span> end_x_idx = 4;
00468     <span class="keyword">const</span> <span class="keywordtype">int</span> end_y_idx = 5;
00469     <span class="keyword">const</span> <span class="keywordtype">int</span> rotation_idx = 6;
00470     <span class="keyword">const</span> <span class="keywordtype">int</span> nuf_points = 2;
00471     GdkGC *local_gc = gdk_gc_new(pixmap);
00472     GdkPoint points[nuf_points];
00473     GdkColor color;
00474     <span class="keywordtype">int</span> i;
00475 
00476     gdk_gc_copy(local_gc, gc);
00477 
00478     <span class="comment">/* Exposure */</span>
00479     <span class="keywordflow">if</span> (s-&gt;stack[exposure_idx] == 0.0) {
00480        color.pixel = 0;
00481        gdk_gc_set_foreground(local_gc, &amp;color);
00482     }
00483 
00484     gdk_gc_set_line_attributes(local_gc, 
00485                             (<span class="keywordtype">int</span>)round(scale * s-&gt;stack[linewidth_idx]),
00486                             GDK_LINE_SOLID, 
00487                             GDK_CAP_BUTT, 
00488                             GDK_JOIN_MITER);
00489 
00490     points[0].x = (s-&gt;stack[start_x_idx] * scale);
00491     points[0].y = (s-&gt;stack[start_y_idx] * scale);
00492     points[1].x = (s-&gt;stack[end_x_idx] * scale);
00493     points[1].y = (s-&gt;stack[end_y_idx] * scale);
00494 
00495     <span class="keywordflow">for</span> (i = 0; i &lt; nuf_points; i++) {
00496        points[i] = rotate_point(points[i], s-&gt;stack[rotation_idx]);
00497        points[i].x = x + points[i].x;
00498        points[i].y = y - points[i].y;
00499     }
00500 
00501     gdk_draw_line(pixmap, local_gc, 
00502                 points[0].x, points[0].y, 
00503                 points[1].x, points[1].y);
00504     
00505     gdk_gc_unref(local_gc);
00506 
00507     <span class="keywordflow">return</span>;
00508 } <span class="comment">/* gerbv_draw_prim20 */</span>
00509 
00510 
00511 <span class="comment">/*</span>
00512 <span class="comment"> * Doesn't handle explicit x,y yet</span>
00513 <span class="comment"> */</span>
00514 <span class="keyword">static</span> <span class="keywordtype">void</span>
00515 gerbv_draw_prim21(GdkPixmap *pixmap, GdkGC *gc, stack_t *s, <span class="keywordtype">int</span> scale,
00516                 gint x, gint y)
00517 {
00518     <span class="keyword">const</span> <span class="keywordtype">int</span> exposure_idx = 0;
00519     <span class="keyword">const</span> <span class="keywordtype">int</span> width_idx = 1;
00520     <span class="keyword">const</span> <span class="keywordtype">int</span> height_idx = 2;
00521     <span class="keyword">const</span> <span class="keywordtype">int</span> rotation_idx = 5;
00522     <span class="keyword">const</span> <span class="keywordtype">int</span> nuf_points = 4;
00523     GdkPoint points[nuf_points];
00524     GdkColor color;
00525     GdkGC *local_gc = gdk_gc_new(pixmap);
00526     <span class="keywordtype">int</span> half_width, half_height;
00527     <span class="keywordtype">int</span> i;
00528 
00529     half_width = (int)round(s-&gt;stack[width_idx] * scale / 2.0);
00530     half_height =(<span class="keywordtype">int</span>)round(s-&gt;stack[height_idx] * scale / 2.0);
00531 
00532     points[0].x = half_width;
00533     points[0].y = half_height;
00534 
00535     points[1].x = half_width;
00536     points[1].y = -half_height;
00537 
00538     points[2].x = -half_width;
00539     points[2].y = -half_height;
00540 
00541     points[3].x = -half_width;
00542     points[3].y = half_height;
00543 
00544     for (i = 0; i &lt; nuf_points; i++) {
00545        points[i] = rotate_point(points[i], s-&gt;stack[rotation_idx]);
00546        points[i].x += x;
00547        points[i].y += y;
00548     }
00549 
00550     <span class="comment">/* Exposure */</span>
00551     <span class="keywordflow">if</span> (s-&gt;stack[exposure_idx] == 0.0) {
00552        color.pixel = 0;
00553        gdk_gc_set_foreground(local_gc, &amp;color);
00554     }
00555 
00556     gdk_draw_polygon(pixmap, gc, 1, points, nuf_points);
00557 
00558     gdk_gc_unref(local_gc);
00559 
00560     <span class="keywordflow">return</span>;
00561 } <span class="comment">/* gerbv_draw_prim21 */</span>
00562 
00563 
00564 <span class="comment">/*</span>
00565 <span class="comment"> * Doesn't handle explicit x,y yet</span>
00566 <span class="comment"> */</span>
00567 <span class="keyword">static</span> <span class="keywordtype">void</span>
00568 gerbv_draw_prim22(GdkPixmap *pixmap, GdkGC *gc, stack_t *s, <span class="keywordtype">int</span> scale,
00569                 gint x, gint y)
00570 {
00571     <span class="keyword">const</span> <span class="keywordtype">int</span> exposure_idx = 0;
00572     <span class="keyword">const</span> <span class="keywordtype">int</span> width_idx = 1;
00573     <span class="keyword">const</span> <span class="keywordtype">int</span> height_idx = 2;
00574     <span class="keyword">const</span> <span class="keywordtype">int</span> x_lower_left_idx = 3;
00575     <span class="keyword">const</span> <span class="keywordtype">int</span> y_lower_left_idx = 4;
00576     <span class="keyword">const</span> <span class="keywordtype">int</span> rotation_idx = 5;
00577     <span class="keyword">const</span> <span class="keywordtype">int</span> nuf_points = 4;
00578     GdkPoint points[nuf_points];
00579     GdkGC *local_gc = gdk_gc_new(pixmap);
00580     GdkColor color;
00581     <span class="keywordtype">int</span> i;
00582 
00583     points[0].x = (int)round(s-&gt;stack[x_lower_left_idx] * scale);
00584     points[0].y = (int)round(s-&gt;stack[y_lower_left_idx] * scale);
00585 
00586     points[1].x = (int)round((s-&gt;stack[x_lower_left_idx] + s-&gt;stack[width_idx])
00587                           * scale);
00588     points[1].y = (int)round(s-&gt;stack[y_lower_left_idx] * scale);
00589 
00590     points[2].x = (int)round((s-&gt;stack[x_lower_left_idx]  + s-&gt;stack[width_idx])
00591                           * scale);
00592     points[2].y = (int)round((s-&gt;stack[y_lower_left_idx]  - s-&gt;stack[height_idx])
00593                           * scale);
00594 
00595     points[3].x = (int)round(s-&gt;stack[x_lower_left_idx] * scale);
00596     points[3].y = (int)round((s-&gt;stack[y_lower_left_idx] - s-&gt;stack[height_idx])
00597                           * scale);
00598 
00599     <span class="keywordflow">for</span> (i = 0; i &lt; nuf_points; i++) {
00600        points[i] = rotate_point(points[i], s-&gt;stack[rotation_idx]);
00601        points[i].x += x;
00602        points[i].y += y;
00603     }
00604     
00605     <span class="comment">/* Exposure */</span>
00606     <span class="keywordflow">if</span> (s-&gt;stack[exposure_idx] == 0.0) {
00607        color.pixel = 0;
00608        gdk_gc_set_foreground(local_gc, &amp;color);
00609     }
00610 
00611     gdk_draw_polygon(pixmap, gc, 1, points, nuf_points);
00612 
00613     gdk_gc_unref(local_gc);
00614 
00615     <span class="keywordflow">return</span>;
00616 } <span class="comment">/* gerbv_draw_prim22 */</span>
00617 
00618 
00619 <span class="keywordtype">int</span>
00620 gerbv_draw_amacro(GdkPixmap *pixmap, GdkGC *gc,
00621                 instruction_t *program, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nuf_push,
00622                 <span class="keywordtype">double</span> *parameters, <a class="code" href="structgerb__transf.html">gerb_transf_t</a> *transf, gint x, gint y)
00623 {
00624     stack_t *s = new_stack(nuf_push);
00625     instruction_t *ip;
00626     <span class="keywordtype">int</span> handled = 1;
00627     
00628     <span class="keywordflow">for</span>(ip = program; ip != NULL; ip = ip-&gt;next) {
00629        <span class="keywordflow">switch</span>(ip-&gt;opcode) {
00630        <span class="keywordflow">case</span> NOP:
00631            <span class="keywordflow">break</span>;
00632        <span class="keywordflow">case</span> PUSH :
00633            push(s, ip-&gt;data.fval);
00634            <span class="keywordflow">break</span>;
00635         <span class="keywordflow">case</span> PPUSH :
00636            push(s, parameters[ip-&gt;data.ival - 1]);
00637            <span class="keywordflow">break</span>;
00638        <span class="keywordflow">case</span> ADD :
00639            push(s, pop(s) + pop(s));
00640            <span class="keywordflow">break</span>;
00641        <span class="keywordflow">case</span> SUB :
00642            push(s, -pop(s) + pop(s));
00643            <span class="keywordflow">break</span>;
00644        <span class="keywordflow">case</span> MUL :
00645            push(s, pop(s) * pop(s));
00646            <span class="keywordflow">break</span>;
00647        <span class="keywordflow">case</span> DIV :
00648            push(s, 1 / ((pop(s) / pop(s))));
00649            <span class="keywordflow">break</span>;
00650        <span class="keywordflow">case</span> PRIM :
00651            <span class="comment">/* </span>
00652 <span class="comment">            * This handles the exposure thing in the aperture macro</span>
00653 <span class="comment">            * The exposure is always the first element on stack independent</span>
00654 <span class="comment">            * of aperture macro.</span>
00655 <span class="comment">            */</span>
00656 <span class="comment">// later TODO            gerb_transf_apply(x,y,transf, &amp;x,&amp;y);</span>
00657            <span class="keywordflow">switch</span>(ip-&gt;data.ival) {
00658            <span class="keywordflow">case</span> 1:
00659               gerbv_draw_prim1(pixmap, gc, s, transf-&gt;<a class="code" href="structgerb__transf.html#o1">scale</a>, x, y);
00660               <span class="keywordflow">break</span>;
00661            <span class="keywordflow">case</span> 4 :
00662               gerbv_draw_prim4(pixmap, gc, s, transf-&gt;<a class="code" href="structgerb__transf.html#o1">scale</a>, x, y);
00663               <span class="keywordflow">break</span>;
00664            <span class="keywordflow">case</span> 5 :
00665               gerbv_draw_prim5(pixmap, gc, s, transf-&gt;<a class="code" href="structgerb__transf.html#o1">scale</a>, x, y);
00666               <span class="keywordflow">break</span>;
00667            <span class="keywordflow">case</span> 6 :
00668               gerbv_draw_prim6(pixmap, gc, s, transf-&gt;<a class="code" href="structgerb__transf.html#o1">scale</a>, x, y);
00669               <span class="keywordflow">break</span>;
00670            <span class="keywordflow">case</span> 7 :
00671               gerbv_draw_prim7(pixmap, gc, s, transf-&gt;<a class="code" href="structgerb__transf.html#o1">scale</a>, x, y);
00672               <span class="keywordflow">break</span>;
00673            <span class="keywordflow">case</span> 2  :
00674            <span class="keywordflow">case</span> 20 :
00675               gerbv_draw_prim20(pixmap, gc, s, transf-&gt;<a class="code" href="structgerb__transf.html#o1">scale</a>, x, y);
00676               <span class="keywordflow">break</span>;
00677            <span class="keywordflow">case</span> 21 :
00678               gerbv_draw_prim21(pixmap, gc, s, transf-&gt;<a class="code" href="structgerb__transf.html#o1">scale</a>, x, y);
00679               <span class="keywordflow">break</span>;
00680            <span class="keywordflow">case</span> 22 :
00681               gerbv_draw_prim22(pixmap, gc, s, transf-&gt;<a class="code" href="structgerb__transf.html#o1">scale</a>, x, y);
00682               <span class="keywordflow">break</span>;
00683            <span class="keywordflow">default</span> :
00684               handled = 0;
00685            }
00686            <span class="comment">/* </span>
00687 <span class="comment">            * Here we reset the stack pointer. It's not general correct</span>
00688 <span class="comment">            * correct to do this, but since I know how the compiler works</span>
00689 <span class="comment">            * I can do this. The correct way to do this should be to </span>
00690 <span class="comment">            * subtract number of used elements in each primitive operation.</span>
00691 <span class="comment">            */</span>
00692            s-&gt;sp = 0;
00693            <span class="keywordflow">break</span>;
00694        <span class="keywordflow">default</span> :
00695            <span class="keywordflow">break</span>;
00696        }
00697     }
00698     free_stack(s);
00699 
00700     <span class="keywordflow">return</span> handled;
00701 } <span class="comment">/* gerbv_draw_amacro */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Oct 13 16:09:18 2004 for gerbv by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.8-20040928 </small></address>
</body>
</html>
