<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gerbv: src/gerbv.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8-20040928 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a></div>
<h1>gerbv.c</h1><a href="gerbv_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * gEDA - GNU Electronic Design Automation</span>
00003 <span class="comment"> * This file is a part of gerbv.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> *   Copyright (C) 2000-2003 Stefan Petersen (spe@stacken.kth.se)</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> * $Id$</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
00010 <span class="comment"> * it under the terms of the GNU General Public License as published by</span>
00011 <span class="comment"> * the Free Software Foundation; either version 2 of the License, or</span>
00012 <span class="comment"> * (at your option) any later version.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
00015 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00016 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00017 <span class="comment"> * GNU General Public License for more details.</span>
00018 <span class="comment"> *</span>
00019 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
00020 <span class="comment"> * along with this program; if not, write to the Free Software</span>
00021 <span class="comment"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA</span>
00022 <span class="comment"> */</span>
00023  
00024  
00050 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#include &lt;config.h&gt;</span>
00052 <span class="preprocessor">#endif</span>
00053 <span class="preprocessor"></span>
00054 <span class="preprocessor">#include &lt;assert.h&gt;</span>
00055 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00056 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00057 <span class="preprocessor">#include &lt;math.h&gt;</span>
00058 <span class="preprocessor">#ifdef HAVE_LIBGEN_H</span>
00059 <span class="preprocessor"></span><span class="preprocessor">#include &lt;libgen.h&gt;</span> <span class="comment">/* dirname */</span>
00060 <span class="preprocessor">#endif</span>
00061 <span class="preprocessor"></span><span class="preprocessor">#include &lt;errno.h&gt;</span>
00062 
00063 <span class="preprocessor">#ifdef HAVE_STRING_H</span>
00064 <span class="preprocessor"></span><span class="preprocessor">#include &lt;string.h&gt;</span>
00065 <span class="preprocessor">#endif</span>
00066 <span class="preprocessor"></span>
00067 <span class="preprocessor">#ifdef HAVE_UNISTD_H</span>
00068 <span class="preprocessor"></span><span class="preprocessor">#include &lt;unistd.h&gt;</span>
00069 <span class="preprocessor">#endif</span>
00070 <span class="preprocessor"></span>
00071 <span class="preprocessor">#include &lt;gtk/gtk.h&gt;</span>
00072 <span class="preprocessor">#include &lt;gdk/gdk.h&gt;</span>
00073 <span class="preprocessor">#include &lt;gdk/gdkkeysyms.h&gt;</span>
00074 
00075 <span class="preprocessor">#ifdef HAVE_GETOPT_H</span>
00076 <span class="preprocessor"></span><span class="preprocessor">#include &lt;getopt.h&gt;</span>
00077 <span class="preprocessor">#endif</span>
00078 <span class="preprocessor"></span>
00079 <span class="preprocessor">#ifdef USE_GTK2</span>
00080 <span class="preprocessor"></span><span class="preprocessor">#include &lt;pango/pango.h&gt;</span>
00081 <span class="preprocessor">#endif</span>
00082 <span class="preprocessor"></span>
00083 <span class="preprocessor">#include &lt;locale.h&gt;</span>
00084 
00085 
00086 <span class="preprocessor">#include "gerber.h"</span>
00087 <span class="preprocessor">#include "drill.h"</span>
00088 <span class="preprocessor">#include "gerb_error.h"</span>
00089 <span class="preprocessor">#include "draw.h"</span>
00090 <span class="preprocessor">#include "color.h"</span>
00091 <span class="preprocessor">#include "gerbv_screen.h"</span>
00092 <span class="preprocessor">#include "gerbv_icon.h"</span>
00093 <span class="preprocessor">#include "log.h"</span>
00094 <span class="preprocessor">#include "setup.h"</span>
00095 <span class="preprocessor">#include "<a class="code" href="project_8h.html">project.h</a>"</span>
00096 <span class="preprocessor">#ifdef EXPORT_PNG</span>
00097 <span class="preprocessor"></span><span class="preprocessor">#include "exportimage.h"</span>
00098 <span class="preprocessor">#endif </span><span class="comment">/* EXPORT_PNG */</span>
00099 <span class="preprocessor">#include "tooltable.h"</span>
00100 <span class="preprocessor">#ifdef USE_GTK2</span>
00101 <span class="preprocessor"></span><span class="preprocessor">#include "search_cb.h"</span>
00102 <span class="preprocessor">#include "search_gui.h"</span>
00103 <span class="preprocessor">#endif</span>
00104 <span class="preprocessor"></span><span class="preprocessor">#include "search_mark.h"</span>
00105 
00106 
00107 <span class="preprocessor">#define WIN_TITLE "Gerber Viewer"</span>
00108 <span class="preprocessor"></span>
00109 
00110 <span class="keyword">typedef</span> <span class="keyword">enum</span> {ZOOM_IN, ZOOM_OUT, ZOOM_FIT, ZOOM_IN_CMOUSE, ZOOM_OUT_CMOUSE, ZOOM_SET } gerbv_zoom_dir_t;
00111 <span class="keyword">typedef</span> <span class="keyword">struct </span>{
00112     gerbv_zoom_dir_t z_dir;
00113     GdkEventButton *z_event;
00114     <span class="keywordtype">int</span> scale;
00115 } gerbv_zoom_data_t;
00116 
00117 
<a name="l00121"></a><a class="code" href="gerbv_8c.html#a0">00121</a> gerbv_screen_t screen;
00122 <span class="preprocessor">#if defined (__MINGW32__)</span>
00123 <span class="preprocessor"></span><span class="keyword">const</span> <span class="keywordtype">char</span> path_separator = <span class="charliteral">'\\'</span>;
00124 <span class="preprocessor">#else</span>
00125 <span class="preprocessor"></span><span class="keyword">const</span> <span class="keywordtype">char</span> path_separator = <span class="charliteral">'/'</span>;
00126 <span class="preprocessor">#endif</span>
00127 <span class="preprocessor"></span>
00128 
00129 <span class="preprocessor">#define SAVE_PROJECT 0</span>
00130 <span class="preprocessor"></span><span class="preprocessor">#define SAVE_AS_PROJECT 1</span>
00131 <span class="preprocessor"></span><span class="preprocessor">#define OPEN_PROJECT 2</span>
00132 <span class="preprocessor"></span>
00133 <span class="keyword">static</span> gint expose_event (GtkWidget *widget, GdkEventExpose *event);
00134 <span class="keyword">static</span> <span class="keywordtype">void</span> draw_zoom_outline(gboolean centered);
00135 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="gerbv_8c.html#a17">draw_measure_distance</a>();
00136 <span class="keyword">static</span> <span class="keywordtype">void</span> swap_layers(GtkWidget *widget, gpointer data);
00137 <span class="keyword">static</span> <span class="keywordtype">void</span> color_selection_popup(GtkWidget *widget, gpointer data);
00138 <span class="keyword">static</span> <span class="keywordtype">void</span> invert_color(GtkWidget *widget, gpointer data);
00139 <span class="keyword">static</span> <span class="keywordtype">void</span> load_file_popup(GtkWidget *widget, gpointer data);
00140 <span class="preprocessor">#ifdef EXPORT_PNG</span>
00141 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> export_png_popup(GtkWidget *widget, gpointer data);
00142 <span class="preprocessor">#endif </span><span class="comment">/* EXPORT_PNG */</span>
00143 <span class="keyword">static</span> <span class="keywordtype">void</span> cb_ok_project(GtkWidget *widget, gpointer data);
00144 <span class="keyword">static</span> <span class="keywordtype">void</span> project_popup(GtkWidget *widget, gpointer data);
00145 <span class="keyword">static</span> <span class="keywordtype">void</span> project_save_cb(GtkWidget *widget, gpointer data);
00146 <span class="keyword">static</span> <span class="keywordtype">void</span> unload_file(GtkWidget *widget, gpointer data);
00147 <span class="keyword">static</span> <span class="keywordtype">void</span> reload_files(GtkWidget *widget, gpointer data);
00148 <span class="keyword">static</span> <span class="keywordtype">void</span> menu_zoom(GtkWidget *widget, gpointer data);
00149 <span class="keyword">static</span> <span class="keywordtype">void</span> si_func(GtkWidget *widget, gpointer data);
00150 <span class="keyword">static</span> <span class="keywordtype">void</span> unit_func(GtkWidget *widget, gpointer data);
00151 <span class="keyword">static</span> <span class="keywordtype">void</span> all_layers_on(GtkWidget *widget, gpointer data);
00152 <span class="keyword">static</span> <span class="keywordtype">void</span> all_layers_off(GtkWidget *widget, gpointer data);
00153 <span class="keyword">static</span> <span class="keywordtype">void</span> load_project(<a class="code" href="structproject__list__t.html">project_list_t</a> *project_list);
00154 <span class="keyword">static</span> <span class="keywordtype">void</span> zoom(GtkWidget *widget, gpointer data);
00155 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="gerbv_8c.html#a35">zoom_outline</a>(GtkWidget *widget, GdkEventButton *event);
00156 gint redraw_pixmap(GtkWidget *widget, <span class="keywordtype">int</span> restart);
00157 <span class="keyword">static</span> <span class="keywordtype">int</span> open_image(<span class="keywordtype">char</span> *filename, <span class="keywordtype">int</span> idx, <span class="keywordtype">int</span> reload);
00158 <span class="keywordtype">void</span> <a class="code" href="gerbv_8c.html#a38">update_statusbar</a>(gerbv_screen_t *scr);
00159 
00160 <span class="keyword">static</span> <span class="keywordtype">void</span> menu_ask_zoom (GtkWidget * widget, gpointer data);
00161 <span class="keyword">static</span> GtkWidget *create_ZoomFactorWindow (<span class="keywordtype">void</span>);
00162 <span class="keyword">static</span> <span class="keywordtype">void</span> zoom_spinbutton1_realize (GtkWidget * widget, gpointer user_data);
00163 GtkWidget *lookup_widget (GtkWidget * widget, <span class="keyword">const</span> gchar * widget_name);
00164 <span class="keyword">static</span> <span class="keywordtype">void</span> zoom_ok_button_clicked (GtkButton * button, gpointer user_data);
00165 <span class="keyword">static</span> <span class="keywordtype">void</span> zoom_cancel_button_clicked (GtkButton * button, gpointer user_data);
00166 
00167 <span class="keywordtype">void</span> rename_main_window(<span class="keywordtype">char</span> *filename, GtkWidget *main_win);
00168 
00169 <span class="keywordtype">void</span>
00170 destroy(GtkWidget *widget, gpointer data)
00171 {
00172     <span class="keywordtype">int</span> i;
00173 
00174     <span class="keywordflow">for</span> (i = 0; i &lt; MAX_FILES; i++) {
00175        <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.file[i] &amp;&amp; <a class="code" href="gerbv_8c.html#a0">screen</a>.file[i]-&gt;image)
00176            free_gerb_image(<a class="code" href="gerbv_8c.html#a0">screen</a>.file[i]-&gt;image);
00177        <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.file[i] &amp;&amp; <a class="code" href="gerbv_8c.html#a0">screen</a>.file[i]-&gt;color)
00178            free(<a class="code" href="gerbv_8c.html#a0">screen</a>.file[i]-&gt;color);
00179        <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.file[i] &amp;&amp; <a class="code" href="gerbv_8c.html#a0">screen</a>.file[i]-&gt;name)
00180            free(<a class="code" href="gerbv_8c.html#a0">screen</a>.file[i]-&gt;name);
00181        <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.file[i])
00182            free(<a class="code" href="gerbv_8c.html#a0">screen</a>.file[i]);
00183     }
00184 
00185     <span class="comment">/* Free all colors allocated */</span>
00186     <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.background)
00187        free(<a class="code" href="gerbv_8c.html#a0">screen</a>.background);
00188     <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.zoom_outline_color)
00189        free(<a class="code" href="gerbv_8c.html#a0">screen</a>.zoom_outline_color);
00190     <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.dist_measure_color)
00191        free(<a class="code" href="gerbv_8c.html#a0">screen</a>.dist_measure_color);
00192 
00193     setup_destroy();
00194 
00195     gtk_main_quit();
00196 } <span class="comment">/* destroy */</span>
00197 
00198 
00199 <span class="keyword">static</span> GtkItemFactoryEntry menu_items[] = {
00200     {<span class="stringliteral">"/_File"</span>,               NULL,     NULL,             0, <span class="stringliteral">"&lt;Branch&gt;"</span>},
00201     {<span class="stringliteral">"/File/_Open Project..."</span>,NULL,    project_popup,    OPEN_PROJECT, NULL},
00202     {<span class="stringliteral">"/File/_Save Project As..."</span>,NULL, project_popup,    SAVE_AS_PROJECT,NULL},
00203     {<span class="stringliteral">"/File/_Save Project"</span>,  NULL,     project_save_cb,  0, NULL},
00204     {<span class="stringliteral">"/File/sep1"</span>,           NULL,     NULL,             0, <span class="stringliteral">"&lt;Separator&gt;"</span>},
00205 <span class="preprocessor">#ifdef USE_GTK2    </span>
00206 <span class="preprocessor"></span>    {<span class="stringliteral">"/File/_Load Pick&amp;Place..."</span>,NULL, load_pnp_file_popup,  0, NULL},
00207     {<span class="stringliteral">"/File/sep1"</span>,           NULL,     NULL,             0, <span class="stringliteral">"&lt;Separator&gt;"</span>},
00208 <span class="preprocessor">#endif    </span>
00209 <span class="preprocessor"></span><span class="preprocessor">#ifdef EXPORT_PNG</span>
00210 <span class="preprocessor"></span>    {<span class="stringliteral">"/File/_Export"</span>,        NULL,     NULL,             0, <span class="stringliteral">"&lt;Branch&gt;"</span>},
00211     {<span class="stringliteral">"/File/_Export/PNG..."</span>, NULL,     export_png_popup, 0, NULL},
00212     {<span class="stringliteral">"/File/sep1"</span>,           NULL,     NULL,             0, <span class="stringliteral">"&lt;Separator&gt;"</span>},
00213 <span class="preprocessor">#endif </span><span class="comment">/* EXPORT_PNG */</span>
00214     {<span class="stringliteral">"/File/Reload"</span>,         <span class="stringliteral">"&lt;alt&gt;R"</span>, reload_files,     0, NULL},
00215     {<span class="stringliteral">"/File/sep2"</span>,           NULL,     NULL,             0, <span class="stringliteral">"&lt;Separator&gt;"</span>},
00216     {<span class="stringliteral">"/File/_Quit"</span>,          <span class="stringliteral">"&lt;alt&gt;Q"</span>, destroy,          0, NULL},
00217     {<span class="stringliteral">"/_Zoom"</span>,               NULL,     NULL,             0, <span class="stringliteral">"&lt;Branch&gt;"</span>},
00218     {<span class="stringliteral">"/Zoom/_Out"</span>,           <span class="stringliteral">"&lt;alt&gt;O"</span>, menu_zoom,        ZOOM_OUT, NULL},
00219     {<span class="stringliteral">"/Zoom/_In"</span>,            <span class="stringliteral">"&lt;alt&gt;I"</span>, menu_zoom,        ZOOM_IN, NULL},
00220     {<span class="stringliteral">"/Zoom/sep3"</span>,           NULL,     NULL,             0,  <span class="stringliteral">"&lt;Separator&gt;"</span>},
00221     {<span class="stringliteral">"/Zoom/_Fit"</span>,           NULL,     menu_zoom,        ZOOM_FIT, NULL},
00222     {<span class="stringliteral">"/Zoom/_Set scale"</span>,     NULL,     menu_ask_zoom,    0, NULL},
00223     {<span class="stringliteral">"/_Setup"</span>,              NULL,     NULL,             0, <span class="stringliteral">"&lt;Branch&gt;"</span>},
00224 
00225     {<span class="stringliteral">"/Setup/_Superimpose"</span>,  NULL,     NULL,             0, <span class="stringliteral">"&lt;Branch&gt;"</span>},
00226     {<span class="stringliteral">"/Setup/_Superimpose/Copy"</span>,NULL, si_func, 0, <span class="stringliteral">"&lt;RadioItem&gt;"</span>},
00227     {<span class="stringliteral">"/Setup/_Superimpose/And"</span>, NULL, si_func, GDK_AND,  <span class="stringliteral">"/Setup/Superimpose/Copy"</span>},
00228     {<span class="stringliteral">"/Setup/_Superimpose/Or"</span>,  NULL, si_func, GDK_OR,   <span class="stringliteral">"/Setup/Superimpose/Copy"</span>},
00229     {<span class="stringliteral">"/Setup/_Superimpose/Xor"</span>, NULL, si_func, GDK_XOR,  <span class="stringliteral">"/Setup/Superimpose/Copy"</span>},
00230     {<span class="stringliteral">"/Setup/_Superimpose/Invert"</span>, NULL, si_func, GDK_INVERT,  <span class="stringliteral">"/Setup/Superimpose/Copy"</span>},
00231 
00232     {<span class="stringliteral">"/Setup/_Background Color"</span>,NULL, color_selection_popup, 1, NULL},
00233     {<span class="stringliteral">"/Setup/_Units"</span>,  NULL,     NULL,             0, <span class="stringliteral">"&lt;Branch&gt;"</span>},
00234     {<span class="stringliteral">"/Setup/_Units/m_ils"</span>,NULL, unit_func, GERBV_MILS, <span class="stringliteral">"&lt;RadioItem&gt;"</span>},
00235     {<span class="stringliteral">"/Setup/_Units/_mm"</span>,NULL, unit_func, GERBV_MMS, <span class="stringliteral">"/Setup/Units/mils"</span>},
00236 };
00237 
00238 <span class="keyword">static</span> GtkItemFactoryEntry popup_menu_items[] = {
00239     {<span class="stringliteral">"/Swap with Above"</span>, NULL, swap_layers, 0, NULL},
00240     {<span class="stringliteral">"/Layer Color..."</span>, NULL, color_selection_popup, 0, NULL},
00241     {<span class="stringliteral">"/Load File..."</span>, NULL, load_file_popup, 0, NULL},
00242     {<span class="stringliteral">"/Unload File..."</span>, NULL, unload_file, 0, NULL},
00243     {<span class="stringliteral">"/Invert Color"</span>, NULL, invert_color, 0, NULL},
00244     {<span class="stringliteral">"/Swap with Below"</span>, NULL, swap_layers, 1, NULL},
00245 };
00246 
00247 
00248 <span class="keywordtype">void</span>
00249 create_menubar(GtkWidget *window, GtkWidget **menubar)
00250 {
00251     <span class="keywordtype">int</span> nmenu_items = <span class="keyword">sizeof</span>(menu_items) / <span class="keyword">sizeof</span>(menu_items[0]);
00252     GtkItemFactory *item_factory;
00253     GtkAccelGroup  *accel_group;
00254     
00255     accel_group = gtk_accel_group_new();
00256 
00257     <span class="comment">/* This function initializes the item factory.</span>
00258 <span class="comment">       Param 1: The type of menu - can be GTK_TYPE_MENU_BAR, GTK_TYPE_MENU,</span>
00259 <span class="comment">       or GTK_TYPE_OPTION_MENU.</span>
00260 <span class="comment">       Param 2: The path of the menu.</span>
00261 <span class="comment">       Param 3: A pointer to a gtk_accel_group. The item factory sets up</span>
00262 <span class="comment">       the accelerator table while generating menus.</span>
00263 <span class="comment">    */</span>
00264     
00265     item_factory = gtk_item_factory_new(GTK_TYPE_MENU_BAR, <span class="stringliteral">"&lt;main&gt;"</span>, 
00266                                    accel_group);
00267     <span class="comment">/* This function generates the menu items. Pass the item factory,</span>
00268 <span class="comment">       the number of items in the array, the array itself, and any</span>
00269 <span class="comment">       callback data for the menu items. */</span>
00270     gtk_item_factory_create_items(item_factory, nmenu_items, menu_items, NULL);
00271     
00272     <span class="comment">/* Attach the new accelerator group to the window */</span>
00273 <span class="preprocessor">#ifdef USE_GTK2</span>
00274 <span class="preprocessor"></span>    gtk_window_add_accel_group (GTK_WINDOW(window), accel_group);
00275 <span class="preprocessor">#else</span>
00276 <span class="preprocessor"></span>    gtk_accel_group_attach(accel_group, GTK_OBJECT(window));
00277 <span class="preprocessor">#endif</span>
00278 <span class="preprocessor"></span>    
00279     <span class="keywordflow">if</span>(menubar) {
00280        GtkWidget *menuEntry;
00281 
00282        <span class="comment">/* Finally, return the actual menu bar created by the item factory. */</span>
00283        *menubar = gtk_item_factory_get_widget(item_factory, <span class="stringliteral">"&lt;main&gt;"</span>);
00284        <span class="comment">/* Set menu selection to reflect the current active unit */</span>
00285        <span class="keywordflow">if</span> (GERBV_DEFAULT_UNIT == GERBV_MMS) {
00286            menuEntry = gtk_item_factory_get_widget(item_factory, <span class="stringliteral">"/Setup/Units/mm"</span>);
00287            gtk_menu_item_activate(GTK_MENU_ITEM(menuEntry));
00288        }
00289     }
00290 } <span class="comment">/* create_menubar */</span>
00291 
00292 
00293 <span class="comment">/*</span>
00294 <span class="comment"> * By redesigning create_menubar we can probably do without this function</span>
00295 <span class="comment"> */</span>
00296 <span class="keyword">static</span> <span class="keywordtype">void</span>
00297 create_popupmenu(GtkWidget **popupmenu)
00298 {
00299     <span class="keywordtype">int</span> nmenu_items = <span class="keyword">sizeof</span>(popup_menu_items) / <span class="keyword">sizeof</span>(popup_menu_items[0]);
00300     GtkItemFactory *item_factory;
00301 
00302     item_factory = gtk_item_factory_new(GTK_TYPE_MENU, <span class="stringliteral">"&lt;popup&gt;"</span>, NULL);
00303     gtk_item_factory_create_items(item_factory, nmenu_items, popup_menu_items,
00304                               NULL);
00305     
00306     <span class="keywordflow">if</span>(popupmenu)
00307        <span class="comment">/* Finally, return the actual menu bar created by the item factory. */</span>
00308        *popupmenu = gtk_item_factory_get_widget(item_factory, <span class="stringliteral">"&lt;popup&gt;"</span>);
00309 
00310     <span class="keywordflow">return</span>;
00311 } <span class="comment">/* create_popupmenu */</span>
00312 
00313 
00314 <span class="keywordtype">void</span>
00315 set_window_icon (GtkWidget * this_window)
00316 {
00317     GdkPixmap *pixmap;
00318     GdkBitmap *mask;
00319 
00320     pixmap = gdk_pixmap_create_from_xpm_d (this_window-&gt;window, &amp;mask,
00321 &amp;this_window-&gt;style-&gt;bg[GTK_STATE_NORMAL], gerbv_icon_xpm);
00322     gdk_window_set_icon (this_window-&gt;window, NULL, pixmap, mask);
00323 
00324     <span class="keywordflow">return</span>;
00325 } <span class="comment">/* set_window_icon */</span>
00326 
00327 
00328 <span class="keyword">static</span> <span class="keywordtype">void</span>
00329 cb_layer_button(GtkWidget *widget, gpointer data)
00330 {
00331     <span class="keywordtype">long</span> idx = (long)data;
00332 
00333     <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx] == NULL)
00334        <span class="keywordflow">return</span>;
00335 
00336     <a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index = idx;
00337 
00338     <span class="comment">/* Redraw the image(s) */</span>
00339     redraw_pixmap(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area, TRUE);
00340 
00341 } <span class="comment">/* cb_layer_button */</span>
00342 
00343 
00344 <span class="keyword">static</span> gint
00345 layer_button_press_event(GtkWidget *widget, GdkEventButton *event, 
00346                       gpointer button)
00347 {
00348     GdkEventButton *event_button;
00349 
00350     <span class="keywordflow">if</span> (event-&gt;type != GDK_BUTTON_PRESS) {
00351        <span class="keywordflow">return</span> FALSE;
00352     }
00353 
00354     event_button = (GdkEventButton *) event;
00355 
00356     <span class="comment">/*</span>
00357 <span class="comment">     * Only button 3 accepted</span>
00358 <span class="comment">     */</span>
00359     <span class="keywordflow">if</span> (event_button-&gt;button != 3) {
00360        <span class="keywordflow">return</span> FALSE;
00361     }
00362 
00363     gtk_menu_popup(GTK_MENU(<a class="code" href="gerbv_8c.html#a0">screen</a>.popup_menu), NULL, NULL, NULL, NULL, 
00364                  event_button-&gt;button, event_button-&gt;time);
00365     
00366     <a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index = (<span class="keywordtype">long</span> int)button;
00367 
00368     <span class="keywordflow">return</span> TRUE;
00369 } <span class="comment">/*layer_button_press_event */</span>
00370 
00371 
00372 <span class="keyword">static</span> GtkWidget *
00373 create_layer_buttons(<span class="keywordtype">int</span> nuf_buttons)
00374 {
00375     GtkWidget *button = NULL;
00376     GtkWidget *box = NULL;
00377     GdkColor  *color;
00378     GtkStyle  *defstyle, *newstyle;
00379     GtkTooltips *tooltips = gtk_tooltips_new();
00380     <span class="keywordtype">char</span>      info[5];
00381     <span class="keywordtype">long</span> <span class="keywordtype">int</span>  bi;
00382 
00383     box = gtk_vbox_new(TRUE, 0);
00384 
00385     <span class="comment">/* </span>
00386 <span class="comment">     * Create style to be used by "all layer" buttons</span>
00387 <span class="comment">     */</span>
00388     color = alloc_color(0, 0, 0, <span class="stringliteral">"white"</span>);
00389     defstyle = gtk_widget_get_default_style();
00390     newstyle = gtk_style_copy(defstyle);
00391     newstyle-&gt;bg[GTK_STATE_NORMAL] = *color;
00392     newstyle-&gt;bg[GTK_STATE_ACTIVE] = *color;
00393     newstyle-&gt;bg[GTK_STATE_PRELIGHT] = *color;
00394 
00395     <span class="comment">/*</span>
00396 <span class="comment">     * Create On button with callback, color and tooltips</span>
00397 <span class="comment">     */</span>
00398     button = gtk_button_new_with_label(<span class="stringliteral">"On"</span>);
00399     gtk_signal_connect(GTK_OBJECT(button), <span class="stringliteral">"button_press_event"</span>,
00400                      GTK_SIGNAL_FUNC(all_layers_on), 
00401                      (gpointer)NULL);
00402     gtk_box_pack_start(GTK_BOX(box), button, TRUE, TRUE, 0);
00403     gtk_widget_set_style(button, newstyle);
00404     gtk_tooltips_set_tip(tooltips, button, <span class="stringliteral">"Turn On All Layers"</span>, NULL); 
00405 
00406     <span class="comment">/*</span>
00407 <span class="comment">     * Create Off button with callback, color and tooltips</span>
00408 <span class="comment">     */</span>
00409     button = gtk_button_new_with_label(<span class="stringliteral">"Off"</span>);
00410     gtk_signal_connect(GTK_OBJECT(button), <span class="stringliteral">"button_press_event"</span>,
00411                      GTK_SIGNAL_FUNC(all_layers_off), 
00412                      (gpointer)NULL);
00413     gtk_box_pack_start(GTK_BOX(box), button, TRUE, TRUE, 0);
00414     gtk_widget_set_style(button, newstyle);
00415     gtk_tooltips_set_tip(tooltips, button, <span class="stringliteral">"Turn Off All Layers"</span>, NULL); 
00416 
00417     <span class="comment">/*</span>
00418 <span class="comment">     * Create the rest of the buttons</span>
00419 <span class="comment">     */</span>
00420     <span class="keywordflow">for</span> (bi = 0; bi &lt; nuf_buttons; bi++) {
00421        snprintf(info, <span class="keyword">sizeof</span>(info), <span class="stringliteral">"%ld"</span>, bi);
00422        button = gtk_toggle_button_new_with_label(info);
00423 
00424        gtk_signal_connect(GTK_OBJECT(button), <span class="stringliteral">"toggled"</span>, 
00425                         GTK_SIGNAL_FUNC(cb_layer_button),
00426                         (gpointer)bi);
00427        gtk_signal_connect(GTK_OBJECT(button), <span class="stringliteral">"button_press_event"</span>,
00428                         GTK_SIGNAL_FUNC(layer_button_press_event), 
00429                         (gpointer)bi);
00430 
00431        gtk_box_pack_start(GTK_BOX(box), button, TRUE, TRUE, 0);
00432        <a class="code" href="gerbv_8c.html#a0">screen</a>.layer_button[bi] = button;
00433     }
00434 
00435     <span class="keywordflow">return</span> box;
00436 } <span class="comment">/* create_layer_buttons */</span>
00437 
00438 
00439 <span class="keyword">static</span> <span class="keywordtype">void</span>
00440 color_selection_destroy(GtkWidget *widget, gpointer data)
00441 {
00442     <span class="comment">/* Remove modal grab and destroy color selection dialog */</span>
00443     gtk_grab_remove(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.color_selection);
00444     gtk_widget_destroy(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.color_selection);
00445     <a class="code" href="gerbv_8c.html#a0">screen</a>.win.color_selection = NULL;
00446 } <span class="comment">/* color_selection_destroy */</span>
00447 
00448 
00449 <span class="keyword">static</span> <span class="keywordtype">void</span>
00450 color_selection_ok(GtkWidget *widget, gpointer data)
00451 {
00452     <span class="keywordtype">int</span> background = (<span class="keywordtype">long</span> int)data;
00453     GtkColorSelection *colorsel;
00454     gdouble color[4];
00455     GtkStyle *oldstyle, *newstyle;
00456 
00457     <span class="comment">/* Get selected color */</span>
00458     colorsel = GTK_COLOR_SELECTION(GTK_COLOR_SELECTION_DIALOG
00459                                (<a class="code" href="gerbv_8c.html#a0">screen</a>.win.color_selection)-&gt;colorsel);
00460     gtk_color_selection_get_color(colorsel, color);
00461 
00462     <span class="comment">/* Allocate new color  */</span>
00463     <span class="keywordflow">if</span> (background) {
00464        free(<a class="code" href="gerbv_8c.html#a0">screen</a>.background);
00465        <a class="code" href="gerbv_8c.html#a0">screen</a>.background = 
00466            alloc_color((<span class="keywordtype">int</span>)(color[0] * MAX_COLOR_RESOLUTION),
00467                      (<span class="keywordtype">int</span>)(color[1] * MAX_COLOR_RESOLUTION),
00468                      (<span class="keywordtype">int</span>)(color[2] * MAX_COLOR_RESOLUTION),
00469                      NULL);
00470     } <span class="keywordflow">else</span> {
00471        free(<a class="code" href="gerbv_8c.html#a0">screen</a>.file[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index]-&gt;color);
00472        <a class="code" href="gerbv_8c.html#a0">screen</a>.file[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index]-&gt;color = 
00473            alloc_color((<span class="keywordtype">int</span>)(color[0] * MAX_COLOR_RESOLUTION), 
00474                      (<span class="keywordtype">int</span>)(color[1] * MAX_COLOR_RESOLUTION), 
00475                      (<span class="keywordtype">int</span>)(color[2] * MAX_COLOR_RESOLUTION), 
00476                      NULL);
00477     }
00478 
00479     <span class="comment">/* Redraw image on screen */</span>
00480     redraw_pixmap(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area, TRUE);
00481 
00482     <span class="comment">/* Change color on button too */</span>
00483     <span class="keywordflow">if</span> (!background) {
00484        oldstyle = gtk_widget_get_style(<a class="code" href="gerbv_8c.html#a0">screen</a>.layer_button[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index]);
00485        newstyle = gtk_style_copy(oldstyle);
00486        newstyle-&gt;bg[GTK_STATE_NORMAL] = *(<a class="code" href="gerbv_8c.html#a0">screen</a>.file[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index]-&gt;color);
00487        newstyle-&gt;bg[GTK_STATE_ACTIVE] = *(<a class="code" href="gerbv_8c.html#a0">screen</a>.file[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index]-&gt;color);
00488        newstyle-&gt;bg[GTK_STATE_PRELIGHT] = *(<a class="code" href="gerbv_8c.html#a0">screen</a>.file[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index]-&gt;color);
00489        gtk_widget_set_style(<a class="code" href="gerbv_8c.html#a0">screen</a>.layer_button[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index], newstyle);
00490     }
00491 
00492     <span class="comment">/* Remove modal grab and destroy color selection dialog */</span>
00493     gtk_grab_remove(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.color_selection);
00494     gtk_widget_destroy(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.color_selection);
00495     <a class="code" href="gerbv_8c.html#a0">screen</a>.win.color_selection = NULL;
00496 
00497     <span class="keywordflow">return</span>;
00498 } <span class="comment">/* cb_ok_color_selection */</span>
00499 
00500 
00501 <span class="keyword">static</span> <span class="keywordtype">void</span> 
00502 swap_layers(GtkWidget *widget, gpointer data)
00503 {
00504     gerbv_fileinfo_t *temp_file;
00505     GtkStyle *s1, *s2;
00506     GtkTooltipsData *td1, *td2;
00507     <span class="keywordtype">int</span> idx;
00508 
00509     <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.file[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index] == NULL) <span class="keywordflow">return</span>;
00510 
00511     <span class="keywordflow">if</span> (data == 0) {
00512        <span class="comment">/* Moving Up */</span>
00513        <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index == 0) <span class="keywordflow">return</span>;
00514        <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.file[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index - 1] == NULL) <span class="keywordflow">return</span>;
00515        idx = -1;
00516     } <span class="keywordflow">else</span> { 
00517        <span class="comment">/* Moving Down */</span>
00518        <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index == MAX_FILES - 1) <span class="keywordflow">return</span>;
00519        <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.file[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index + 1] == NULL) <span class="keywordflow">return</span>;
00520        idx = 1;
00521     }
00522 
00523     <span class="comment">/* Swap file */</span>
00524     temp_file = <a class="code" href="gerbv_8c.html#a0">screen</a>.file[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index];
00525     <a class="code" href="gerbv_8c.html#a0">screen</a>.file[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index] = <a class="code" href="gerbv_8c.html#a0">screen</a>.file[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index + idx];
00526     <a class="code" href="gerbv_8c.html#a0">screen</a>.file[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index + idx] = temp_file;
00527 
00528     <span class="comment">/* Swap color on button */</span>
00529     s1 = gtk_widget_get_style(<a class="code" href="gerbv_8c.html#a0">screen</a>.layer_button[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index]);
00530     s2 = gtk_widget_get_style(<a class="code" href="gerbv_8c.html#a0">screen</a>.layer_button[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index + idx]);
00531     gtk_widget_set_style(<a class="code" href="gerbv_8c.html#a0">screen</a>.layer_button[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index + idx], s1);
00532     gtk_widget_set_style(<a class="code" href="gerbv_8c.html#a0">screen</a>.layer_button[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index], s2);
00533 
00534     <span class="comment">/* Swap tooltips on button */</span>
00535     td1 = gtk_tooltips_data_get(<a class="code" href="gerbv_8c.html#a0">screen</a>.layer_button[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index]);
00536     td2 = gtk_tooltips_data_get(<a class="code" href="gerbv_8c.html#a0">screen</a>.layer_button[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index + idx]);
00537     gtk_tooltips_set_tip(td1-&gt;tooltips, td1-&gt;widget,
00538                       <a class="code" href="gerbv_8c.html#a0">screen</a>.file[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index]-&gt;name, NULL);
00539     gtk_tooltips_set_tip(td2-&gt;tooltips, td2-&gt;widget,
00540                       <a class="code" href="gerbv_8c.html#a0">screen</a>.file[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index + idx]-&gt;name, NULL);
00541 
00542 
00543     redraw_pixmap(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area, TRUE);
00544     
00545 } <span class="comment">/* swap_layers */</span>
00546 
00547 
00548 <span class="keyword">static</span> <span class="keywordtype">void</span>
00549 color_selection_popup(GtkWidget *widget, gpointer data)
00550 {
00551     gdouble curr_color[4];
00552     <span class="keywordtype">int</span> background = (<span class="keywordtype">long</span> int)data;
00553 
00554     <span class="keywordflow">if</span> (!background &amp;&amp; (<a class="code" href="gerbv_8c.html#a0">screen</a>.file[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index] == NULL))
00555        <span class="keywordflow">return</span>;
00556 
00557     <a class="code" href="gerbv_8c.html#a0">screen</a>.win.color_selection = gtk_color_selection_dialog_new(<span class="stringliteral">"Color Selection"</span>);
00558 
00559     gtk_color_selection_set_update_policy
00560        (GTK_COLOR_SELECTION
00561         (GTK_COLOR_SELECTION_DIALOG(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.color_selection)-&gt;colorsel),
00562         GTK_UPDATE_CONTINUOUS);
00563 
00564     gtk_signal_connect
00565        (GTK_OBJECT
00566         (GTK_COLOR_SELECTION_DIALOG(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.color_selection)-&gt;cancel_button),
00567         <span class="stringliteral">"clicked"</span>, GTK_SIGNAL_FUNC(color_selection_destroy), NULL);
00568 
00569     gtk_signal_connect
00570        (GTK_OBJECT
00571         (GTK_COLOR_SELECTION_DIALOG(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.color_selection)-&gt;ok_button),
00572         <span class="stringliteral">"clicked"</span>, GTK_SIGNAL_FUNC(color_selection_ok), data);
00573 
00574     gtk_signal_connect(GTK_OBJECT(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.color_selection), <span class="stringliteral">"destroy"</span>,
00575                      GTK_SIGNAL_FUNC(color_selection_destroy),
00576                      NULL);
00577 
00578     <span class="comment">/* Get current color and use it as a start in color selection dialog */</span>
00579     <span class="keywordflow">if</span> (background) {
00580        curr_color[0] = (gdouble)<a class="code" href="gerbv_8c.html#a0">screen</a>.background-&gt;red / 
00581            (gdouble)MAX_COLOR_RESOLUTION;
00582        curr_color[1] = (gdouble)<a class="code" href="gerbv_8c.html#a0">screen</a>.background-&gt;green / 
00583            (gdouble)MAX_COLOR_RESOLUTION;
00584        curr_color[2] = (gdouble)<a class="code" href="gerbv_8c.html#a0">screen</a>.background-&gt;blue / 
00585            (gdouble)MAX_COLOR_RESOLUTION;
00586        curr_color[3] = 0.0; <span class="comment">/* Actually don't know how to get this value */</span>
00587     }<span class="keywordflow">else</span> {
00588        curr_color[0] = (gdouble)<a class="code" href="gerbv_8c.html#a0">screen</a>.file[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index]-&gt;color-&gt;red / 
00589            (gdouble)MAX_COLOR_RESOLUTION;
00590        curr_color[1] = (gdouble)<a class="code" href="gerbv_8c.html#a0">screen</a>.file[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index]-&gt;color-&gt;green /
00591            (gdouble)MAX_COLOR_RESOLUTION;
00592        curr_color[2] = (gdouble)<a class="code" href="gerbv_8c.html#a0">screen</a>.file[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index]-&gt;color-&gt;blue / 
00593            (gdouble)MAX_COLOR_RESOLUTION;
00594        curr_color[3] = 0.0; <span class="comment">/* Actually don't know how to get this value */</span>
00595     }
00596 
00597     <span class="comment">/* Now set this color in color selection dialog */</span>
00598     gtk_color_selection_set_color
00599        (GTK_COLOR_SELECTION(GTK_COLOR_SELECTION_DIALOG
00600                           (<a class="code" href="gerbv_8c.html#a0">screen</a>.win.color_selection)-&gt;colorsel),
00601         curr_color);
00602 
00603     <span class="comment">/* Display widget */</span>
00604     gtk_widget_show(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.color_selection);
00605 
00606     <span class="comment">/* Make widget modal */</span>
00607     gtk_grab_add(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.color_selection);
00608 
00609     <span class="keywordflow">return</span>;
00610 } <span class="comment">/* color_selection_popup */</span>
00611 
00612 
00613 <span class="keyword">static</span> <span class="keywordtype">void</span> 
00614 invert_color(GtkWidget *widget, gpointer data)
00615 {
00616     <span class="keywordflow">if</span> (!<a class="code" href="gerbv_8c.html#a0">screen</a>.file[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index])
00617        <span class="keywordflow">return</span>;
00618 
00619     <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.file[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index]-&gt;inverted)
00620        <a class="code" href="gerbv_8c.html#a0">screen</a>.file[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index]-&gt;inverted = 0;
00621     <span class="keywordflow">else</span>
00622        <a class="code" href="gerbv_8c.html#a0">screen</a>.file[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index]-&gt;inverted = 1;
00623 
00624     redraw_pixmap(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area, TRUE);
00625        
00626     <span class="keywordflow">return</span>;
00627 } <span class="comment">/* invert_color */</span>
00628 
00629 
00630 <span class="keyword">static</span> <span class="keywordtype">void</span>
00631 cb_ok_load_file(GtkWidget *widget, GtkFileSelection *fs)
00632 {
00633     <span class="keywordtype">char</span> *filename;
00634 
00635     filename = (<span class="keywordtype">char</span> *)gtk_file_selection_get_filename(GTK_FILE_SELECTION(fs));
00636     <span class="keywordflow">if</span> (open_image(filename, <a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index, FALSE) != -1) {
00637 
00638        gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON
00639                                  (<a class="code" href="gerbv_8c.html#a0">screen</a>.layer_button[<a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index]),
00640                                  TRUE);
00641 
00642 <span class="preprocessor">#ifdef HAVE_LIBGEN_H    </span>
00643 <span class="preprocessor"></span>
00644        <span class="comment">/*</span>
00645 <span class="comment">        * Remember where we loaded file from last time</span>
00646 <span class="comment">        */</span>
00647        filename = dirname(filename);
00648 <span class="preprocessor">#endif        </span>
00649 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.path)
00650            free(<a class="code" href="gerbv_8c.html#a0">screen</a>.path);
00651        <a class="code" href="gerbv_8c.html#a0">screen</a>.path = (<span class="keywordtype">char</span> *)malloc(strlen(filename) + 1);
00652        strcpy(<a class="code" href="gerbv_8c.html#a0">screen</a>.path, filename);
00653        <a class="code" href="gerbv_8c.html#a0">screen</a>.path = strncat(<a class="code" href="gerbv_8c.html#a0">screen</a>.path, <span class="stringliteral">"/"</span>, 1);
00654        
00655        <span class="comment">/* Make loaded image appear on screen */</span>
00656        redraw_pixmap(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area, TRUE);
00657     }
00658 
00659     gtk_grab_remove(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.load_file);
00660     gtk_widget_destroy(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.load_file);
00661     <a class="code" href="gerbv_8c.html#a0">screen</a>.win.load_file = NULL;
00662 
00663     <span class="keywordflow">return</span>;
00664 } <span class="comment">/* cb_ok_load_file */</span>
00665 
00666 
00667 <span class="keyword">static</span> <span class="keywordtype">void</span>
00668 cb_cancel_load_file(GtkWidget *widget, gpointer data)
00669 {
00670     gtk_grab_remove(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.load_file);
00671     gtk_widget_destroy(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.load_file);
00672     <a class="code" href="gerbv_8c.html#a0">screen</a>.win.load_file = NULL;
00673 
00674     <span class="keywordflow">return</span>;
00675 } <span class="comment">/* cb_cancel_load_file */</span>
00676 
00677 
00678 <span class="keyword">static</span> <span class="keywordtype">void</span>
00679 load_file_popup(GtkWidget *widget, gpointer data)
00680 {
00681     <a class="code" href="gerbv_8c.html#a0">screen</a>.win.load_file = gtk_file_selection_new(<span class="stringliteral">"Select File To View"</span>);
00682 
00683     <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.path)
00684        gtk_file_selection_set_filename
00685            (GTK_FILE_SELECTION(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.load_file), <a class="code" href="gerbv_8c.html#a0">screen</a>.path);
00686 
00687     gtk_signal_connect(GTK_OBJECT(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.load_file), <span class="stringliteral">"destroy"</span>,
00688                      GTK_SIGNAL_FUNC(cb_cancel_load_file),
00689                      NULL);
00690     gtk_signal_connect
00691        (GTK_OBJECT(GTK_FILE_SELECTION(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.load_file)-&gt;ok_button),
00692         <span class="stringliteral">"clicked"</span>, GTK_SIGNAL_FUNC(cb_ok_load_file), 
00693         (gpointer)<a class="code" href="gerbv_8c.html#a0">screen</a>.win.load_file);
00694     gtk_signal_connect
00695        (GTK_OBJECT(GTK_FILE_SELECTION(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.load_file)-&gt;cancel_button),
00696         <span class="stringliteral">"clicked"</span>, GTK_SIGNAL_FUNC(cb_cancel_load_file), 
00697         (gpointer)<a class="code" href="gerbv_8c.html#a0">screen</a>.win.load_file);
00698     
00699     gtk_widget_show(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.load_file);
00700 
00701     gtk_grab_add(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.load_file);
00702     
00703     <span class="keywordflow">return</span>;
00704 } <span class="comment">/* load_file_popup */</span>
00705 
00706 
00707 <span class="preprocessor">#ifdef EXPORT_PNG</span>
00708 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span>
00709 cb_ok_export_png(GtkWidget *widget, GtkFileSelection *fs)
00710 {
00711     <span class="keywordtype">char</span> *filename;
00712     gboolean result;
00713     GdkWindow *window;
00714 
00715     filename = (<span class="keywordtype">char</span> *)gtk_file_selection_get_filename(GTK_FILE_SELECTION(fs));
00716 
00717     <span class="comment">/* This might be lengthy, show that we're busy by changing the pointer */</span>
00718     window = gtk_widget_get_parent_window(widget);
00719     <span class="keywordflow">if</span> (window) {
00720        GdkCursor *cursor;
00721 
00722        cursor = gdk_cursor_new(GDK_WATCH);
00723        gdk_window_set_cursor(window, cursor);
00724        gdk_cursor_destroy(cursor);
00725     }
00726 
00727     <span class="comment">/* Export PNG */</span>
00728 <span class="preprocessor">#ifdef EXPORT_DISPLAYED_IMAGE</span>
00729 <span class="preprocessor"></span>    result = png_export(<a class="code" href="gerbv_8c.html#a0">screen</a>.pixmap, filename);
00730 <span class="preprocessor">#else</span>
00731 <span class="preprocessor"></span>    result = png_export(NULL, filename);
00732 <span class="preprocessor">#endif </span><span class="comment">/* EXPORT_DISPLAYED_IMAGE */</span>
00733     <span class="keywordflow">if</span> (!result) {
00734        GERB_MESSAGE(<span class="stringliteral">"Failed to save PNG at %s\n"</span>, filename);
00735     }
00736 
00737     <span class="comment">/* Return default pointer shape */</span>
00738     <span class="keywordflow">if</span> (window) {
00739        gdk_window_set_cursor(window, GERBV_DEF_CURSOR);
00740     }
00741 
00742     <span class="comment">/*</span>
00743 <span class="comment">     * Remember where we loaded file from last time</span>
00744 <span class="comment">     */</span>
00745 <span class="preprocessor">#ifdef HAVE_LIBGEN_H     </span>
00746 <span class="preprocessor"></span>    filename = dirname(filename);
00747 <span class="preprocessor">#endif    </span>
00748 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.path)
00749        free(<a class="code" href="gerbv_8c.html#a0">screen</a>.path);
00750     <a class="code" href="gerbv_8c.html#a0">screen</a>.path = (<span class="keywordtype">char</span> *)malloc(strlen(filename) + 1);
00751     strcpy(<a class="code" href="gerbv_8c.html#a0">screen</a>.path, filename);
00752     <a class="code" href="gerbv_8c.html#a0">screen</a>.path = strncat(<a class="code" href="gerbv_8c.html#a0">screen</a>.path, <span class="stringliteral">"/"</span>, 1);
00753    
00754     gtk_grab_remove(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.export_png);
00755     
00756     <a class="code" href="gerbv_8c.html#a0">screen</a>.win.export_png = NULL;
00757 
00758     <span class="keywordflow">return</span>;
00759 } <span class="comment">/* cb_ok_export_png */</span>
00760 
00761 
00762 <span class="keyword">static</span> <span class="keywordtype">void</span>
00763 export_png_popup(GtkWidget *widget, gpointer data)
00764 {
00765     <a class="code" href="gerbv_8c.html#a0">screen</a>.win.export_png = gtk_file_selection_new(<span class="stringliteral">"Save PNG filename"</span>);
00766 
00767     <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.path)
00768        gtk_file_selection_set_filename
00769            (GTK_FILE_SELECTION(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.export_png), <a class="code" href="gerbv_8c.html#a0">screen</a>.path);
00770 
00771     gtk_signal_connect
00772        (GTK_OBJECT(GTK_FILE_SELECTION(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.export_png)-&gt;ok_button),
00773         <span class="stringliteral">"clicked"</span>, GTK_SIGNAL_FUNC(cb_ok_export_png), 
00774         (gpointer)<a class="code" href="gerbv_8c.html#a0">screen</a>.win.export_png);
00775     gtk_signal_connect_object
00776        (GTK_OBJECT(GTK_FILE_SELECTION(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.export_png)-&gt;ok_button),
00777         <span class="stringliteral">"clicked"</span>, GTK_SIGNAL_FUNC(gtk_widget_destroy), 
00778         (gpointer)<a class="code" href="gerbv_8c.html#a0">screen</a>.win.export_png);
00779     gtk_signal_connect_object
00780        (GTK_OBJECT(GTK_FILE_SELECTION(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.export_png)-&gt;cancel_button),
00781         <span class="stringliteral">"clicked"</span>, GTK_SIGNAL_FUNC(gtk_widget_destroy), 
00782         (gpointer)<a class="code" href="gerbv_8c.html#a0">screen</a>.win.export_png);
00783     
00784     gtk_widget_show(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.export_png);
00785 
00786     gtk_grab_add(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.export_png);
00787     
00788     <span class="keywordflow">return</span>;
00789 } <span class="comment">/* export_png_popup */</span>
00790 
00791 <span class="preprocessor">#endif </span><span class="comment">/* EXPORT_PNG */</span>
00792 
00793 
00794 <span class="keyword">static</span> <span class="keywordtype">void</span>
00795 cb_ok_project(GtkWidget *widget, gpointer data)
00796 {
00797     <span class="keywordtype">char</span> *filename = NULL;
00798     <a class="code" href="structproject__list__t.html">project_list_t</a> *project_list = NULL, *tmp;
00799     <span class="keywordtype">int</span> idx, pnp_file_in_project_list;
00800     
00801     <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.win.project) {
00802        filename = (<span class="keywordtype">char</span> *)gtk_file_selection_get_filename(GTK_FILE_SELECTION(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.project));
00803 
00804        <span class="comment">/*</span>
00805 <span class="comment">        * Remember where we loaded file from last time</span>
00806 <span class="comment">        */</span>
00807        <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.path)
00808            free(<a class="code" href="gerbv_8c.html#a0">screen</a>.path);
00809        <a class="code" href="gerbv_8c.html#a0">screen</a>.path = (<span class="keywordtype">char</span> *)malloc(strlen(filename) + 1);
00810        strcpy(<a class="code" href="gerbv_8c.html#a0">screen</a>.path, filename);
00811 <span class="preprocessor">#ifdef HAVE_LIBGEN_H        </span>
00812 <span class="preprocessor"></span>       dirname(<a class="code" href="gerbv_8c.html#a0">screen</a>.path);
00813 <span class="preprocessor">#endif        </span>
00814 <span class="preprocessor"></span>       <a class="code" href="gerbv_8c.html#a0">screen</a>.path = strncat(<a class="code" href="gerbv_8c.html#a0">screen</a>.path, <span class="stringliteral">"/"</span>, 1);
00815     }
00816 
00817     <span class="keywordflow">switch</span> ((long)data) {
00818     <span class="keywordflow">case</span> OPEN_PROJECT:
00819        
00820        project_list = <a class="code" href="project_8h.html#a3">read_project_file</a>(filename);
00821 
00822        <span class="keywordflow">if</span> (project_list) {
00823            load_project(project_list);
00824            <span class="comment">/*</span>
00825 <span class="comment">            * Save project filename for later use</span>
00826 <span class="comment">            */</span>
00827            <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.project) {
00828               free(<a class="code" href="gerbv_8c.html#a0">screen</a>.project);
00829               <a class="code" href="gerbv_8c.html#a0">screen</a>.project = NULL;
00830            }
00831            <a class="code" href="gerbv_8c.html#a0">screen</a>.project = (<span class="keywordtype">char</span> *)malloc(strlen(filename) + 1);
00832            memset((<span class="keywordtype">void</span> *)<a class="code" href="gerbv_8c.html#a0">screen</a>.project, 0, strlen(filename) + 1);
00833            strncpy(<a class="code" href="gerbv_8c.html#a0">screen</a>.project, filename, strlen(filename));
00834             rename_main_window(filename, NULL);
00835            redraw_pixmap(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area, TRUE);
00836        } <span class="keywordflow">else</span> {
00837            GERB_MESSAGE(<span class="stringliteral">"Failed to load project\n"</span>);
00838            <span class="keywordflow">goto</span> cb_ok_project_end;
00839        }
00840        all_layers_on(NULL, NULL);
00841        <span class="keywordflow">break</span>;
00842     <span class="keywordflow">case</span> SAVE_AS_PROJECT:
00843        <span class="comment">/*</span>
00844 <span class="comment">        * Save project filename for later use</span>
00845 <span class="comment">        */</span>
00846        <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.project) {
00847            free(<a class="code" href="gerbv_8c.html#a0">screen</a>.project);
00848            <a class="code" href="gerbv_8c.html#a0">screen</a>.project = NULL;
00849        }
00850        <a class="code" href="gerbv_8c.html#a0">screen</a>.project = (<span class="keywordtype">char</span> *)malloc(strlen(filename) + 1);
00851        memset((<span class="keywordtype">void</span> *)<a class="code" href="gerbv_8c.html#a0">screen</a>.project, 0, strlen(filename) + 1);
00852        strncpy(<a class="code" href="gerbv_8c.html#a0">screen</a>.project, filename, strlen(filename));
00853        rename_main_window(filename, NULL);
00854        
00855     <span class="keywordflow">case</span> SAVE_PROJECT:
00856        <span class="keywordflow">if</span> (!<a class="code" href="gerbv_8c.html#a0">screen</a>.project) {
00857            GERB_MESSAGE(<span class="stringliteral">"Missing project filename\n"</span>);
00858            <span class="keywordflow">goto</span> cb_ok_project_end;
00859        }
00860        
00861        <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.path) {
00862            project_list = (<a class="code" href="structproject__list__t.html">project_list_t</a> *)malloc(<span class="keyword">sizeof</span>(<a class="code" href="structproject__list__t.html">project_list_t</a>));
00863            memset(project_list, 0, <span class="keyword">sizeof</span>(<a class="code" href="structproject__list__t.html">project_list_t</a>));
00864            project_list-&gt;<a class="code" href="structproject__list__t.html#o5">next</a> = project_list;
00865            project_list-&gt;<a class="code" href="structproject__list__t.html#o0">layerno</a> = -1;
00866            project_list-&gt;<a class="code" href="structproject__list__t.html#o1">filename</a> = <a class="code" href="gerbv_8c.html#a0">screen</a>.path;
00867            project_list-&gt;<a class="code" href="structproject__list__t.html#o2">rgb</a>[0] = <a class="code" href="gerbv_8c.html#a0">screen</a>.background-&gt;red;
00868            project_list-&gt;<a class="code" href="structproject__list__t.html#o2">rgb</a>[1] = <a class="code" href="gerbv_8c.html#a0">screen</a>.background-&gt;green;
00869            project_list-&gt;<a class="code" href="structproject__list__t.html#o2">rgb</a>[2] = <a class="code" href="gerbv_8c.html#a0">screen</a>.background-&gt;blue;
00870            project_list-&gt;<a class="code" href="structproject__list__t.html#o5">next</a> = NULL;
00871        }
00872        pnp_file_in_project_list = 0;
00873        <span class="keywordflow">for</span> (idx = 0; idx &lt; MAX_FILES; idx++) {
00874         <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx] &amp;&amp;  <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;color) {
00875                   tmp = (<a class="code" href="structproject__list__t.html">project_list_t</a> *)malloc(<span class="keyword">sizeof</span>(<a class="code" href="structproject__list__t.html">project_list_t</a>));
00876                   memset(tmp, 0, <span class="keyword">sizeof</span>(<a class="code" href="structproject__list__t.html">project_list_t</a>));
00877                   tmp-&gt;<a class="code" href="structproject__list__t.html#o5">next</a> = project_list;
00878                   tmp-&gt;<a class="code" href="structproject__list__t.html#o0">layerno</a> = idx;
00879 <span class="preprocessor">#ifdef USE_GTK2            </span>
00880 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ((<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;name == NULL) &amp;&amp; (pnp_file_in_project_list == 0) &amp;&amp; (interface.<a class="code" href="struct__InterfaceStruct.html#o21">pnp_filename</a> != NULL)) {
00881                 tmp-&gt;<a class="code" href="structproject__list__t.html#o1">filename</a> = interface.<a class="code" href="struct__InterfaceStruct.html#o21">pnp_filename</a>;
00882                 pnp_file_in_project_list = 1;
00883             } <span class="keywordflow">else</span>
00884 <span class="preprocessor">#endif            </span>
00885 <span class="preprocessor"></span>                  tmp-&gt;filename = <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;name;
00886                   tmp-&gt;rgb[0] = <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;color-&gt;red;
00887                   tmp-&gt;rgb[1] = <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;color-&gt;green;
00888                   tmp-&gt;rgb[2] = <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;color-&gt;blue;
00889                   tmp-&gt;inverted = <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;inverted;
00890            project_list = tmp;
00891            }
00892        }
00893            
00894        <span class="keywordflow">if</span> (write_project_file(<a class="code" href="gerbv_8c.html#a0">screen</a>.project, project_list)) {
00895            GERB_MESSAGE(<span class="stringliteral">"Failed to write project\n"</span>);
00896            <span class="keywordflow">goto</span> cb_ok_project_end;
00897        }
00898        <span class="keywordflow">break</span>;
00899     <span class="keywordflow">default</span>:
00900        GERB_FATAL_ERROR(<span class="stringliteral">"Unknown operation in cb_ok_project\n"</span>);
00901     }
00902 <span class="preprocessor">#ifdef HAVE_LIBGEN_H</span>
00903 <span class="preprocessor"></span>    <span class="comment">/*</span>
00904 <span class="comment">     * Remember where we loaded file from last time</span>
00905 <span class="comment">     */</span>
00906     filename = dirname(filename);
00907 <span class="preprocessor">#endif </span>
00908 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.path)
00909            free(<a class="code" href="gerbv_8c.html#a0">screen</a>.path);
00910     <a class="code" href="gerbv_8c.html#a0">screen</a>.path = (<span class="keywordtype">char</span> *)malloc(strlen(filename) + 1);
00911     strcpy(<a class="code" href="gerbv_8c.html#a0">screen</a>.path, filename);
00912     <a class="code" href="gerbv_8c.html#a0">screen</a>.path = strncat(<a class="code" href="gerbv_8c.html#a0">screen</a>.path, <span class="stringliteral">"/"</span>, 1);
00913 
00914  cb_ok_project_end:
00915     <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.win.project) {
00916        gtk_grab_remove(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.project);
00917        <a class="code" href="gerbv_8c.html#a0">screen</a>.win.project = NULL;
00918     }
00919 
00920     <span class="keywordflow">return</span>;
00921 } <span class="comment">/* cb_ok_project */</span>
00922 
00923 
00924 <span class="keyword">static</span> <span class="keywordtype">void</span> 
00925 project_popup(GtkWidget *widget, gpointer data)
00926 {
00927 
00928     <span class="keywordflow">switch</span> ((long)data) {
00929     <span class="keywordflow">case</span> SAVE_AS_PROJECT:
00930     <span class="keywordflow">case</span> SAVE_PROJECT:
00931        <a class="code" href="gerbv_8c.html#a0">screen</a>.win.project = gtk_file_selection_new(<span class="stringliteral">"Save project filename"</span>);
00932        <span class="keywordflow">break</span>;
00933     <span class="keywordflow">case</span> OPEN_PROJECT:
00934        <a class="code" href="gerbv_8c.html#a0">screen</a>.win.project = gtk_file_selection_new(<span class="stringliteral">"Open project filename"</span>);
00935        <span class="keywordflow">break</span>;
00936     <span class="keywordflow">default</span>:
00937        GERB_FATAL_ERROR(<span class="stringliteral">"Unknown operation in project_popup\n"</span>);
00938     }
00939 
00940     <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.project)
00941        gtk_file_selection_set_filename
00942            (GTK_FILE_SELECTION(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.project), <a class="code" href="gerbv_8c.html#a0">screen</a>.project);
00943     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.path)
00944        gtk_file_selection_set_filename
00945            (GTK_FILE_SELECTION(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.project), <a class="code" href="gerbv_8c.html#a0">screen</a>.path);
00946     
00947     gtk_signal_connect
00948        (GTK_OBJECT(GTK_FILE_SELECTION(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.project)-&gt;ok_button),
00949         <span class="stringliteral">"clicked"</span>, GTK_SIGNAL_FUNC(cb_ok_project), data);
00950     gtk_signal_connect_object
00951        (GTK_OBJECT(GTK_FILE_SELECTION(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.project)-&gt;ok_button),
00952         <span class="stringliteral">"clicked"</span>, GTK_SIGNAL_FUNC(gtk_widget_destroy), 
00953         (gpointer)<a class="code" href="gerbv_8c.html#a0">screen</a>.win.project);
00954     gtk_signal_connect_object
00955        (GTK_OBJECT(GTK_FILE_SELECTION(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.project)-&gt;cancel_button),
00956         <span class="stringliteral">"clicked"</span>, GTK_SIGNAL_FUNC(gtk_widget_destroy), 
00957         (gpointer)<a class="code" href="gerbv_8c.html#a0">screen</a>.win.project);
00958     
00959 
00960     gtk_widget_show(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.project);
00961 
00962     gtk_grab_add(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.project);
00963     
00964     <span class="keywordflow">return</span>;
00965 } <span class="comment">/* project_popup */</span>
00966 
00967 <span class="keyword">static</span> <span class="keywordtype">void</span>
00968 project_save_cb(GtkWidget *widget, gpointer data)
00969 {
00970 
00971     <span class="keywordflow">if</span> (!<a class="code" href="gerbv_8c.html#a0">screen</a>.project) 
00972         project_popup(widget, (gpointer) SAVE_AS_PROJECT);
00973     <span class="keywordflow">else</span> 
00974         cb_ok_project(widget, (gpointer) SAVE_PROJECT);
00975 
00976 }
00977 
00978 <span class="keyword">static</span> <span class="keywordtype">void</span>
00979 all_layers_on(GtkWidget *widget, gpointer data)
00980 {
00981     <span class="keywordtype">int</span> idx;
00982     <span class="keywordflow">for</span> (idx = 0; idx &lt; MAX_FILES; idx++) {
00983        <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]) {
00984            gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON
00985                                     (<a class="code" href="gerbv_8c.html#a0">screen</a>.layer_button[idx]),TRUE);
00986        }
00987     }
00988 } <span class="comment">/* all_layers_on */</span>
00989 
00990 
00991 <span class="keyword">static</span> <span class="keywordtype">void</span>
00992 all_layers_off(GtkWidget *widget, gpointer data)
00993 {
00994     <span class="keywordtype">int</span> idx;
00995     <span class="keywordflow">for</span> (idx = 0; idx &lt; MAX_FILES; idx++) {
00996        <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]) {
00997            gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON
00998                                     (<a class="code" href="gerbv_8c.html#a0">screen</a>.layer_button[idx]),FALSE);
00999        }
01000     }
01001 } <span class="comment">/* all_layers_off */</span>
01002 
01003 
01004 <span class="keyword">static</span> <span class="keywordtype">void</span>
01005 unload_file(GtkWidget *widget, gpointer data)
01006 {
01007     <span class="keywordtype">int</span>         idx = <a class="code" href="gerbv_8c.html#a0">screen</a>.curr_index;
01008     GtkStyle   *defstyle;
01009 <span class="preprocessor">#ifdef USE_GTK2       </span>
01010 <span class="preprocessor"></span><span class="comment">//    int         idx0;</span>
01011     GtkTreeIter iter;
01012 <span class="preprocessor">#endif    </span>
01013 <span class="preprocessor"></span>
01014     
01015     <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx] == NULL)
01016        <span class="keywordflow">return</span>;
01017 
01018     <span class="comment">/*</span>
01019 <span class="comment">     * Deselect the layer we're unloading so it's not left in the pixmap</span>
01020 <span class="comment">     */</span>
01021     gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(<a class="code" href="gerbv_8c.html#a0">screen</a>.layer_button[idx]),
01022                              FALSE);
01023 
01024     <span class="comment">/* </span>
01025 <span class="comment">     * Remove color on layer button (set default style) </span>
01026 <span class="comment">     */</span>
01027     defstyle = gtk_widget_get_default_style();
01028     gtk_widget_set_style(<a class="code" href="gerbv_8c.html#a0">screen</a>.layer_button[idx], defstyle);
01029 
01030     <span class="comment">/* </span>
01031 <span class="comment">     * Remove tool tips </span>
01032 <span class="comment">     */</span>
01033     gtk_tooltips_set_tip(<a class="code" href="gerbv_8c.html#a0">screen</a>.tooltips, <a class="code" href="gerbv_8c.html#a0">screen</a>.layer_button[idx], 
01034                       NULL, NULL); 
01035 
01036     <span class="comment">/* </span>
01037 <span class="comment">     * Remove data struct </span>
01038 <span class="comment">     */</span>
01039     free_gerb_image(<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;image);  <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;image = NULL;
01040     free(<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;color);  <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;color = NULL;
01041     free(<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;name);  <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;name = NULL;
01042     free(<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]);  <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx] = NULL;
01043 <span class="preprocessor">#ifdef USE_GTK2</span>
01044 <span class="preprocessor"></span><span class="comment">//#if 0    </span>
01045     <span class="keywordflow">if</span> (interface.<a class="code" href="struct__InterfaceStruct.html#o2">main_window</a> &amp;&amp; gtk_tree_model_get_iter_first(GTK_TREE_MODEL(combo_box_model), &amp;iter)) {
01046             <a class="code" href="search__gui_8c.html#a9">update_combo_box_model</a>();
01047             
01048     }
01049 <span class="preprocessor">#endif        </span>
01050 <span class="preprocessor"></span>    <span class="keywordflow">return</span>;
01051 } <span class="comment">/* unload_file */</span>
01052 
01053 
01054 <span class="keyword">static</span> <span class="keywordtype">void</span>
01055 reload_files(GtkWidget *widget, gpointer data)
01056 {
01057     <span class="keywordtype">int</span> idx;
01058 
01059     <span class="keywordflow">for</span> (idx = 0; idx &lt; MAX_FILES; idx++) {
01060            <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx] &amp;&amp; <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;name) {
01061                <span class="keywordflow">if</span> (open_image(<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;name, idx, TRUE) == -1)
01062                   <span class="keywordflow">return</span>;
01063            }
01064     }
01065     
01066     redraw_pixmap(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area, TRUE);
01067 
01068     <span class="keywordflow">return</span>;
01069 } <span class="comment">/* reload_files */</span>
01070 
01071 
01072 <span class="keyword">static</span> <span class="keywordtype">void</span>
01073 load_project(<a class="code" href="structproject__list__t.html">project_list_t</a> *project_list)
01074 {
01075     <a class="code" href="structproject__list__t.html">project_list_t</a> *pl_tmp;
01076     GtkStyle       *defstyle, *newstyle;
01077 <span class="preprocessor">#ifdef USE_GTK2    </span>
01078 <span class="preprocessor"></span>    GtkTreeIter     iter;
01079 <span class="preprocessor">#endif</span>
01080 <span class="preprocessor"></span>     
01081     <span class="keywordflow">while</span> (project_list) {
01082        <span class="keywordflow">if</span> (project_list-&gt;<a class="code" href="structproject__list__t.html#o0">layerno</a> == -1) {
01083            <a class="code" href="gerbv_8c.html#a0">screen</a>.background = alloc_color(project_list-&gt;<a class="code" href="structproject__list__t.html#o2">rgb</a>[0], 
01084                                        project_list-&gt;<a class="code" href="structproject__list__t.html#o2">rgb</a>[1],
01085                                        project_list-&gt;<a class="code" href="structproject__list__t.html#o2">rgb</a>[2], NULL);
01086        } <span class="keywordflow">else</span> {
01087            <span class="keywordtype">int</span>  idx =  project_list-&gt;<a class="code" href="structproject__list__t.html#o0">layerno</a>;
01088 <span class="preprocessor">#ifdef USE_GTK2        </span>
01089 <span class="preprocessor"></span>        <span class="keywordtype">char</span> project_pnp_layer[MAXL] = <span class="stringliteral">""</span>;
01090         
01091         <span class="keywordflow">if</span> (project_list-&gt;<a class="code" href="structproject__list__t.html#o4">is_pnp</a>) {
01092             <a class="code" href="search__gui_8c.html#a8">create_search_window</a>(NULL, NULL);
01093             <span class="keywordflow">if</span> (<a class="code" href="search__cb_8c.html#a3">open_pnp</a>(project_list-&gt;<a class="code" href="structproject__list__t.html#o1">filename</a>, idx, FALSE) == -1) {
01094                 GERB_MESSAGE(<span class="stringliteral">"could not read %s[%d]"</span>, project_list-&gt;<a class="code" href="structproject__list__t.html#o1">filename</a>,
01095                     idx);
01096                 <span class="keywordflow">goto</span> next_layer;
01097             }
01098 <span class="comment">//            update_combo_box_model();</span>
01099             sprintf(project_pnp_layer,<span class="stringliteral">"%i"</span>, project_list-&gt;<a class="code" href="structproject__list__t.html#o0">layerno</a>);
01100             gtk_tree_model_get_iter_from_string(GTK_TREE_MODEL(combo_box_model), &amp;iter, project_pnp_layer);
01101             g_signal_emit_by_name ((GTK_COMBO_BOX(interface.<a class="code" href="struct__InterfaceStruct.html#o15">layer_active</a>)), <span class="stringliteral">"changed"</span>);
01102             gtk_combo_box_set_active_iter   (GTK_COMBO_BOX(interface.<a class="code" href="struct__InterfaceStruct.html#o15">layer_active</a>), &amp;iter);
01103             click_layer_active_cb(GTK_WIDGET(interface.<a class="code" href="struct__InterfaceStruct.html#o15">layer_active</a>), NULL);   
01104             <a class="code" href="search__mark_8c.html#a0">create_marked_layer</a>(idx);
01105        } <span class="keywordflow">else</span> {
01106 <span class="preprocessor">#endif        </span>
01107 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (open_image(project_list-&gt;<a class="code" href="structproject__list__t.html#o1">filename</a>, idx, FALSE) == -1) {
01108                 GERB_MESSAGE(<span class="stringliteral">"could not read %s[%d]"</span>, project_list-&gt;<a class="code" href="structproject__list__t.html#o1">filename</a>,
01109                     idx);
01110                 <span class="keywordflow">goto</span> next_layer;
01111             }
01112 <span class="preprocessor">#ifdef USE_GTK2            </span>
01113 <span class="preprocessor"></span>        }    
01114 <span class="preprocessor">#endif        </span>
01115 <span class="preprocessor"></span>           <span class="comment">/* </span>
01116 <span class="comment">            * Change color from default to from the project list</span>
01117 <span class="comment">            */</span>
01118            free(<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;color);
01119            <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;color = alloc_color(project_list-&gt;<a class="code" href="structproject__list__t.html#o2">rgb</a>[0], 
01120                                             project_list-&gt;<a class="code" href="structproject__list__t.html#o2">rgb</a>[1],
01121                                             project_list-&gt;<a class="code" href="structproject__list__t.html#o2">rgb</a>[2], NULL);
01122 
01123            <span class="comment">/* </span>
01124 <span class="comment">            * Also change color on layer button</span>
01125 <span class="comment">            */</span>
01126            defstyle = gtk_widget_get_default_style();
01127            newstyle = gtk_style_copy(defstyle);
01128            newstyle-&gt;bg[GTK_STATE_NORMAL] = *(<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;color);
01129            newstyle-&gt;bg[GTK_STATE_ACTIVE] = *(<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;color);
01130            newstyle-&gt;bg[GTK_STATE_PRELIGHT] = *(<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;color);
01131            gtk_widget_set_style(<a class="code" href="gerbv_8c.html#a0">screen</a>.layer_button[idx], newstyle);
01132 
01133            <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;<a class="code" href="structproject__list__t.html#o3">inverted</a> = project_list-&gt;<a class="code" href="structproject__list__t.html#o3">inverted</a>;
01134        }
01135         next_layer:
01136        pl_tmp = project_list;
01137        project_list = project_list-&gt;<a class="code" href="structproject__list__t.html#o5">next</a>;
01138         free(pl_tmp-&gt;<a class="code" href="structproject__list__t.html#o1">filename</a>);
01139        free(pl_tmp);
01140     }
01141 
01142     <span class="keywordflow">return</span>;
01143 } <span class="comment">/* load_project */</span>
01144 
01145 
01146 <span class="keywordtype">void</span>
01147 autoscale(<span class="keywordtype">void</span>)
01148 {
01149     <span class="keywordtype">double</span> max_width = LONG_MIN, max_height = LONG_MIN;
01150     <span class="keywordtype">double</span> x_scale, y_scale;
01151     <span class="keywordtype">int</span> i;
01152     
01153     <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area == NULL)
01154        <span class="keywordflow">return</span>;
01155 
01156     <a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.x1 = HUGE_VAL;
01157     <a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.y1 = HUGE_VAL;
01158     <a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.x2 = -HUGE_VAL;
01159     <a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.y2 = -HUGE_VAL;
01160 
01161     <span class="keywordflow">for</span>(i = 0; i &lt; MAX_FILES; i++) {
01162     <span class="comment">/*check if not only screen.file[] exists, but also if it is not a search and select layer*/</span>
01163         <span class="keywordflow">if</span> ((<a class="code" href="gerbv_8c.html#a0">screen</a>.file[i]) &amp;&amp; (<a class="code" href="gerbv_8c.html#a0">screen</a>.file[i]-&gt;image != NULL)){
01164             
01165             <span class="comment">/* </span>
01166 <span class="comment">             * Find the biggest image and use as a size reference</span>
01167 <span class="comment">             */</span>
01168            <a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.x1 = MIN(<a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.x1,
01169                                    <a class="code" href="gerbv_8c.html#a0">screen</a>.file[i]-&gt;image-&gt;info-&gt;min_x+
01170                                    <a class="code" href="gerbv_8c.html#a0">screen</a>.file[i]-&gt;image-&gt;info-&gt;offset_a);
01171            <a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.y1 = MIN(<a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.y1,
01172                                    <a class="code" href="gerbv_8c.html#a0">screen</a>.file[i]-&gt;image-&gt;info-&gt;min_y+
01173                                    <a class="code" href="gerbv_8c.html#a0">screen</a>.file[i]-&gt;image-&gt;info-&gt;offset_b);
01174            <a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.x2 = MAX(<a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.x2,
01175                                    <a class="code" href="gerbv_8c.html#a0">screen</a>.file[i]-&gt;image-&gt;info-&gt;max_x+
01176                                    <a class="code" href="gerbv_8c.html#a0">screen</a>.file[i]-&gt;image-&gt;info-&gt;offset_a);
01177            <a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.y2 = MAX(<a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.y2,
01178                                    <a class="code" href="gerbv_8c.html#a0">screen</a>.file[i]-&gt;image-&gt;info-&gt;max_y+
01179                                    <a class="code" href="gerbv_8c.html#a0">screen</a>.file[i]-&gt;image-&gt;info-&gt;offset_b);
01180         }
01181     }
01182 
01183 
01184     max_width = <a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.x2 - <a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.x1;
01185     max_height = <a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.y2 - <a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.y1;
01186 
01187     <span class="comment">/*</span>
01188 <span class="comment">     * Calculate scale for both x axis and y axis</span>
01189 <span class="comment">     */</span>
01190     x_scale = <a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area-&gt;allocation.width / max_width;
01191     y_scale = <a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area-&gt;allocation.height / max_height;
01192 
01193     <span class="comment">/*</span>
01194 <span class="comment">     * Take the scale that fits both directions with some extra checks</span>
01195 <span class="comment">     */</span>
01196     <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale = (int)ceil(MIN(x_scale, y_scale));
01197     <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale &lt; 1)
01198        <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale = 1;
01199     <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale &gt; 10)
01200        <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale = floor(<a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale / 10) * 10;
01201 
01202     <span class="comment">/*</span>
01203 <span class="comment">     * Calculate translation</span>
01204 <span class="comment">     */</span>
01205     <span class="keywordflow">if</span> (x_scale &lt; y_scale) {
01206        <a class="code" href="gerbv_8c.html#a0">screen</a>.trans_x = 0;
01207        <a class="code" href="gerbv_8c.html#a0">screen</a>.trans_y = -(int)((double)((<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area-&gt;allocation.height-<a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale*(max_height))/2.0));
01208     } <span class="keywordflow">else</span> {
01209        <a class="code" href="gerbv_8c.html#a0">screen</a>.trans_x = -(int)((double)((<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area-&gt;allocation.width-<a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale*(max_width))/2.0));
01210        <a class="code" href="gerbv_8c.html#a0">screen</a>.trans_y = 0;
01211     }
01212 
01213     <span class="comment">/* Initialize clipping bbox to contain entire image */</span>
01214     <a class="code" href="gerbv_8c.html#a0">screen</a>.clip_bbox.x1 = -<a class="code" href="gerbv_8c.html#a0">screen</a>.trans_x/(double)<a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale;
01215     <a class="code" href="gerbv_8c.html#a0">screen</a>.clip_bbox.y1 = -<a class="code" href="gerbv_8c.html#a0">screen</a>.trans_y/(double)<a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale;
01216     <a class="code" href="gerbv_8c.html#a0">screen</a>.clip_bbox.x2 = <a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.x2-<a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.x1;
01217     <a class="code" href="gerbv_8c.html#a0">screen</a>.clip_bbox.y2 = <a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.y2-<a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.y1;
01218     <a class="code" href="gerbv_8c.html#a0">screen</a>.off_x = 0;
01219     <a class="code" href="gerbv_8c.html#a0">screen</a>.off_y = 0;
01220 
01221     <span class="keywordflow">return</span>;
01222 } <span class="comment">/* autoscale */</span>
01223 
01224 <span class="comment">/*</span>
01225 <span class="comment"> * idle_redraw_pixmap_active is true when idle_redraw_pixmap</span>
01226 <span class="comment"> * is called, during this time we are not allowed to call the</span>
01227 <span class="comment"> * gtk_idle_xxx functions.</span>
01228 <span class="comment"> */</span>
01229 gboolean idle_redraw_pixmap_active = FALSE;
01230 gboolean <a class="code" href="gerbv_8c.html#a59">idle_redraw_pixmap</a>(gpointer data);
01231 
01232 <span class="keywordtype">void</span>
01233 start_idle_redraw_pixmap(GtkWidget *data)
01234 {
01235     <span class="keywordflow">if</span> (!idle_redraw_pixmap_active) {
01236        gtk_idle_add(idle_redraw_pixmap, (gpointer) data);
01237        idle_redraw_pixmap_active = TRUE;
01238     }
01239 } <span class="comment">/* start_idle_redraw_pixmap */</span>
01240 
01241 
01242 <span class="keywordtype">void</span>
01243 stop_idle_redraw_pixmap(GtkWidget *data)
01244 {
01245     <span class="keywordflow">if</span> (!idle_redraw_pixmap_active) {
01246        gtk_idle_remove_by_data ((gpointer)data);
01247        idle_redraw_pixmap_active = FALSE;
01248     }
01249 } <span class="comment">/* stop_idle_redraw_pixmap */</span>
01250 
01251 
01255 gboolean
<a name="l01256"></a><a class="code" href="gerbv_8c.html#a59">01256</a> <a class="code" href="gerbv_8c.html#a59">idle_redraw_pixmap</a>(gpointer data)
01257 {
01258     gboolean retval;
01259 
01260     idle_redraw_pixmap_active = TRUE;
01261     <span class="keywordflow">if</span> (redraw_pixmap((GtkWidget *) data, FALSE)) {
01262        retval = TRUE;
01263     } <span class="keywordflow">else</span> {
01264        retval = FALSE;
01265     }
01266     idle_redraw_pixmap_active = FALSE;
01267     <span class="keywordflow">return</span> retval;
01268 } <span class="comment">/* idle_redraw_pixmap */</span>
01269 
01270 
01271 <span class="keyword">static</span> <span class="keywordtype">void</span>
01272 menu_zoom(GtkWidget *widget, gpointer data)
01273 {
01274     gerbv_zoom_data_t z_data = { (gerbv_zoom_dir_t)data, NULL };
01275 
01276     zoom(widget, &amp;z_data);
01277 } <span class="comment">/* menu_zoom */</span>
01278 
01279 
01280 <span class="comment">/* Superimpose function */</span>
01281 <span class="keyword">static</span> <span class="keywordtype">void</span> 
01282 si_func(GtkWidget *widget, gpointer data)
01283 {
01284 
01285     <span class="keywordflow">if</span> ((GdkFunction)data  == <a class="code" href="gerbv_8c.html#a0">screen</a>.si_func)
01286        <span class="keywordflow">return</span>;
01287     
01288     <a class="code" href="gerbv_8c.html#a0">screen</a>.si_func = (GdkFunction)data;
01289 
01290     <span class="comment">/* Redraw the image(s) */</span>
01291     redraw_pixmap(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area, TRUE);
01292 
01293     <span class="keywordflow">return</span>;
01294 }
01295 
01296 
01297 <span class="comment">/* Unit function, sets unit for statusbar */</span>
01298 <span class="keyword">static</span> <span class="keywordtype">void</span> 
01299 unit_func(GtkWidget *widget, gpointer data)
01300 {
01301 
01302     <span class="keywordflow">if</span> ((gerbv_unit_t)data  == <a class="code" href="gerbv_8c.html#a0">screen</a>.unit)
01303        <span class="keywordflow">return</span>;
01304     
01305     <a class="code" href="gerbv_8c.html#a0">screen</a>.unit = (gerbv_unit_t)data;
01306 
01307     <span class="comment">/* Redraw the status bar */</span>
01308     <a class="code" href="gerbv_8c.html#a38">update_statusbar</a>(&amp;screen);
01309 
01310     <span class="keywordflow">return</span>;
01311 } <span class="comment">/* unit_func() */</span>
01312 
01313 
01314 <span class="comment">/* Zoom function */</span>
01315 <span class="keyword">static</span> <span class="keywordtype">void</span>
01316 zoom(GtkWidget *widget, gpointer data)
01317 {
01318     <span class="keywordtype">double</span> us_midx, us_midy;       <span class="comment">/* unscaled translation for screen center */</span>
01319     <span class="keywordtype">int</span> half_w, half_h;            <span class="comment">/* cache for half window dimensions */</span>
01320     <span class="keywordtype">int</span> mouse_delta_x = 0;  <span class="comment">/* Delta for mouse to window center */</span>
01321     <span class="keywordtype">int</span> mouse_delta_y = 0;
01322     gerbv_zoom_data_t *z_data = (gerbv_zoom_data_t *) data;
01323 
01324     half_w = <a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area-&gt;allocation.width / 2;
01325     half_h = <a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area-&gt;allocation.height / 2;
01326 
01327     <span class="keywordflow">if</span> (z_data-&gt;z_dir == ZOOM_IN_CMOUSE ||
01328        z_data-&gt;z_dir == ZOOM_OUT_CMOUSE) {
01329        mouse_delta_x = half_w - z_data-&gt;z_event-&gt;x;
01330        mouse_delta_y = half_h - z_data-&gt;z_event-&gt;y;
01331        <a class="code" href="gerbv_8c.html#a0">screen</a>.trans_x -= mouse_delta_x;
01332        <a class="code" href="gerbv_8c.html#a0">screen</a>.trans_y -= mouse_delta_y;
01333     }
01334 
01335     us_midx = (<a class="code" href="gerbv_8c.html#a0">screen</a>.trans_x + half_w)/(double) <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale;
01336     us_midy = (<a class="code" href="gerbv_8c.html#a0">screen</a>.trans_y + half_h)/(double) <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale;
01337 
01338     <span class="keywordflow">switch</span>(z_data-&gt;z_dir) {
01339     <span class="keywordflow">case</span> ZOOM_IN : <span class="comment">/* Zoom In */</span>
01340     <span class="keywordflow">case</span> ZOOM_IN_CMOUSE : <span class="comment">/* Zoom In Around Mouse Pointer */</span>
01341        <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale += <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale/10;
01342        <a class="code" href="gerbv_8c.html#a0">screen</a>.trans_x = <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale * us_midx - half_w;
01343        <a class="code" href="gerbv_8c.html#a0">screen</a>.trans_y = <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale * us_midy - half_h;
01344        <span class="keywordflow">break</span>;
01345     <span class="keywordflow">case</span> ZOOM_OUT :  <span class="comment">/* Zoom Out */</span>
01346     <span class="keywordflow">case</span> ZOOM_OUT_CMOUSE : <span class="comment">/* Zoom Out Around Mouse Pointer */</span>
01347        <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale &gt; 10) {
01348            <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale -= <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale/10;
01349            <a class="code" href="gerbv_8c.html#a0">screen</a>.trans_x = <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale * us_midx - half_w;
01350            <a class="code" href="gerbv_8c.html#a0">screen</a>.trans_y = <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale * us_midy - half_h;
01351        }
01352        <span class="keywordflow">break</span>;
01353     <span class="keywordflow">case</span> ZOOM_FIT : <span class="comment">/* Zoom Fit */</span>
01354        autoscale();
01355        <span class="keywordflow">break</span>;
01356     <span class="keywordflow">case</span> ZOOM_SET : <span class="comment">/*explicit scale set by user */</span>
01357        <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale = z_data-&gt;scale;
01358        <a class="code" href="gerbv_8c.html#a0">screen</a>.trans_x = <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale * us_midx - half_w;
01359        <a class="code" href="gerbv_8c.html#a0">screen</a>.trans_y = <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale * us_midy - half_h;
01360         <span class="keywordflow">break</span>;
01361     <span class="keywordflow">default</span> :
01362        GERB_MESSAGE(<span class="stringliteral">"Illegal zoom direction %ld\n"</span>, (<span class="keywordtype">long</span> <span class="keywordtype">int</span>)data);
01363     }
01364 
01365     <span class="keywordflow">if</span> (z_data-&gt;z_dir == ZOOM_IN_CMOUSE ||
01366        z_data-&gt;z_dir == ZOOM_OUT_CMOUSE) {
01367        <a class="code" href="gerbv_8c.html#a0">screen</a>.trans_x += mouse_delta_x;
01368        <a class="code" href="gerbv_8c.html#a0">screen</a>.trans_y += mouse_delta_y;
01369     }
01370 
01371     <span class="comment">/* Update clipping bbox */</span>
01372     <a class="code" href="gerbv_8c.html#a0">screen</a>.clip_bbox.x1 = -<a class="code" href="gerbv_8c.html#a0">screen</a>.trans_x/(double)<a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale;
01373     <a class="code" href="gerbv_8c.html#a0">screen</a>.clip_bbox.y1 = -<a class="code" href="gerbv_8c.html#a0">screen</a>.trans_y/(double)<a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale;    
01374 
01375     <span class="comment">/* Redraw screen */</span>
01376     redraw_pixmap(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area, TRUE);
01377     
01378     <span class="keywordflow">return</span>;
01379 } <span class="comment">/* zoom */</span>
01380 
01381 
01384 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01385"></a><a class="code" href="gerbv_8c.html#a35">01385</a> <a class="code" href="gerbv_8c.html#a35">zoom_outline</a>(GtkWidget *widget, GdkEventButton *event)
01386 {
01387     <span class="keywordtype">int</span> x1, y1, x2, y2, dx, dy;    <span class="comment">/* Zoom outline (UR and LL corners) */</span>
01388     <span class="keywordtype">double</span> us_x1, us_y1, us_x2, us_y2;
01389     <span class="keywordtype">int</span> half_w, half_h;            <span class="comment">/* cache for half window dimensions */</span>
01390 <span class="preprocessor">#ifdef USE_GTK2    </span>
01391 <span class="preprocessor"></span>    gchar *designator, *comment, *footprint;
01392     GList *tmp_list = NULL;
01393     GtkTreeIter iter;
01394     <span class="keywordtype">double</span> mid_x, mid_y, pad_x, pad_y, length, width;
01395 <span class="preprocessor">#endif    </span>
01396 <span class="preprocessor"></span>
01397     
01398     half_w = <a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area-&gt;allocation.width / 2;
01399     half_h = <a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area-&gt;allocation.height / 2;
01400 
01401     x1 = MIN(<a class="code" href="gerbv_8c.html#a0">screen</a>.start_x, event-&gt;x);
01402     y1 = MIN(<a class="code" href="gerbv_8c.html#a0">screen</a>.start_y, event-&gt;y);
01403     x2 = MAX(<a class="code" href="gerbv_8c.html#a0">screen</a>.start_x, event-&gt;x);
01404     y2 = MAX(<a class="code" href="gerbv_8c.html#a0">screen</a>.start_y, event-&gt;y);
01405     dx = x2-x1;
01406     dy = y2-y1;
01407 
01408     <span class="keywordflow">if</span> (dx &lt; 4 &amp;&amp; dy &lt; 4) {
01409 <span class="preprocessor">#ifndef     USE_GTK2</span>
01410 <span class="preprocessor"></span>       GERB_MESSAGE(<span class="stringliteral">"Warning: Zoom area too small, bailing out!\n"</span>);
01411 <span class="preprocessor">#else    </span>
01412 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (parsed_PNP_data == NULL)
01413       <span class="keywordflow">return</span>;
01414     tmp_list = gtk_tree_selection_get_selected_rows
01415                                             (GTK_TREE_SELECTION(interface.<a class="code" href="struct__InterfaceStruct.html#o19">selection</a>),
01416                                              (GtkTreeModel **)&amp;interface.<a class="code" href="struct__InterfaceStruct.html#o17">model</a>);<span class="comment">//item must be in the active selection list </span>
01417     <span class="keywordflow">if</span> (tmp_list == NULL) 
01418         <span class="keywordflow">return</span>;
01419                                                          
01420     tmp_list  = g_list_first(tmp_list);
01421     <span class="keywordflow">do</span> {   
01422         gtk_tree_model_get_iter         (GTK_TREE_MODEL(interface.<a class="code" href="struct__InterfaceStruct.html#o17">model</a>),
01423                                          &amp;iter,
01424                                          tmp_list-&gt;data);
01425         
01426         gtk_tree_model_get              (GTK_TREE_MODEL(interface.<a class="code" href="struct__InterfaceStruct.html#o17">model</a>),
01427                                          &amp;iter,
01428                                          COLUMN_DESIGNATOR, &amp;designator, 
01429                                          COLUMN_mid_x, &amp;mid_x, 
01430                                          COLUMN_mid_y, &amp;mid_y, 
01431                                          COLUMN_pad_x, &amp;pad_x, 
01432                                          COLUMN_pad_y, &amp;pad_y,
01433                                          COLUMN_length, &amp;length,
01434                                          COLUMN_width, &amp;width, 
01435                                          COLUMN_COMMENT, &amp;comment,
01436                                          COLUMN_footprint, &amp;footprint, -1);                                  
01437 <span class="comment">//        printf("Iter: %s", gtk_tree_model_get_string_from_iter(GTK_TREE_MODEL(interface.model), &amp;iter));                                         </span>
01438         <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.unit == GERBV_MILS) {
01439 
01440             us_x1 = COORD2MILS(<a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.x1 + (x1+<a class="code" href="gerbv_8c.html#a0">screen</a>.trans_x)/(<span class="keywordtype">double</span>)<a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale);
01441             us_y1 = COORD2MILS(<a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.y2 - (y1+<a class="code" href="gerbv_8c.html#a0">screen</a>.trans_y)/(<span class="keywordtype">double</span>)<a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale);
01442         } <span class="keywordflow">else</span> {
01443             us_x1 = COORD2MMS(<a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.x1 + (x1+<a class="code" href="gerbv_8c.html#a0">screen</a>.trans_x)/(<span class="keywordtype">double</span>)<a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale);
01444             us_y1 = COORD2MMS(<a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.y2 - (y1+<a class="code" href="gerbv_8c.html#a0">screen</a>.trans_y)/(<span class="keywordtype">double</span>)<a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale);
01445         }    
01446 
01447 <span class="comment">//        printf("x1/y1:%d/%d,  translated: us_x1/us_y1:%f/%f, desig %s, mid_x/y %f/%f, calc'ed range x1/2:%f/%f, padx/y %f/%f\n",</span>
01448 <span class="comment">//            x1, y1, us_x1, us_y1, designator, mid_x, mid_y, (mid_x - fabs(mid_x - pad_x)) ,(mid_x + fabs(mid_x - pad_x)), pad_x, pad_y);</span>
01449 
01450 
01451         <span class="keywordflow">if</span> ((((us_x1 &gt;= (mid_x - width/2)) &amp;&amp;  (us_x1 &lt;= (mid_x + width/2))) 
01452             &amp;&amp; ((us_y1 &gt;= (mid_y - length/2)) &amp;&amp; (us_y1 &lt;= (mid_y + length/2))) <span class="comment">//rectangular PIN1 on centre axis</span>
01453             &amp;&amp; (((length != 0) &amp;&amp; (width != 0))))            
01454             ||
01455          (((us_x1 &gt;= (mid_x - fabs(mid_x - pad_x))) &amp;&amp; (us_x1 &lt;= (mid_x + fabs(mid_x - pad_x)))) <span class="comment">//rectangluar PIN1 off centre axis</span>
01456             &amp;&amp; ((us_y1 &gt;= (mid_y - fabs(mid_y - pad_y))) &amp;&amp; (us_y1 &lt;= (mid_y + fabs(mid_y - pad_y)))))
01457             ||
01458             (((us_x1 &gt;= (mid_x - 3)) &amp;&amp; (us_x1 &lt;= (mid_x + 3)))
01459             &amp;&amp; ((us_y1 &gt;= (mid_y - 3)) &amp;&amp; (us_y1 &lt;= (mid_y + 3))))) <span class="comment">//circular shapes workaround 3mm in each direction</span>
01460 <span class="preprocessor">#if 0            </span>
01461 <span class="preprocessor"></span>            (((us_x1 &gt;= (mid_x - (fabs(mid_x - pad_x) / 4))) &amp;&amp; (us_x1 &lt;= (mid_x + (fabs(mid_x - pad_x) / 4))))
01462             &amp;&amp; ((us_y1 &gt;= (mid_y - (fabs(mid_y - pad_y) / 4))) &amp;&amp; (us_y1 &lt;= (mid_y + (fabs(mid_y - pad_y) / 4)))))) <span class="comment">//circular shapes</span>
01463 <span class="preprocessor">#endif            </span>
01464 <span class="preprocessor"></span>            {
01465             
01466             <span class="comment">//pointer must be in range of element;  FIX ME range is rectangular, but in reality it can be circular as well for unknown shapes</span>
01467             
01468             <span class="keywordflow">if</span> ( !g_utf8_validate(designator, -1, NULL)) {
01469                 <span class="comment">//memset  (designator, 0, sizeof(designator));</span>
01470 
01471                 gchar * str_designator = g_convert(designator, strlen(designator), <span class="stringliteral">"UTF-8"</span>, <span class="stringliteral">"ISO-8859-1"</span>,
01472                             NULL, NULL, NULL);
01473                 <span class="comment">// I have not decided yet whether it is better to use always</span>
01474                 <span class="comment">// "ISO-8859-1" or current locale.</span>
01475                 <span class="comment">// str = g_locale_to_utf8(row[10], -1, NULL, NULL, NULL);</span>
01476 
01477                 sprintf (designator, <span class="stringliteral">"%.*s"</span>, <span class="keyword">sizeof</span>(designator)-1, str_designator);
01478                 g_free(str_designator);
01479             } 
01480              <span class="keywordflow">if</span> ( !g_utf8_validate(comment, -1, NULL)) {
01481                 <span class="comment">//memset  (designator, 0, sizeof(designator));</span>
01482 
01483                 gchar * str_comment = g_convert(comment, strlen(comment), <span class="stringliteral">"UTF-8"</span>, <span class="stringliteral">"ISO-8859-1"</span>,
01484                             NULL, NULL, NULL);
01485                 <span class="comment">// I have not decided yet whether it is better to use always</span>
01486                 <span class="comment">// "ISO-8859-1" or current locale.</span>
01487                 <span class="comment">// str = g_locale_to_utf8(row[10], -1, NULL, NULL, NULL);</span>
01488 
01489                 sprintf (comment, <span class="stringliteral">"%.*s"</span>, <span class="keyword">sizeof</span>(comment)-1, str_comment);
01490                 g_free(str_comment);
01491             } 
01492              <span class="keywordflow">if</span> ( !g_utf8_validate(footprint, -1, NULL)) {
01493                 <span class="comment">//memset  (designator, 0, sizeof(designator));</span>
01494 
01495                 gchar * str_footprint = g_convert(footprint, strlen(footprint), <span class="stringliteral">"UTF-8"</span>, <span class="stringliteral">"ISO-8859-1"</span>,
01496                             NULL, NULL, NULL);
01497                 <span class="comment">// I have not decided yet whether it is better to use always</span>
01498                 <span class="comment">// "ISO-8859-1" or current locale.</span>
01499                 <span class="comment">// str = g_locale_to_utf8(row[10], -1, NULL, NULL, NULL);</span>
01500 
01501                 sprintf (footprint, <span class="stringliteral">"%.*s"</span>, <span class="keyword">sizeof</span>(footprint)-1, str_footprint);
01502                 g_free(str_footprint);
01503             }     
01504 
01505             snprintf(<a class="code" href="gerbv_8c.html#a0">screen</a>.statusbar.diststr, MAX_DISTLEN,
01506                        <span class="stringliteral">"P: %s, C:%s, FP:%s"</span>, designator, comment, footprint);
01507             GERB_MESSAGE(<span class="stringliteral">"The part you have selected is: %s, Comment: %s, Footprint %s\n"</span>, designator, comment, footprint);
01508            
01509             <span class="keywordflow">break</span>;
01510 
01511         } <span class="keywordflow">else</span> {
01512             snprintf(<a class="code" href="gerbv_8c.html#a0">screen</a>.statusbar.diststr, MAX_DISTLEN,
01513                        <span class="stringliteral">"%s"</span>, <span class="stringliteral">"        "</span>);<span class="comment">//blank the statusbar in this section</span>
01514         }     
01515                                                     
01516     } <span class="keywordflow">while</span> ((tmp_list = g_list_next(tmp_list)));
01517           
01518        <a class="code" href="gerbv_8c.html#a38">update_statusbar</a>(&amp;<a class="code" href="gerbv_8c.html#a0">screen</a>);
01519 <span class="preprocessor">#endif    </span>
01520 <span class="preprocessor"></span>       <span class="keywordflow">goto</span> zoom_outline_end;
01521     }
01522 
01523     <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.centered_outline_zoom) {
01524        <span class="comment">/* Centered outline mode */</span>
01525        x1 = <a class="code" href="gerbv_8c.html#a0">screen</a>.start_x - dx;
01526        y1 = <a class="code" href="gerbv_8c.html#a0">screen</a>.start_y - dy;
01527        dx *= 2;
01528        dy *= 2;
01529     }
01530 
01531     us_x1 = (<a class="code" href="gerbv_8c.html#a0">screen</a>.trans_x + x1)/(double) <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale;
01532     us_y1 = (<a class="code" href="gerbv_8c.html#a0">screen</a>.trans_y + y1)/(double) <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale;
01533     us_x2 = (<a class="code" href="gerbv_8c.html#a0">screen</a>.trans_x + x2)/(double) <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale;
01534     us_y2 = (<a class="code" href="gerbv_8c.html#a0">screen</a>.trans_y + y2)/(double) <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale;
01535 
01536     <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale = MIN(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area-&gt;allocation.width/(<span class="keywordtype">double</span>)(us_x2 - us_x1),
01537                      <a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area-&gt;allocation.height/(<span class="keywordtype">double</span>)(us_y2 - us_y1));
01538     <a class="code" href="gerbv_8c.html#a0">screen</a>.trans_x = <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale * (us_x1 + (us_x2 - us_x1)/2) - half_w;
01539     <a class="code" href="gerbv_8c.html#a0">screen</a>.trans_y = <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale * (us_y1 + (us_y2 - us_y1)/2) - half_h;;
01540     <a class="code" href="gerbv_8c.html#a0">screen</a>.clip_bbox.x1 = -<a class="code" href="gerbv_8c.html#a0">screen</a>.trans_x/(double)<a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale;
01541     <a class="code" href="gerbv_8c.html#a0">screen</a>.clip_bbox.y1 = -<a class="code" href="gerbv_8c.html#a0">screen</a>.trans_y/(double)<a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale;
01542 
01543 zoom_outline_end:
01544     <span class="comment">/* Redraw screen */</span>
01545     redraw_pixmap(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area, TRUE);
01546 } <span class="comment">/* zoom_outline */</span>
01547 
01548 
01549 GtkWidget *
01550 create_drawing_area(gint win_width, gint win_height)
01551 {
01552     GtkWidget *drawing_area;
01553     
01554     drawing_area = gtk_drawing_area_new();
01555     gtk_drawing_area_size(GTK_DRAWING_AREA(drawing_area), win_width, win_height);
01556     
01557     <span class="keywordflow">return</span> drawing_area;
01558 } <span class="comment">/* create_drawing_area */</span>
01559 
01560 
01561 <span class="comment">/* Invalidate state, free up pixmaps if necessary */</span>
01562  <span class="keywordtype">void</span>
01563 invalidate_redraw_state(<span class="keyword">struct</span> gerbv_redraw_state *state)
01564 {
01565     <span class="keywordflow">if</span> (state-&gt;valid) {
01566        state-&gt;valid = 0;
01567        <span class="comment">/* Free up pixmaps */</span>
01568        <span class="keywordflow">if</span> (state-&gt;curr_pixmap) {
01569            gdk_pixmap_unref(state-&gt;curr_pixmap);
01570        }
01571        <span class="keywordflow">if</span> (state-&gt;clipmask) {
01572            gdk_pixmap_unref(state-&gt;clipmask);
01573        }
01574     }
01575 } <span class="comment">/* invalidate_redraw_state() */</span>
01576 
01577 <span class="comment">/* Create a new backing pixmap of the appropriate size */</span>
01578  gint
01579 redraw_pixmap(GtkWidget *widget, <span class="keywordtype">int</span> restart)
01580 {
01581     <span class="keywordtype">int</span> i;
01582     <span class="keywordtype">double</span> dmax_x = LONG_MIN, dmax_y = LONG_MIN;
01583     <span class="keywordtype">double</span> dmin_x = LONG_MAX, dmin_y = LONG_MAX;
01584     GdkGC *gc = gdk_gc_new(widget-&gt;window);
01585     GdkRectangle update_rect;
01586     <span class="keywordtype">int</span> file_loaded = 0;
01587     GdkWindow *window;
01588     <span class="keywordtype">int</span> retval = TRUE;
01589     <span class="keyword">static</span> <span class="keyword">struct </span>gerbv_redraw_state state;
01590 
01591     window = gtk_widget_get_parent_window(widget);
01592     <span class="comment">/* This might be lengthy, show that we're busy by changing the pointer */</span>
01593     <span class="keywordflow">if</span> (window) {
01594        GdkCursor *cursor;
01595 
01596        cursor = gdk_cursor_new(GDK_WATCH);
01597        gdk_window_set_cursor(window, cursor);
01598        gdk_cursor_destroy(cursor);
01599     }
01600 
01601     <span class="comment">/* Stop the idle-function if we are not within an idle-call */</span>
01602     <span class="keywordflow">if</span> (state.valid) {
01603        stop_idle_redraw_pixmap(widget);
01604     }
01605     retval = FALSE;
01606 
01607     <span class="comment">/* Called first when opening window and then when resizing window */</span>
01608     <span class="keywordflow">for</span>(i = 0; i &lt; MAX_FILES; i++) {
01609        <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.file[i]) {
01610            file_loaded++;
01611        }
01612     }
01613 
01614     <span class="comment">/*</span>
01615 <span class="comment">     * Setup scale etc first time we load a file</span>
01616 <span class="comment">     */</span>
01617     <span class="keywordflow">if</span> (file_loaded &amp;&amp; <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale &lt; 0.001) {
01618        autoscale();
01619        invalidate_redraw_state(&amp;state);
01620     }
01621 
01622     <span class="comment">/*</span>
01623 <span class="comment">     * Find the biggest image and use as a size reference</span>
01624 <span class="comment">     */</span>
01625     dmax_x = <a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.x2;
01626     dmax_y = <a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.y2;
01627 
01628     <span class="comment">/*</span>
01629 <span class="comment">     * Also find the smallest coordinates to see if we have negative</span>
01630 <span class="comment">     * ones that must be compensated for.</span>
01631 <span class="comment">     */</span>
01632     dmin_x = <a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.x1;
01633     dmin_y = <a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.y1;
01634 
01635     <span class="comment">/* Should we restart drawing, or try to load a saved state? */</span>
01636     <span class="keywordflow">if</span> (!restart &amp;&amp; state.valid) {
01637        <span class="keywordflow">if</span> (file_loaded != state.files_loaded) {
01638            invalidate_redraw_state(&amp;state);
01639        }
01640 
01641        <span class="keywordflow">if</span> ((state.max_width != <a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area-&gt;allocation.width ||
01642            state.max_height != <a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area-&gt;allocation.height)) {
01643            invalidate_redraw_state(&amp;state);
01644        }
01645     } <span class="keywordflow">else</span> {
01646        invalidate_redraw_state(&amp;state);
01647     }
01648 
01649     <span class="comment">/* Check for useful data in saved state or initialise state */</span>
01650     <span class="keywordflow">if</span> (!state.valid) {
01651        <span class="keywordtype">int</span> width = 0, height = 0;
01652 
01653        <span class="comment">/*</span>
01654 <span class="comment">        * Paranoia check; size in width or height is zero</span>
01655 <span class="comment">        */</span>
01656        <span class="keywordflow">if</span> (!file_loaded) {
01657            retval = FALSE;
01658            <span class="keywordflow">goto</span> redraw_pixmap_end;
01659        }
01660 
01661        <span class="comment">/* Clear state */</span>
01662        memset(&amp;state, 0, <span class="keyword">sizeof</span>(state));
01663 
01664        state.files_loaded = file_loaded;
01665 
01666        <span class="comment">/*</span>
01667 <span class="comment">        * Pixmap size is always size of window, no</span>
01668 <span class="comment">        * matter how the scale.</span>
01669 <span class="comment">        */</span>
01670        gdk_window_get_size(widget-&gt;window, &amp;width, &amp;height);   
01671        state.max_width = width;
01672        state.max_height = height;
01673 
01674        <span class="comment">/* </span>
01675 <span class="comment">        * Remove old pixmap, allocate a new one, draw the background.</span>
01676 <span class="comment">        */</span>
01677        <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.pixmap) 
01678            gdk_pixmap_unref(<a class="code" href="gerbv_8c.html#a0">screen</a>.pixmap);
01679        <a class="code" href="gerbv_8c.html#a0">screen</a>.pixmap = gdk_pixmap_new(widget-&gt;window, state.max_width,
01680                                    state.max_height,  -1);
01681        gdk_gc_set_foreground(gc, <a class="code" href="gerbv_8c.html#a0">screen</a>.background);
01682        gdk_draw_rectangle(<a class="code" href="gerbv_8c.html#a0">screen</a>.pixmap, gc, TRUE, 0, 0, -1, -1);
01683 
01684        <span class="comment">/*</span>
01685 <span class="comment">        * Allocate the pixmap and the clipmask (a one pixel pixmap)</span>
01686 <span class="comment">        */</span>
01687        state.curr_pixmap = gdk_pixmap_new(widget-&gt;window,
01688                                       state.max_width,
01689                                       state.max_height,  -1);
01690        state.clipmask = gdk_pixmap_new(widget-&gt;window,
01691                                    state.max_width,
01692                                    state.max_height,  1);
01693 
01694        state.valid = 1;
01695     }
01696 
01697     <span class="comment">/*</span>
01698 <span class="comment">     * Set superimposing function.</span>
01699 <span class="comment">     */</span>
01700     gdk_gc_set_function(gc, <a class="code" href="gerbv_8c.html#a0">screen</a>.si_func);
01701 
01702     
01703     <span class="comment">/* </span>
01704 <span class="comment">     * This now allows drawing several layers on top of each other.</span>
01705 <span class="comment">     * Higher layer numbers have higher priority in the Z-order. </span>
01706 <span class="comment">     */</span>
01707     <span class="keywordflow">for</span>(i = state.file_index; i &lt; MAX_FILES; i++) {
01708        <span class="keywordflow">if</span> (g_main_pending()) {
01709            <span class="comment">/* return TRUE to keep this idle function active */</span>
01710            retval = TRUE;
01711            start_idle_redraw_pixmap(widget);
01712            state.file_index = i;
01713            <span class="keywordflow">goto</span> redraw_pixmap_end;
01714        }
01715        <span class="keywordflow">if</span> (GTK_TOGGLE_BUTTON(<a class="code" href="gerbv_8c.html#a0">screen</a>.layer_button[i])-&gt;active &amp;&amp;
01716            <a class="code" href="gerbv_8c.html#a0">screen</a>.file[i]) {
01717            <span class="keyword">enum</span> polarity_t polarity;
01718 
01719            <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.file[i]-&gt;inverted) {
01720               <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.file[i]-&gt;image-&gt;info-&gt;polarity == POSITIVE)
01721                   polarity = NEGATIVE;
01722               <span class="keywordflow">else</span>
01723                   polarity = POSITIVE;
01724            } <span class="keywordflow">else</span> {
01725               polarity = <a class="code" href="gerbv_8c.html#a0">screen</a>.file[i]-&gt;image-&gt;info-&gt;polarity;
01726            }
01727 
01728            <span class="comment">/*</span>
01729 <span class="comment">            * Show progress in status bar</span>
01730 <span class="comment">            */</span>
01731            snprintf(<a class="code" href="gerbv_8c.html#a0">screen</a>.statusbar.msgstr, MAX_STATUSMSGLEN,
01732                    <span class="stringliteral">"%d %s..."</span>,
01733                    i, <a class="code" href="gerbv_8c.html#a0">screen</a>.file[i]-&gt;basename);
01734            <a class="code" href="gerbv_8c.html#a38">update_statusbar</a>(&amp;screen);
01735 
01736            <span class="comment">/*</span>
01737 <span class="comment">            * Fill up image with all the foreground color. Excess pixels</span>
01738 <span class="comment">            * will be removed by clipmask.</span>
01739 <span class="comment">            */</span>
01740            gdk_gc_set_foreground(gc, <a class="code" href="gerbv_8c.html#a0">screen</a>.file[i]-&gt;color);
01741            gdk_draw_rectangle(state.curr_pixmap, gc, TRUE, 0, 0, -1, -1);
01742             <span class="comment">/* calculate shift */</span>
01743             <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;offset[0] = <a class="code" href="gerbv_8c.html#a0">screen</a>.clip_bbox.x1-dmin_x;
01744             <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;offset[1] = <a class="code" href="gerbv_8c.html#a0">screen</a>.clip_bbox.y1+dmax_y;
01745             <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;offset[0] *= <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale;
01746             <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;offset[1] *= <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale;
01747 
01748            <span class="comment">/*</span>
01749 <span class="comment">            * Translation is to get it inside the allocated pixmap,</span>
01750 <span class="comment">            * which is not always centered perfectly for GTK/X.</span>
01751 <span class="comment">            */</span>
01752            image2pixmap(&amp;(state.clipmask),
01753                       <a class="code" href="gerbv_8c.html#a0">screen</a>.file[i]-&gt;image, <a class="code" href="gerbv_8c.html#a0">screen</a>.transf, 
01754                          <span class="comment">/* screen.scale, </span>
01755 <span class="comment">                      (screen.clip_bbox.x1-dmin_x)*screen.transf-&gt;scale,</span>
01756 <span class="comment">                      (screen.clip_bbox.y1+dmax_y)*screen.transf-&gt;scale, */</span>
01757                       polarity);
01758 
01759            <span class="comment">/* </span>
01760 <span class="comment">            * Set clipmask and draw the clipped out image onto the</span>
01761 <span class="comment">            * screen pixmap. Afterwards we remove the clipmask, else</span>
01762 <span class="comment">            * it will screw things up when run this loop again.</span>
01763 <span class="comment">            */</span>
01764            gdk_gc_set_clip_mask(gc, state.clipmask);
01765            gdk_gc_set_clip_origin(gc, 0, 0);
01766            gdk_draw_pixmap(<a class="code" href="gerbv_8c.html#a0">screen</a>.pixmap, gc, state.curr_pixmap, -<a class="code" href="gerbv_8c.html#a0">screen</a>.off_x, -<a class="code" href="gerbv_8c.html#a0">screen</a>.off_y, 0, 0, -1, -1);
01767            gdk_gc_set_clip_mask(gc, NULL);
01768        }
01769     }
01770 
01771     <a class="code" href="gerbv_8c.html#a0">screen</a>.statusbar.msgstr[0] = <span class="charliteral">'\0'</span>;
01772     <a class="code" href="gerbv_8c.html#a38">update_statusbar</a>(&amp;screen);
01773     <span class="comment">/* Clean up */</span>
01774     state.valid = 0;
01775     <span class="comment">/* Free up pixmaps */</span>
01776     <span class="keywordflow">if</span> (state.curr_pixmap) {
01777        gdk_pixmap_unref(state.curr_pixmap);
01778     }
01779     <span class="keywordflow">if</span> (state.clipmask) {
01780        gdk_pixmap_unref(state.clipmask);
01781     }
01782 
01783     update_rect.x = 0, update_rect.y = 0;
01784     update_rect.width =     widget-&gt;allocation.width;
01785     update_rect.height = widget-&gt;allocation.height;
01786 
01787     <span class="comment">/*</span>
01788 <span class="comment">     * Calls expose_event</span>
01789 <span class="comment">     */</span>
01790     gtk_widget_draw(widget, &amp;update_rect);
01791 
01792 redraw_pixmap_end:
01793     <span class="comment">/* Return default pointer shape */</span>
01794     <span class="keywordflow">if</span> (window) {
01795        gdk_window_set_cursor(window, GERBV_DEF_CURSOR);
01796     }
01797 
01798     gdk_gc_unref(gc);
01799 
01800     <span class="keywordflow">return</span> retval;
01801 } <span class="comment">/* redraw_pixmap */</span>
01802 
01803 
01804 <span class="keyword">static</span> <span class="keywordtype">int</span>
01805 open_image(<span class="keywordtype">char</span> *filename, <span class="keywordtype">int</span> idx, <span class="keywordtype">int</span> reload)
01806 {
01807     gerb_file_t *fd;
01808     <span class="keywordtype">int</span> r, g, b;
01809     GtkStyle *defstyle, *newstyle;
01810     gerb_image_t *parsed_image;
01811     gerb_verify_error_t error = GERB_IMAGE_OK;
01812     <span class="keywordtype">char</span> *cptr;
01813 <span class="preprocessor">#ifdef USE_GTK2       </span>
01814 <span class="preprocessor"></span>    <span class="comment">//int          idx0;</span>
01815     GtkTreeIter  iter;
01816 <span class="preprocessor">#endif</span>
01817 <span class="preprocessor"></span>
01818     <span class="keywordflow">if</span> (idx &gt;= MAX_FILES) {
01819        GERB_MESSAGE(<span class="stringliteral">"Couldn't open %s. Maximum number of files opened.\n"</span>,
01820                    filename);
01821        <span class="keywordflow">return</span> -1;
01822     }
01823 
01824     fd = gerb_fopen(filename);
01825     <span class="keywordflow">if</span> (fd == NULL) {
01826        GERB_MESSAGE(<span class="stringliteral">"Trying to open %s:%s\n"</span>, filename, strerror(errno));
01827        <span class="keywordflow">return</span> -1;
01828     }
01829     
01830     <span class="keywordflow">if</span>(drill_file_p(fd))
01831        parsed_image = parse_drillfile(fd);
01832     <span class="keywordflow">else</span> 
01833        parsed_image = parse_gerb(fd);
01834 
01835     gerb_fclose(fd);
01836 
01837     <span class="comment">/*</span>
01838 <span class="comment">     * Do error check before continuing</span>
01839 <span class="comment">     */</span>
01840     error = gerb_image_verify(parsed_image);
01841     <span class="keywordflow">if</span> (error) {
01842        GERB_COMPILE_ERROR(<span class="stringliteral">"%s: Parse error:\n"</span>, filename);
01843        <span class="keywordflow">if</span> (error &amp; GERB_IMAGE_MISSING_NETLIST)
01844            GERB_COMPILE_ERROR(<span class="stringliteral">"* Missing netlist\n"</span>);
01845        <span class="keywordflow">if</span> (error &amp; GERB_IMAGE_MISSING_FORMAT)
01846            GERB_COMPILE_ERROR(<span class="stringliteral">"* Missing format\n"</span>);
01847        <span class="keywordflow">if</span> (error &amp; GERB_IMAGE_MISSING_APERTURES) 
01848            GERB_COMPILE_ERROR(<span class="stringliteral">"* Missing apertures/drill sizes\n"</span>);
01849        <span class="keywordflow">if</span> (error &amp; GERB_IMAGE_MISSING_INFO)
01850            GERB_COMPILE_ERROR(<span class="stringliteral">"* Missing info\n"</span>);
01851        GERB_COMPILE_ERROR(<span class="stringliteral">"\n"</span>);
01852        GERB_COMPILE_ERROR(<span class="stringliteral">"You probably tried to read an RS-274D file, which gerbv doesn't support\n"</span>);
01853        free_gerb_image(parsed_image);
01854        <span class="keywordflow">return</span> -1;
01855     }
01856 
01857     <span class="comment">/* Used to debug parser */</span>
01858     <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.dump_parsed_image)
01859        gerb_image_dump(parsed_image);
01860 
01861     <span class="comment">/*</span>
01862 <span class="comment">     * If reload, just exchange the image. Else we have to allocate</span>
01863 <span class="comment">     * a new memory before we define anything more.</span>
01864 <span class="comment">     */</span>
01865     <span class="keywordflow">if</span> (reload) {
01866        free_gerb_image(<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;image);
01867        <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;image = parsed_image;
01868        <span class="keywordflow">return</span> 0;
01869     } <span class="keywordflow">else</span> {
01870        <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx] = (gerbv_fileinfo_t *)malloc(<span class="keyword">sizeof</span>(gerbv_fileinfo_t));
01871        memset((<span class="keywordtype">void</span> *)<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx], 0, <span class="keyword">sizeof</span>(gerbv_fileinfo_t));
01872        <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;image = parsed_image;
01873     }
01874 
01875     <span class="comment">/*</span>
01876 <span class="comment">     * Store filename for eventual reload</span>
01877 <span class="comment">     * XXX Really should check retval from malloc!!! And use strncpy</span>
01878 <span class="comment">     */</span>
01879     <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;name = (<span class="keywordtype">char</span> *)malloc(strlen(filename) + 1);
01880     strcpy(<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;name, filename);
01881 
01882     <span class="comment">/*</span>
01883 <span class="comment">     * Try to get a basename for the file</span>
01884 <span class="comment">     */</span>
01885      
01886     cptr = strrchr(filename, path_separator);
01887     <span class="keywordflow">if</span> (cptr) {
01888        <span class="keywordtype">int</span> len;
01889 
01890        len = strlen(cptr);
01891        <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;basename = (<span class="keywordtype">char</span> *)malloc(len + 1);
01892        <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;basename) {
01893            strncpy(<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;basename, cptr+1, len);
01894            <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;basename[len] = <span class="charliteral">'\0'</span>;
01895        } <span class="keywordflow">else</span> {
01896            <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;basename = <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;name;
01897        }
01898     } <span class="keywordflow">else</span> {
01899        <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;basename = <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;name;
01900     }
01901 
01902     <span class="comment">/*</span>
01903 <span class="comment">     * Calculate a "clever" random color based on index.</span>
01904 <span class="comment">     */</span>
01905     r = (12341 + 657371 * idx) % (int)(MAX_COLOR_RESOLUTION);
01906     g = (23473 + 434382 * idx) % (int)(MAX_COLOR_RESOLUTION);
01907     b = (90341 + 123393 * idx) % (int)(MAX_COLOR_RESOLUTION);
01908 
01909     <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;color = alloc_color(r, g, b, NULL);
01910 
01911     <span class="comment">/* </span>
01912 <span class="comment">     * Set color on layer button</span>
01913 <span class="comment">     */</span>
01914     defstyle = gtk_widget_get_default_style();
01915     newstyle = gtk_style_copy(defstyle);
01916     newstyle-&gt;bg[GTK_STATE_NORMAL] = *(<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;color);
01917     newstyle-&gt;bg[GTK_STATE_ACTIVE] = *(<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;color);
01918     newstyle-&gt;bg[GTK_STATE_PRELIGHT] = *(<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;color);
01919     gtk_widget_set_style(<a class="code" href="gerbv_8c.html#a0">screen</a>.layer_button[idx], newstyle);
01920 
01921     <span class="comment">/* </span>
01922 <span class="comment">     * Tool tips on button is the file name </span>
01923 <span class="comment">     */</span>
01924     gtk_tooltips_set_tip(<a class="code" href="gerbv_8c.html#a0">screen</a>.tooltips, <a class="code" href="gerbv_8c.html#a0">screen</a>.layer_button[idx],
01925                       filename, NULL);
01926 <span class="preprocessor">#ifdef USE_GTK2                         </span>
01927 <span class="preprocessor"></span><span class="comment">//#if 0</span>
01928     <span class="keywordflow">if</span> ((interface.<a class="code" href="struct__InterfaceStruct.html#o2">main_window</a>) &amp;&amp; (!reload) &amp;&amp; gtk_tree_model_get_iter_first(GTK_TREE_MODEL(combo_box_model), &amp;iter)) {                          
01929             <a class="code" href="search__gui_8c.html#a9">update_combo_box_model</a>();
01930         }                                     
01931 <span class="preprocessor">#endif                     </span>
01932 <span class="preprocessor"></span>    <span class="keywordflow">return</span> 0;
01933 } <span class="comment">/* open_image */</span>
01934 
01935 
01936 <span class="keyword">static</span> gint
01937 configure_event (GtkWidget *widget, GdkEventConfigure *event)
01938 {
01939     <span class="keywordflow">return</span> redraw_pixmap(widget, TRUE);
01940 } <span class="comment">/* configure_event */</span>
01941 
01942 
01943 <span class="keyword">static</span> gint
01944 button_press_event (GtkWidget *widget, GdkEventButton *event)
01945 {
01946     gerbv_zoom_data_t data;
01947     gboolean do_zoom = FALSE;
01948 
01949     <span class="keywordflow">switch</span> (event-&gt;button) {
01950     <span class="keywordflow">case</span> 1 :
01951        <span class="keywordflow">if</span>((event-&gt;state &amp; GDK_SHIFT_MASK) == 0) {
01952            <span class="comment">/* Plain panning */</span>
01953            <a class="code" href="gerbv_8c.html#a0">screen</a>.state = MOVE;
01954            <a class="code" href="gerbv_8c.html#a0">screen</a>.last_x = widget-&gt;allocation.height - event-&gt;x;
01955            <a class="code" href="gerbv_8c.html#a0">screen</a>.last_y = widget-&gt;allocation.width  - event-&gt;y;
01956        } <span class="keywordflow">else</span> {
01957            GdkCursor *cursor;
01958 
01959            <a class="code" href="gerbv_8c.html#a0">screen</a>.state = MEASURE;
01960            <a class="code" href="gerbv_8c.html#a0">screen</a>.start_x = event-&gt;x;
01961            <a class="code" href="gerbv_8c.html#a0">screen</a>.start_y = event-&gt;y;
01962 
01963            cursor = gdk_cursor_new(GDK_CROSSHAIR);
01964            gdk_window_set_cursor(gtk_widget_get_parent_window(widget),
01965                               cursor);
01966            gdk_cursor_destroy(cursor);
01967            
01968        }
01969        <span class="keywordflow">break</span>;
01970     <span class="keywordflow">case</span> 2 :
01971        <span class="comment">/* And now, some Veribest-like mouse commands for</span>
01972 <span class="comment">          all us who dislike scroll wheels ;) */</span>
01973        do_zoom = TRUE;
01974        <span class="keywordflow">if</span>((event-&gt;state &amp; GDK_SHIFT_MASK) != 0) {
01975            <span class="comment">/* Middle button + shift == zoom in */</span>
01976            data.z_dir = ZOOM_IN_CMOUSE;
01977        } <span class="keywordflow">else</span> {
01978            <span class="comment">/* Only middle button == zoom out */</span>
01979            data.z_dir = ZOOM_OUT_CMOUSE;
01980        }
01981        <span class="keywordflow">break</span>;
01982     <span class="keywordflow">case</span> 3 :
01983        <span class="comment">/* Zoom outline mode initiated */</span>
01984        <a class="code" href="gerbv_8c.html#a0">screen</a>.state = ZOOM_OUTLINE;
01985        <a class="code" href="gerbv_8c.html#a0">screen</a>.start_x = event-&gt;x;
01986        <a class="code" href="gerbv_8c.html#a0">screen</a>.start_y = event-&gt;y;
01987        <a class="code" href="gerbv_8c.html#a0">screen</a>.centered_outline_zoom = event-&gt;state &amp; GDK_SHIFT_MASK;
01988        <span class="keywordflow">break</span>;
01989     <span class="keywordflow">case</span> 4 : <span class="comment">/* Scroll wheel */</span>
01990        data.z_dir = ZOOM_IN_CMOUSE;
01991        do_zoom = TRUE;
01992        <span class="keywordflow">break</span>;
01993     <span class="keywordflow">case</span> 5 :  <span class="comment">/* Scroll wheel */</span>
01994        data.z_dir = ZOOM_OUT_CMOUSE;
01995        do_zoom = TRUE;
01996        <span class="keywordflow">break</span>;
01997     <span class="keywordflow">default</span>:
01998        <span class="keywordflow">break</span>;
01999     }
02000 
02001     <span class="keywordflow">if</span> (do_zoom) {
02002        data.z_event = event;
02003        zoom(widget, &amp;data);
02004     }
02005 
02006     <span class="keywordflow">return</span> TRUE;
02007 } <span class="comment">/* button_press_event */</span>
02008 
02009 
02010 <span class="preprocessor">#ifdef USE_GTK2</span>
02011 <span class="preprocessor"></span><span class="comment">/* Scroll wheel */</span>
02012 <span class="keyword">static</span> gint
02013 scroll_event(GtkWidget *widget, GdkEventScroll *event)
02014 {
02015     gerbv_zoom_data_t data;
02016 
02017     <span class="keywordflow">switch</span> (event-&gt;direction) {
02018     <span class="keywordflow">case</span> GDK_SCROLL_UP:
02019        data.z_dir = ZOOM_IN_CMOUSE;
02020        <span class="keywordflow">break</span>;
02021     <span class="keywordflow">case</span> GDK_SCROLL_DOWN:
02022        data.z_dir = ZOOM_OUT_CMOUSE;
02023        <span class="keywordflow">break</span>;
02024     <span class="keywordflow">case</span> GDK_SCROLL_LEFT: 
02025        <span class="comment">/* Ignore */</span>
02026        <span class="keywordflow">return</span> TRUE;
02027     <span class="keywordflow">case</span> GDK_SCROLL_RIGHT:
02028        <span class="comment">/* Ignore */</span>
02029        <span class="keywordflow">return</span> TRUE;
02030     <span class="keywordflow">default</span>:
02031        <span class="keywordflow">return</span> TRUE;
02032     }
02033 
02034     <span class="comment">/* XXX Ugly hack */</span>
02035     data.z_event = (GdkEventButton *)event;
02036     zoom(widget, &amp;data);
02037 
02038     <span class="keywordflow">return</span> TRUE;
02039 } <span class="comment">/* scroll_event */</span>
02040 <span class="preprocessor">#endif</span>
02041 <span class="preprocessor"></span>
02042 
02043 <span class="keyword">static</span> gint
02044 button_release_event (GtkWidget *widget, GdkEventButton *event)
02045 {
02046     <span class="keywordflow">if</span> (event-&gt;type == GDK_BUTTON_RELEASE) {
02047        <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.state == MOVE) {
02048            <a class="code" href="gerbv_8c.html#a0">screen</a>.state = NORMAL;
02049            <span class="comment">/* Redraw the image(s) */</span>
02050            <a class="code" href="gerbv_8c.html#a0">screen</a>.off_x = 0;
02051            <a class="code" href="gerbv_8c.html#a0">screen</a>.off_y = 0;
02052            redraw_pixmap(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area, TRUE);
02053        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.state == ZOOM_OUTLINE) {
02054            <a class="code" href="gerbv_8c.html#a0">screen</a>.state = NORMAL;
02055            <a class="code" href="gerbv_8c.html#a35">zoom_outline</a>(widget, event);
02056        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!(event-&gt;state &amp; GDK_SHIFT_MASK)) {
02057            gdk_window_set_cursor(gtk_widget_get_parent_window(widget),
02058                               GERBV_DEF_CURSOR);
02059        }
02060        <a class="code" href="gerbv_8c.html#a0">screen</a>.last_x = <a class="code" href="gerbv_8c.html#a0">screen</a>.last_y = 0;
02061        <a class="code" href="gerbv_8c.html#a0">screen</a>.state = NORMAL;
02062     }
02063 
02064     <span class="keywordflow">return</span> TRUE;
02065 } <span class="comment">/* button_release_event */</span>
02066 
02067 
02068 <span class="keyword">static</span> gint
02069 key_press_event (GtkWidget *widget, GdkEventKey *event)
02070 {
02071     GdkCursor *cursor;
02072     gerbv_zoom_data_t z_data;
02073 
02074     <span class="keywordflow">switch</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.state) {
02075     <span class="keywordflow">case</span> NORMAL:
02076        <span class="keywordflow">switch</span>(event-&gt;keyval) {
02077        <span class="keywordflow">case</span> GDK_Shift_L:
02078        <span class="keywordflow">case</span> GDK_Shift_R:
02079            cursor = gdk_cursor_new(GDK_CROSSHAIR);
02080            gdk_window_set_cursor(gtk_widget_get_parent_window(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area),
02081                               cursor);
02082            gdk_cursor_destroy(cursor);
02083            <span class="keywordflow">break</span>;
02084        <span class="keywordflow">case</span> GDK_Alt_L:
02085        <span class="keywordflow">case</span> GDK_Alt_R: 
02086            <a class="code" href="gerbv_8c.html#a0">screen</a>.state = ALT_PRESSED;
02087            <a class="code" href="gerbv_8c.html#a0">screen</a>.selected_layer = -1;
02088            <span class="keywordflow">break</span>;
02089        <span class="keywordflow">case</span> GDK_f:
02090        <span class="keywordflow">case</span> GDK_F:
02091            autoscale();
02092            redraw_pixmap(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area, TRUE);
02093            <span class="keywordflow">break</span>;
02094        <span class="keywordflow">case</span> GDK_z:
02095            z_data.z_dir = ZOOM_IN;
02096            zoom(widget, &amp;z_data);
02097            <span class="keywordflow">break</span>;
02098        <span class="keywordflow">case</span> GDK_Z:
02099            z_data.z_dir = ZOOM_OUT;
02100            zoom(widget, &amp;z_data);
02101            <span class="keywordflow">break</span>;
02102        <span class="keywordflow">default</span>:
02103            <span class="keywordflow">break</span>;
02104        }
02105        <span class="keywordflow">break</span>;
02106     <span class="keywordflow">case</span> ALT_PRESSED:
02107        <span class="keywordflow">if</span> ((event-&gt;keyval &gt;= GDK_KP_0) &amp;&amp;
02108            (event-&gt;keyval &lt;= GDK_KP_9)) {
02109            <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.selected_layer == -1) 
02110               <a class="code" href="gerbv_8c.html#a0">screen</a>.selected_layer = event-&gt;keyval - GDK_KP_0;
02111            <span class="keywordflow">else</span>
02112               <a class="code" href="gerbv_8c.html#a0">screen</a>.selected_layer = 10 * <a class="code" href="gerbv_8c.html#a0">screen</a>.selected_layer + 
02113                   (event-&gt;keyval - GDK_KP_0);
02114        }
02115        <span class="keywordflow">break</span>;
02116     <span class="keywordflow">default</span>:
02117        <span class="keywordflow">break</span>;
02118     }
02119            
02120     <span class="comment">/* Escape may be used to abort outline zoom and just plain repaint */</span>
02121     <span class="keywordflow">if</span> (event-&gt;keyval == GDK_Escape) {
02122        GdkRectangle update_rect;
02123 
02124        <a class="code" href="gerbv_8c.html#a0">screen</a>.state = NORMAL;
02125 
02126        <a class="code" href="gerbv_8c.html#a0">screen</a>.statusbar.diststr[0] = <span class="charliteral">'\0'</span>;
02127        <a class="code" href="gerbv_8c.html#a38">update_statusbar</a>(&amp;screen);
02128 
02129        update_rect.x = 0, update_rect.y = 0;
02130        update_rect.width =  widget-&gt;allocation.width;
02131        update_rect.height = widget-&gt;allocation.height;
02132 
02133        <span class="comment">/*</span>
02134 <span class="comment">        * Calls expose_event</span>
02135 <span class="comment">        */</span>
02136        gtk_widget_draw(widget, &amp;update_rect);
02137     }
02138 
02139     <span class="keywordflow">return</span> TRUE;
02140 } <span class="comment">/* key_press_event */</span>
02141 
02142 
02143 <span class="preprocessor">#define TOGGLE_BUTTON(button) gtk_toggle_button_set_active( \</span>
02144 <span class="preprocessor">                                      GTK_TOGGLE_BUTTON(button),\</span>
02145 <span class="preprocessor">                             !gtk_toggle_button_get_active( \</span>
02146 <span class="preprocessor">                                      GTK_TOGGLE_BUTTON(button)));</span>
02147 <span class="preprocessor"></span>
02148 <span class="keyword">static</span> gint
02149 key_release_event (GtkWidget *widget, GdkEventKey *event)
02150 {
02151     <span class="keywordflow">switch</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.state) {
02152     <span class="keywordflow">case</span> NORMAL:
02153        <span class="keywordflow">if</span>((event-&gt;keyval == GDK_Shift_L) ||
02154           (event-&gt;keyval == GDK_Shift_R)) {
02155            gdk_window_set_cursor(gtk_widget_get_parent_window(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area),
02156                               GERBV_DEF_CURSOR);
02157        }
02158        <span class="keywordflow">break</span>;
02159     <span class="keywordflow">case</span> ALT_PRESSED:
02160        <span class="keywordflow">if</span> ((event-&gt;keyval == GDK_Alt_L) ||
02161             (event-&gt;keyval == GDK_Alt_R)) {
02162            <span class="keywordflow">if</span> ((<a class="code" href="gerbv_8c.html#a0">screen</a>.selected_layer != -1) &amp;&amp;
02163               (<a class="code" href="gerbv_8c.html#a0">screen</a>.selected_layer &lt; MAX_FILES)){
02164               TOGGLE_BUTTON(<a class="code" href="gerbv_8c.html#a0">screen</a>.layer_button[<a class="code" href="gerbv_8c.html#a0">screen</a>.selected_layer]);
02165            }
02166            <a class="code" href="gerbv_8c.html#a0">screen</a>.state = NORMAL;
02167        }
02168     <span class="keywordflow">default</span>:
02169        <span class="keywordflow">break</span>;
02170     }
02171 
02172     <span class="keywordflow">return</span> TRUE;
02173 } <span class="comment">/* key_release_event */</span>
02174 
02175 
02176 <span class="keyword">static</span> gint
02177 motion_notify_event (GtkWidget *widget, GdkEventMotion *event)
02178 {
02179     <span class="keywordtype">int</span> x, y;
02180     GdkModifierType state;
02181     GdkRectangle update_rect;
02182     
02183     <span class="keywordflow">if</span> (event-&gt;is_hint)
02184        gdk_window_get_pointer (event-&gt;window, &amp;x, &amp;y, &amp;state);
02185     <span class="keywordflow">else</span> {
02186        x = event-&gt;x;
02187        y = event-&gt;y;
02188        state = event-&gt;state;
02189     }
02190     
02191     <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.pixmap != NULL) {
02192        <span class="keywordtype">double</span> X, Y;
02193 
02194        X = <a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.x1 + (x+<a class="code" href="gerbv_8c.html#a0">screen</a>.trans_x)/(double)<a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale;
02195        Y = (<a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.y2 - (y+<a class="code" href="gerbv_8c.html#a0">screen</a>.trans_y)/(double)<a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale);
02196        <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.unit == GERBV_MILS) {
02197            snprintf(<a class="code" href="gerbv_8c.html#a0">screen</a>.statusbar.coordstr, MAX_COORDLEN,
02198                    <span class="stringliteral">"X,Y (%7.1f, %7.1f)mils"</span>,
02199                    COORD2MILS(X), COORD2MILS(Y));
02200        } <span class="keywordflow">else</span> <span class="comment">/* unit is GERBV_MMS */</span> {
02201            snprintf(<a class="code" href="gerbv_8c.html#a0">screen</a>.statusbar.coordstr, MAX_COORDLEN,
02202                    <span class="stringliteral">"X,Y (%7.2f, %7.2f)mm"</span>,
02203                    COORD2MMS(X), COORD2MMS(Y));
02204        }
02205        <a class="code" href="gerbv_8c.html#a38">update_statusbar</a>(&amp;screen);
02206 
02207        <span class="keywordflow">switch</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.state) {
02208        <span class="keywordflow">case</span> MOVE: {
02209 
02210            x = widget-&gt;allocation.height - x;
02211            y = widget-&gt;allocation.width - y;
02212 
02213            <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.last_x != 0 || <a class="code" href="gerbv_8c.html#a0">screen</a>.last_y != 0) {
02214               <a class="code" href="gerbv_8c.html#a0">screen</a>.trans_x = <a class="code" href="gerbv_8c.html#a0">screen</a>.trans_x + x - <a class="code" href="gerbv_8c.html#a0">screen</a>.last_x;
02215               <a class="code" href="gerbv_8c.html#a0">screen</a>.trans_y = <a class="code" href="gerbv_8c.html#a0">screen</a>.trans_y + y - <a class="code" href="gerbv_8c.html#a0">screen</a>.last_y;
02216 
02217               <a class="code" href="gerbv_8c.html#a0">screen</a>.clip_bbox.x1 = -<a class="code" href="gerbv_8c.html#a0">screen</a>.trans_x/(double)<a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale;
02218               <a class="code" href="gerbv_8c.html#a0">screen</a>.clip_bbox.y1 = -<a class="code" href="gerbv_8c.html#a0">screen</a>.trans_y/(double)<a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale;
02219 
02220               <span class="comment">/* Move pixmap to get a snappier feel of movement */</span>
02221               <a class="code" href="gerbv_8c.html#a0">screen</a>.off_x += x - <a class="code" href="gerbv_8c.html#a0">screen</a>.last_x;
02222               <a class="code" href="gerbv_8c.html#a0">screen</a>.off_y += y - <a class="code" href="gerbv_8c.html#a0">screen</a>.last_y;
02223            }
02224            <a class="code" href="gerbv_8c.html#a0">screen</a>.last_x = x;
02225            <a class="code" href="gerbv_8c.html#a0">screen</a>.last_y = y;
02226 
02227            update_rect.x = 0, update_rect.y = 0;
02228            update_rect.width  = widget-&gt;allocation.width;
02229            update_rect.height = widget-&gt;allocation.height;
02230 
02231            <span class="comment">/*</span>
02232 <span class="comment">            * Calls expose_event</span>
02233 <span class="comment">            */</span>
02234            gtk_widget_draw(widget, &amp;update_rect);
02235 
02236            <span class="keywordflow">break</span>;
02237        }
02238        <span class="keywordflow">case</span> ZOOM_OUTLINE: {
02239            <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.last_x || <a class="code" href="gerbv_8c.html#a0">screen</a>.last_y)
02240               draw_zoom_outline(<a class="code" href="gerbv_8c.html#a0">screen</a>.centered_outline_zoom);
02241 
02242            <a class="code" href="gerbv_8c.html#a0">screen</a>.last_x = x;
02243            <a class="code" href="gerbv_8c.html#a0">screen</a>.last_y = y;
02244 
02245            draw_zoom_outline(<a class="code" href="gerbv_8c.html#a0">screen</a>.centered_outline_zoom);
02246            <span class="keywordflow">break</span>;
02247        }
02248        <span class="keywordflow">case</span> MEASURE: {
02249            <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.last_x || <a class="code" href="gerbv_8c.html#a0">screen</a>.last_y)
02250               <a class="code" href="gerbv_8c.html#a17">draw_measure_distance</a>();
02251 
02252            <a class="code" href="gerbv_8c.html#a0">screen</a>.last_x = x;
02253            <a class="code" href="gerbv_8c.html#a0">screen</a>.last_y = y;
02254 
02255            <a class="code" href="gerbv_8c.html#a17">draw_measure_distance</a>();
02256            <span class="keywordflow">break</span>;
02257        }
02258        <span class="keywordflow">default</span>:
02259            <span class="keywordflow">break</span>;
02260        }
02261     }
02262     
02263     <span class="keywordflow">return</span> TRUE;
02264 } <span class="comment">/* motion_notify_event */</span>
02265 
02266 
02267 <span class="comment">/* Redraw the screen from the backing pixmap */</span>
02268 <span class="keyword">static</span> gint
02269 expose_event (GtkWidget *widget, GdkEventExpose *event)
02270 {
02271 
02272     GdkPixmap *new_pixmap;
02273     GdkGC *gc = gdk_gc_new(widget-&gt;window);
02274 
02275     <span class="comment">/*</span>
02276 <span class="comment">     * Create a pixmap with default background</span>
02277 <span class="comment">     */</span>
02278     new_pixmap = gdk_pixmap_new(widget-&gt;window,
02279                             widget-&gt;allocation.width,
02280                             widget-&gt;allocation.height,
02281                             -1);
02282 
02283     gdk_gc_set_foreground(gc, <a class="code" href="gerbv_8c.html#a0">screen</a>.background);
02284 
02285     gdk_draw_rectangle(new_pixmap, gc, TRUE, 
02286                      event-&gt;area.x, event-&gt;area.y,
02287                      event-&gt;area.width, event-&gt;area.height);
02288     
02289     <span class="comment">/*</span>
02290 <span class="comment">     * Copy gerber pixmap onto background if we have one to copy.</span>
02291 <span class="comment">     * Do translation at the same time.</span>
02292 <span class="comment">     */</span>
02293     <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.pixmap != NULL) {
02294        gdk_draw_pixmap(new_pixmap,
02295                      widget-&gt;style-&gt;fg_gc[GTK_WIDGET_STATE (widget)],
02296                      <a class="code" href="gerbv_8c.html#a0">screen</a>.pixmap, 
02297                      event-&gt;area.x + <a class="code" href="gerbv_8c.html#a0">screen</a>.off_x, 
02298                      event-&gt;area.y + <a class="code" href="gerbv_8c.html#a0">screen</a>.off_y, 
02299                      event-&gt;area.x, event-&gt;area.y,
02300                      event-&gt;area.width, event-&gt;area.height);
02301     }
02302 
02303     <span class="comment">/*</span>
02304 <span class="comment">     * Draw the whole thing onto screen</span>
02305 <span class="comment">     */</span>
02306     gdk_draw_pixmap(widget-&gt;window,
02307                   widget-&gt;style-&gt;fg_gc[GTK_WIDGET_STATE (widget)],
02308                   new_pixmap,
02309                   event-&gt;area.x, event-&gt;area.y,
02310                   event-&gt;area.x, event-&gt;area.y,
02311                   event-&gt;area.width, event-&gt;area.height);
02312 <span class="preprocessor">#ifdef GERBV_DEBUG_OUTLINE</span>
02313 <span class="preprocessor"></span>    {
02314            <span class="keywordtype">double</span> dx, dy;
02315 
02316            dx = <a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.x2-<a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.x1;
02317            dy = <a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.y2-<a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.y1;
02318            gdk_gc_set_foreground(gc, <a class="code" href="gerbv_8c.html#a0">screen</a>.dist_measure_color);
02319            gdk_draw_rectangle(widget-&gt;window, gc, FALSE, 
02320                             (<a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.x1-1.1)*<a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale - <a class="code" href="gerbv_8c.html#a0">screen</a>.trans_x,
02321                             ((<a class="code" href="gerbv_8c.html#a0">screen</a>.gerber_bbox.y1-0.6)*<a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale - <a class="code" href="gerbv_8c.html#a0">screen</a>.trans_y),
02322                             dx*<a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale,
02323                             dy*<a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale);
02324     }
02325 <span class="preprocessor">#endif </span><span class="comment">/* DEBUG_GERBV_OUTLINE */</span>
02326 
02327     gdk_pixmap_unref(new_pixmap);
02328     gdk_gc_unref(gc);
02329 
02330     <span class="comment">/*</span>
02331 <span class="comment">     * Draw Zooming outline if we are in that mode</span>
02332 <span class="comment">     */</span>
02333     <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.state == ZOOM_OUTLINE) {
02334        draw_zoom_outline(<a class="code" href="gerbv_8c.html#a0">screen</a>.centered_outline_zoom);
02335     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.state == MEASURE) {
02336        <a class="code" href="gerbv_8c.html#a17">draw_measure_distance</a>();
02337     }
02338     <span class="comment">/*</span>
02339 <span class="comment">     * Raise popup windows if they happen to disappear</span>
02340 <span class="comment">     */</span>
02341     <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.win.load_file &amp;&amp; <a class="code" href="gerbv_8c.html#a0">screen</a>.win.load_file-&gt;window)
02342        gdk_window_raise(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.load_file-&gt;window);
02343     <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.win.color_selection &amp;&amp; <a class="code" href="gerbv_8c.html#a0">screen</a>.win.color_selection-&gt;window)
02344        gdk_window_raise(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.color_selection-&gt;window);
02345     <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.win.export_png &amp;&amp; <a class="code" href="gerbv_8c.html#a0">screen</a>.win.export_png-&gt;window)
02346        gdk_window_raise(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.export_png-&gt;window);
02347     <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.win.scale &amp;&amp; <a class="code" href="gerbv_8c.html#a0">screen</a>.win.scale-&gt;window)
02348        gdk_window_raise(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.scale-&gt;window);
02349     <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.win.log &amp;&amp; <a class="code" href="gerbv_8c.html#a0">screen</a>.win.log-&gt;window)
02350        gdk_window_raise(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.log-&gt;window);
02351 
02352     <span class="keywordflow">return</span> FALSE;
02353 } <span class="comment">/* expose_event */</span>
02354 
02355 
02356 <span class="keyword">static</span> <span class="keywordtype">void</span>
02357 draw_zoom_outline(gboolean centered)
02358 {
02359     GdkGC *gc;
02360     GdkGCValues values;
02361     GdkGCValuesMask values_mask;
02362     gint x1, y1, x2, y2, dx, dy;
02363 
02364     memset(&amp;values, 0, <span class="keyword">sizeof</span>(values));
02365     values.function = GDK_XOR;
02366     values.foreground = *<a class="code" href="gerbv_8c.html#a0">screen</a>.zoom_outline_color;
02367     values_mask = GDK_GC_FUNCTION | GDK_GC_FOREGROUND;
02368     gc = gdk_gc_new_with_values(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area-&gt;window, &amp;values, values_mask);
02369 
02370     x1 = MIN(<a class="code" href="gerbv_8c.html#a0">screen</a>.start_x, <a class="code" href="gerbv_8c.html#a0">screen</a>.last_x);
02371     y1 = MIN(<a class="code" href="gerbv_8c.html#a0">screen</a>.start_y, <a class="code" href="gerbv_8c.html#a0">screen</a>.last_y);
02372     x2 = MAX(<a class="code" href="gerbv_8c.html#a0">screen</a>.start_x, <a class="code" href="gerbv_8c.html#a0">screen</a>.last_x);
02373     y2 = MAX(<a class="code" href="gerbv_8c.html#a0">screen</a>.start_y, <a class="code" href="gerbv_8c.html#a0">screen</a>.last_y);
02374     dx = x2-x1;
02375     dy = y2-y1;
02376 
02377     <span class="keywordflow">if</span> (centered) {
02378        <span class="comment">/* Centered outline mode */</span>
02379        x1 = <a class="code" href="gerbv_8c.html#a0">screen</a>.start_x - dx;
02380        y1 = <a class="code" href="gerbv_8c.html#a0">screen</a>.start_y - dy;
02381        dx *= 2;
02382        dy *= 2;
02383        x2 = x1+dx;
02384        y2 = y1+dy;
02385     }
02386 
02387     gdk_draw_rectangle(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area-&gt;window, gc, FALSE, x1, y1, dx, dy);
02388     gdk_gc_unref(gc);
02389 
02390     <span class="comment">/* Draw actual zoom area in dashed lines */</span>
02391     memset(&amp;values, 0, <span class="keyword">sizeof</span>(values));
02392     values.function = GDK_XOR;
02393     values.foreground = *<a class="code" href="gerbv_8c.html#a0">screen</a>.dist_measure_color;
02394     values.line_style = GDK_LINE_ON_OFF_DASH;
02395     values_mask = GDK_GC_FUNCTION | GDK_GC_FOREGROUND | GDK_GC_LINE_STYLE;
02396     gc = gdk_gc_new_with_values(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area-&gt;window, &amp;values,
02397                             values_mask);
02398 
02399     <span class="keywordflow">if</span> ((dy == 0) || ((double)dx/dy &gt; (double)<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area-&gt;allocation.width/<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area-&gt;allocation.height)) {
02400            dy = dx * (double)<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area-&gt;allocation.height/<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area-&gt;allocation.width;
02401     } <span class="keywordflow">else</span> {
02402            dx = dy * (double)<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area-&gt;allocation.width/<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area-&gt;allocation.height;
02403     }
02404 
02405     gdk_draw_rectangle(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area-&gt;window, gc, FALSE, (x1+x2-dx)/2, (y1+y2-dy)/2, dx, dy);
02406 
02407     gdk_gc_unref(gc);
02408 } <span class="comment">/* draw_zoom_outline */</span>
02409 
02410 
02414 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02415"></a><a class="code" href="gerbv_8c.html#a17">02415</a> <a class="code" href="gerbv_8c.html#a17">draw_measure_distance</a>(<span class="keywordtype">void</span>)
02416 {
02417     GdkGC *gc;
02418     GdkGCValues values;
02419     GdkGCValuesMask values_mask;
02420     gint x1, y1, x2, y2;
02421     <span class="keywordtype">double</span> delta, dx, dy;
02422     GdkFont *font;
02423 
02424     <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.state != MEASURE)
02425        <span class="keywordflow">return</span>;
02426 <span class="preprocessor">#if !defined (__MINGW32__) //taken out because of different drawing behaviour under win32 resulting in a smear</span>
02427 <span class="preprocessor"></span>    memset(&amp;values, 0, <span class="keyword">sizeof</span>(values));
02428     values.function = GDK_XOR;
02429     values.foreground = *<a class="code" href="gerbv_8c.html#a0">screen</a>.dist_measure_color;
02430     values_mask = GDK_GC_FUNCTION | GDK_GC_FOREGROUND;
02431     gc = gdk_gc_new_with_values(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area-&gt;window, &amp;values,
02432                             values_mask);
02433     font = gdk_font_load(setup.dist_fontname);
02434 <span class="preprocessor">#endif</span>
02435 <span class="preprocessor"></span>    x1 = MIN(<a class="code" href="gerbv_8c.html#a0">screen</a>.start_x, <a class="code" href="gerbv_8c.html#a0">screen</a>.last_x);
02436     y1 = MIN(<a class="code" href="gerbv_8c.html#a0">screen</a>.start_y, <a class="code" href="gerbv_8c.html#a0">screen</a>.last_y);
02437     x2 = MAX(<a class="code" href="gerbv_8c.html#a0">screen</a>.start_x, <a class="code" href="gerbv_8c.html#a0">screen</a>.last_x);
02438     y2 = MAX(<a class="code" href="gerbv_8c.html#a0">screen</a>.start_y, <a class="code" href="gerbv_8c.html#a0">screen</a>.last_y);
02439 
02440        dx = (x2 - x1)/(double) <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale;
02441        dy = (y2 - y1)/(double) <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale;
02442        delta = sqrt(dx*dx + dy*dy); <span class="comment">/* Pythagoras */</span>
02443     
02444 <span class="preprocessor">#if !defined (__MINGW32__)</span>
02445 <span class="preprocessor"></span>    gdk_draw_line(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area-&gt;window, gc, <a class="code" href="gerbv_8c.html#a0">screen</a>.start_x,
02446                 <a class="code" href="gerbv_8c.html#a0">screen</a>.start_y, <a class="code" href="gerbv_8c.html#a0">screen</a>.last_x, <a class="code" href="gerbv_8c.html#a0">screen</a>.last_y);
02447     <span class="keywordflow">if</span> (font == NULL) {
02448        GERB_MESSAGE(<span class="stringliteral">"Failed to load font '%s'\n"</span>, setup.dist_fontname);
02449     } <span class="keywordflow">else</span> {
02450        gchar string[65];
02451        gint lbearing, rbearing, width, ascent, descent;
02452        gint linefeed;       <span class="comment">/* Pseudonym for inter line gap */</span>
02453 
02454        snprintf(string, <span class="keyword">sizeof</span>(string),
02455                <span class="stringliteral">"[dist %7.1f, dX %7.1f, dY %7.1f] mils"</span>,
02456                COORD2MILS(delta), COORD2MILS(dx), COORD2MILS(dy));
02457 
02458        gdk_string_extents(font, string, &amp;lbearing, &amp;rbearing, &amp;width,
02459                         &amp;ascent, &amp;descent);
02460        gdk_draw_string(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area-&gt;window, font, gc,
02461                      (x1+x2)/2-width/2, (y1+y2)/2, string);
02462 
02463        linefeed = ascent+descent;
02464        linefeed *= (double)1.2;
02465 
02466        snprintf(string, <span class="keyword">sizeof</span>(string),
02467                <span class="stringliteral">"[dist %7.2f, dX %7.2f, dY %7.2f] mm"</span>,
02468                COORD2MMS(delta), COORD2MMS(dx), COORD2MMS(dy));
02469 
02470        gdk_string_extents(font, string, &amp;lbearing, &amp;rbearing, &amp;width,
02471                         &amp;ascent, &amp;descent);
02472        gdk_draw_string(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area-&gt;window, font, gc,
02473                      (x1+x2)/2 - width/2, (y1+y2)/2 + linefeed, string);
02474 
02475        gdk_font_unref(font);
02476 <span class="preprocessor">#endif</span>
02477 <span class="preprocessor"></span>       <span class="comment">/*</span>
02478 <span class="comment">        * Update statusbar</span>
02479 <span class="comment">        */</span>
02480        <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.unit == GERBV_MILS) {
02481            snprintf(<a class="code" href="gerbv_8c.html#a0">screen</a>.statusbar.diststr, MAX_DISTLEN,
02482                    <span class="stringliteral">" dist,dX,dY (%7.1f, %7.1f, %7.1f)mils"</span>,
02483                    COORD2MILS(delta), COORD2MILS(dx), COORD2MILS(dy));
02484        } <span class="keywordflow">else</span> <span class="comment">/* unit is GERBV_MMS */</span> {
02485            snprintf(<a class="code" href="gerbv_8c.html#a0">screen</a>.statusbar.diststr, MAX_DISTLEN,
02486                    <span class="stringliteral">" dist,dX,dY (%7.2f, %7.2f, %7.2f)mm"</span>,
02487                    COORD2MMS(delta), COORD2MMS(dx), COORD2MMS(dy));
02488        }
02489        <a class="code" href="gerbv_8c.html#a38">update_statusbar</a>(&amp;<a class="code" href="gerbv_8c.html#a0">screen</a>);
02490 
02491     }
02492 <span class="preprocessor">#if !defined (__MINGW32__)</span>
02493 <span class="preprocessor"></span>    gdk_gc_unref(gc);
02494 <span class="preprocessor">#endif     </span>
02495 <span class="preprocessor"></span>} <span class="comment">/* draw_measure_distance */</span>
02496 
02503  <span class="keywordtype">void</span> 
<a name="l02504"></a><a class="code" href="gerbv_8c.html#a38">02504</a> <a class="code" href="gerbv_8c.html#a38">update_statusbar</a>(gerbv_screen_t *scr)
02505 {
02506     <span class="keywordtype">char</span> str[MAX_STATUSMSGLEN+1];
02507 
02508     snprintf(str, MAX_STATUSMSGLEN, <span class="stringliteral">" %-*s|%-*s|%.*s"</span>,
02509             MAX_COORDLEN-1, scr-&gt;statusbar.coordstr,
02510             MAX_DISTLEN-1, scr-&gt;statusbar.diststr,
02511             MAX_ERRMSGLEN-1, scr-&gt;statusbar.msgstr);
02512     <span class="keywordflow">if</span> (scr-&gt;statusbar.msg != NULL) {
02513            gtk_label_set_text(GTK_LABEL(scr-&gt;statusbar.msg), str);
02514     }
02515 } <span class="comment">/* update_statusbar */</span>
02516 
02517 
02518 <span class="keyword">static</span> <span class="keywordtype">void</span>
02519 menu_ask_zoom (GtkWidget * widget, gpointer data)
02520 {
02521     <a class="code" href="gerbv_8c.html#a0">screen</a>.win.scale = create_ZoomFactorWindow();
02522     gtk_widget_show(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.scale);
02523     gtk_grab_add(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.scale);
02524 } <span class="comment">/* menu_ask_zoom */</span>
02525     
02526 
02527 <span class="keyword">static</span> GtkWidget *
02528 create_ZoomFactorWindow(<span class="keywordtype">void</span>)
02529 {
02530     GtkWidget *ZoomFactorWindow;
02531     GtkWidget *table2;
02532     GtkObject *zoom_spinbutton1_adj;
02533     GtkWidget *zoom_spinbutton1;
02534     GtkWidget *zoom_cancel_button;
02535     GtkWidget *zoom_ok_button;
02536     GtkWidget *zoomwindowlabel;
02537     
02538     ZoomFactorWindow = gtk_window_new (GTK_WINDOW_TOPLEVEL);
02539     gtk_object_set_data (GTK_OBJECT (ZoomFactorWindow), <span class="stringliteral">"ZoomFactorWindow"</span>,
02540                       ZoomFactorWindow);
02541     gtk_window_set_title (GTK_WINDOW (ZoomFactorWindow), <span class="stringliteral">"Set Scale"</span>);
02542     <span class="comment">/* XXX Hardcoded window size values */</span>
02543     gtk_window_set_default_size(GTK_WINDOW(ZoomFactorWindow), 180, 50);
02544     
02545     table2 = gtk_table_new (2, 2, FALSE);
02546     gtk_widget_ref (table2);
02547     gtk_object_set_data_full (GTK_OBJECT (ZoomFactorWindow), <span class="stringliteral">"table2"</span>, table2,
02548                            (GtkDestroyNotify) gtk_widget_unref);
02549     gtk_widget_show (table2);
02550     gtk_container_add (GTK_CONTAINER (ZoomFactorWindow), table2);
02551     
02552     zoom_spinbutton1_adj = gtk_adjustment_new (1, 1, 65535, 1, 10, 10);
02553     zoom_spinbutton1 =
02554        gtk_spin_button_new (GTK_ADJUSTMENT (zoom_spinbutton1_adj), 1, 0);
02555     gtk_widget_ref (zoom_spinbutton1);
02556     gtk_object_set_data_full (GTK_OBJECT (ZoomFactorWindow),
02557                            <span class="stringliteral">"zoom_spinbutton1"</span>, zoom_spinbutton1,
02558                            (GtkDestroyNotify) gtk_widget_unref);
02559     gtk_widget_show (zoom_spinbutton1);
02560     gtk_table_attach (GTK_TABLE (table2), zoom_spinbutton1, 1, 2, 0, 1,
02561                     (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
02562                     (GtkAttachOptions) (0), 0, 0);
02563 
02564     zoom_cancel_button = gtk_button_new_with_label (<span class="stringliteral">"Cancel"</span>);
02565     gtk_widget_ref (zoom_cancel_button);
02566     gtk_object_set_data_full (GTK_OBJECT (ZoomFactorWindow),
02567                            <span class="stringliteral">"zoom_cancel_button"</span>, zoom_cancel_button,
02568                            (GtkDestroyNotify) gtk_widget_unref);
02569     gtk_widget_show (zoom_cancel_button);
02570     gtk_table_attach (GTK_TABLE (table2), zoom_cancel_button, 1, 2, 1, 2,
02571                     (GtkAttachOptions) (GTK_FILL),
02572                     (GtkAttachOptions) (0), 0, 0);
02573 
02574     zoom_ok_button = gtk_button_new_with_label (<span class="stringliteral">"OK"</span>);
02575     gtk_widget_ref (zoom_ok_button);
02576     gtk_object_set_data_full (GTK_OBJECT (ZoomFactorWindow), <span class="stringliteral">"zoom_ok_button"</span>,
02577                            zoom_ok_button,
02578                            (GtkDestroyNotify) gtk_widget_unref);
02579     gtk_widget_show (zoom_ok_button);
02580     gtk_table_attach (GTK_TABLE (table2), zoom_ok_button, 0, 1, 1, 2,
02581                     (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
02582                     (GtkAttachOptions) (0), 0, 0);
02583 
02584     zoomwindowlabel = gtk_label_new (<span class="stringliteral">"Zoom factor:"</span>);
02585     gtk_widget_ref (zoomwindowlabel);
02586     gtk_object_set_data_full (GTK_OBJECT (ZoomFactorWindow),
02587                            <span class="stringliteral">"zoomwindowlabel"</span>, zoomwindowlabel,
02588                            (GtkDestroyNotify) gtk_widget_unref);
02589     gtk_widget_show (zoomwindowlabel);
02590     gtk_table_attach (GTK_TABLE (table2), zoomwindowlabel, 0, 1, 0, 1,
02591                     (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
02592                     (GtkAttachOptions) (0), 0, 0);
02593     gtk_misc_set_alignment (GTK_MISC (zoomwindowlabel), 0, 0.5);
02594 
02595     gtk_signal_connect(GTK_OBJECT(ZoomFactorWindow), <span class="stringliteral">"destroy"</span>,
02596                      GTK_SIGNAL_FUNC(zoom_cancel_button_clicked),
02597                      NULL);
02598     gtk_signal_connect (GTK_OBJECT (zoom_spinbutton1), <span class="stringliteral">"realize"</span>,
02599                      GTK_SIGNAL_FUNC (zoom_spinbutton1_realize), NULL);
02600     gtk_signal_connect (GTK_OBJECT (zoom_cancel_button), <span class="stringliteral">"clicked"</span>,
02601                      GTK_SIGNAL_FUNC (zoom_cancel_button_clicked),
02602                      (gpointer) ZoomFactorWindow);
02603     gtk_signal_connect (GTK_OBJECT (zoom_ok_button), <span class="stringliteral">"clicked"</span>,
02604                      GTK_SIGNAL_FUNC (zoom_ok_button_clicked),
02605                      (gpointer) ZoomFactorWindow);
02606 
02607     <span class="keywordflow">return</span> ZoomFactorWindow;
02608 } <span class="comment">/* create_ZoomFactorWindow */</span>
02609 
02610 
02611 <span class="keywordtype">void</span>
02612 zoom_spinbutton1_realize(GtkWidget * widget, gpointer user_data)
02613 {
02614     gtk_spin_button_set_value ((GtkSpinButton *) widget,
02615                             (gfloat) <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;scale);
02616 } <span class="comment">/* zoom_spinbutton1_realize */</span>
02617 
02618 
02619 <span class="keyword">static</span> <span class="keywordtype">void</span>
02620 zoom_ok_button_clicked(GtkButton * button, gpointer user_data)
02621 {
02622     GtkSpinButton *ZoomSpin;
02623     <span class="keywordtype">int</span> newscale;
02624     gerbv_zoom_data_t z_data;
02625 
02626     ZoomSpin = (GtkSpinButton *) lookup_widget ((GtkWidget *) button,
02627                                           <span class="stringliteral">"zoom_spinbutton1"</span>);
02628     newscale = gtk_spin_button_get_value_as_int (ZoomSpin);
02629     z_data.z_dir = ZOOM_SET;
02630     z_data.z_event = NULL;
02631     z_data.scale = newscale;
02632     zoom (<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area, &amp;z_data);
02633 
02634     gtk_grab_remove(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.scale);
02635     gtk_widget_destroy (<a class="code" href="gerbv_8c.html#a0">screen</a>.win.scale);
02636     <a class="code" href="gerbv_8c.html#a0">screen</a>.win.scale = NULL;
02637 } <span class="comment">/* zoom_ok_button_clicked */</span>
02638 
02639 
02640 <span class="keyword">static</span> <span class="keywordtype">void</span>
02641 zoom_cancel_button_clicked(GtkButton * button, gpointer user_data)
02642 {
02643     gtk_grab_remove(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.scale);
02644     gtk_widget_destroy(<a class="code" href="gerbv_8c.html#a0">screen</a>.win.scale);
02645     <a class="code" href="gerbv_8c.html#a0">screen</a>.win.scale = NULL;
02646 } <span class="comment">/* zoom_cancel_button_clicked */</span>
02647 
02648 
02649 GtkWidget *
02650 lookup_widget (GtkWidget * widget, <span class="keyword">const</span> gchar * widget_name)
02651 {
02652     GtkWidget *parent, *found_widget;
02653 
02654     <span class="keywordflow">for</span> (;;) {
02655        <span class="keywordflow">if</span> (GTK_IS_MENU (widget))
02656            parent = gtk_menu_get_attach_widget (GTK_MENU (widget));
02657        <span class="keywordflow">else</span>
02658            parent = widget-&gt;parent;
02659        <span class="keywordflow">if</span> (parent == NULL)
02660            <span class="keywordflow">break</span>;
02661        widget = parent;
02662     }
02663 
02664     found_widget = (GtkWidget *) gtk_object_get_data (GTK_OBJECT (widget),
02665                                                 widget_name);
02666     <span class="keywordflow">if</span> (!found_widget)
02667        g_warning (<span class="stringliteral">"Widget not found: %s"</span>, widget_name);
02668     <span class="keywordflow">return</span> found_widget;
02669 } <span class="comment">/* lookup_widget */</span>
02670 
02671 
02672 <span class="keywordtype">void</span>
02673 rename_main_window(<span class="keywordtype">char</span> *filename, GtkWidget *main_win)
02674 {
02675     <span class="keywordtype">char</span> *win_title;
02676     <span class="keyword">static</span> GtkWidget *win=NULL;
02677     size_t len;
02678 
02679     <span class="keywordflow">if</span>( main_win != NULL )
02680        win = main_win;
02681 
02682     assert(win != NULL);
02683 
02684     len = strlen(WIN_TITLE) + strlen(VERSION) + 2 + strlen(filename) + 1;
02685     win_title = (<span class="keywordtype">char</span> *)malloc(len);
02686     snprintf(win_title, len, <span class="stringliteral">"%s%s: %s"</span>, WIN_TITLE, VERSION, filename);
02687     gtk_window_set_title(GTK_WINDOW(win), win_title);
02688     free(win_title);
02689                              
02690 }
02691 
02692 <span class="preprocessor">#ifdef HAVE_GETOPT_LONG</span>
02693 <span class="preprocessor"></span><span class="keywordtype">int</span> longopt_val = 0;
02694 <span class="keywordtype">int</span> longopt_idx = 0;
02695 <span class="keyword">const</span> <span class="keyword">struct </span>option longopts[] = {
02696     <span class="comment">/* name              has_arg            flag  val */</span>
02697     {<span class="stringliteral">"version"</span>,          no_argument,       NULL,    <span class="charliteral">'V'</span>},
02698     {<span class="stringliteral">"help"</span>,             no_argument,       NULL,    <span class="charliteral">'h'</span>},
02699     {<span class="stringliteral">"batch"</span>,            required_argument, NULL,    <span class="charliteral">'b'</span>},
02700     {<span class="stringliteral">"log"</span>,              required_argument, NULL,    <span class="charliteral">'l'</span>},
02701     {<span class="stringliteral">"tools"</span>,            required_argument, NULL,    <span class="charliteral">'t'</span>},
02702     {<span class="stringliteral">"project"</span>,          required_argument, NULL,    <span class="charliteral">'p'</span>},
02703     {<span class="stringliteral">"dump"</span>,             no_argument,       NULL,    <span class="charliteral">'d'</span>},
02704     {<span class="stringliteral">"geometry"</span>,         required_argument, &amp;longopt_val, 1},
02705     <span class="comment">/* GDK/GDK debug flags to be "let through" */</span>
02706     {<span class="stringliteral">"gtk-module"</span>,       required_argument, &amp;longopt_val, 2},
02707     {<span class="stringliteral">"g-fatal-warnings"</span>, no_argument,       &amp;longopt_val, 2},
02708     {<span class="stringliteral">"gtk-debug"</span>,        required_argument, &amp;longopt_val, 2},
02709     {<span class="stringliteral">"gtk-no-debug"</span>,     required_argument, &amp;longopt_val, 2},
02710     {<span class="stringliteral">"gdk-debug"</span>,        required_argument, &amp;longopt_val, 2},
02711     {<span class="stringliteral">"gdk-no-debug"</span>,     required_argument, &amp;longopt_val, 2},
02712     {<span class="stringliteral">"display"</span>,          required_argument, &amp;longopt_val, 2},
02713     {<span class="stringliteral">"sync"</span>,             no_argument,       &amp;longopt_val, 2},
02714     {<span class="stringliteral">"no-xshm"</span>,          no_argument,       &amp;longopt_val, 2},
02715     {<span class="stringliteral">"name"</span>,             required_argument, &amp;longopt_val, 2},
02716     {<span class="stringliteral">"class"</span>,            required_argument, &amp;longopt_val, 2},
02717     {0, 0, 0, 0},
02718 };
02719 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_GETOPT_LONG*/</span>
02720 <span class="keyword">const</span> <span class="keywordtype">char</span> *opt_options = <span class="stringliteral">"Vhl:t:p:d"</span>;
02721 
02722 <span class="keywordtype">int</span>
02723 main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
02724 {
02725     GtkWidget *main_win;
02726     GtkWidget *vbox;
02727     GtkWidget *hbox;
02728     GtkWidget *menubar;
02729     GtkStyle  *textStyle;
02730     gint      screen_width, width, height;
02731     <span class="keywordtype">int</span>       read_opt;
02732     <span class="keywordtype">int</span>       i;
02733     <span class="keywordtype">int</span>       req_width = -1, req_height = -1, req_x = 0, req_y = 0;
02734     <span class="keywordtype">char</span>      *rest, *project_filename = NULL;
02735 
02736     <span class="comment">/*</span>
02737 <span class="comment">     * Setup the screen info. Must do this before getopt, since getopt</span>
02738 <span class="comment">     * eventually will set some variables in screen.</span>
02739 <span class="comment">     */</span>
02740     memset((<span class="keywordtype">void</span> *)&amp;screen, 0, <span class="keyword">sizeof</span>(gerbv_screen_t));
02741     <a class="code" href="gerbv_8c.html#a0">screen</a>.state = NORMAL;
02742 <span class="preprocessor"> #ifdef HAVE_LIBGEN_H    </span>
02743 <span class="preprocessor"></span>    <a class="code" href="gerbv_8c.html#a0">screen</a>.execpath = dirname(argv[0]);
02744 <span class="preprocessor">#else </span>
02745 <span class="preprocessor"></span>    <a class="code" href="gerbv_8c.html#a0">screen</a>.execpath = <span class="stringliteral">""</span>;
02746 <span class="preprocessor">#endif    </span>
02747 <span class="preprocessor"></span>    <a class="code" href="gerbv_8c.html#a0">screen</a>.transf = gerb_transf_new();
02748     <a class="code" href="gerbv_8c.html#a0">screen</a>.transf-&gt;<a class="code" href="structgerb__transf.html#o1">scale</a> = 0.0; <span class="comment">// will force reinitialization of the screen later</span>
02749 
02750     setup_init();
02751        
02752 <span class="preprocessor">#ifdef HAVE_GETOPT_LONG</span>
02753 <span class="preprocessor"></span>    <span class="keywordflow">while</span> ((read_opt = getopt_long(argc, argv, opt_options, 
02754                                longopts, &amp;longopt_idx)) != -1) {
02755 <span class="preprocessor">#else</span>
02756 <span class="preprocessor"></span>    <span class="keywordflow">while</span> ((read_opt = getopt(argc, argv, opt_options)) != -1) {
02757 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_GETOPT_LONG */</span>
02758        <span class="keywordflow">switch</span> (read_opt) {
02759 <span class="preprocessor">#ifdef HAVE_GETOPT_LONG</span>
02760 <span class="preprocessor"></span>       <span class="keywordflow">case</span> 0:
02761            <span class="comment">/* Only long options like GDK/GTK debug */</span>
02762            <span class="keywordflow">switch</span> (longopt_val) {
02763            <span class="keywordflow">case</span> 0: <span class="comment">/* default value if nothing is set */</span>
02764               printf(<span class="stringliteral">"Not handled option %s\n"</span>, longopts[longopt_idx].name);
02765               <span class="keywordflow">break</span>;
02766            <span class="keywordflow">case</span> 1: <span class="comment">/* geometry */</span>
02767               req_width = (int)strtol(optarg, &amp;rest, 10);
02768               <span class="keywordflow">if</span> (rest[0] != <span class="charliteral">'x'</span>){
02769                   printf(<span class="stringliteral">"Split X and Y parameters with an x\n"</span>);
02770                   <span class="keywordflow">break</span>;
02771               }
02772               rest++;
02773               req_height = (int)strtol(rest, &amp;rest, 10);
02774               <span class="keywordflow">if</span> ((rest[0] == 0) || ((rest[0] != <span class="charliteral">'-'</span>) &amp;&amp; (rest[0] != <span class="charliteral">'+'</span>)))
02775                   <span class="keywordflow">break</span>;
02776               req_x = (int)strtol(rest, &amp;rest, 10);
02777               <span class="keywordflow">if</span> ((rest[0] == 0) || ((rest[0] != <span class="charliteral">'-'</span>) &amp;&amp; (rest[0] != <span class="charliteral">'+'</span>)))
02778                   <span class="keywordflow">break</span>;
02779               req_y = (int)strtol(rest, &amp;rest, 10);
02780               <span class="keywordflow">break</span>;
02781            <span class="keywordflow">default</span>:
02782               <span class="keywordflow">break</span>;
02783            }
02784            <span class="keywordflow">break</span>;
02785 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_GETOPT_LONG */</span>
02786        <span class="keywordflow">case</span> <span class="charliteral">'V'</span> :
02787            printf(<span class="stringliteral">"gerbv version %s\n"</span>, VERSION);
02788            printf(<span class="stringliteral">"(C) Stefan Petersen (spe@stacken.kth.se)\n"</span>);
02789            exit(0);
02790        <span class="keywordflow">case</span> <span class="charliteral">'l'</span> :
02791            <span class="keywordflow">if</span> (optarg == NULL) {
02792               fprintf(stderr, <span class="stringliteral">"You must give a filename to send log to\n"</span>);
02793               exit(1);
02794            }
02795            setup.log.to_file = 1;
02796            setup.log.filename = optarg;
02797            <span class="keywordflow">break</span>;
02798        <span class="keywordflow">case</span> <span class="charliteral">'p'</span> :
02799            <span class="keywordflow">if</span> (optarg == NULL) {
02800               fprintf(stderr, <span class="stringliteral">"You must give a project filename\n"</span>);
02801               exit(1);
02802            }
02803            project_filename = optarg;
02804            <span class="keywordflow">break</span>;
02805        <span class="keywordflow">case</span> <span class="charliteral">'t'</span> :
02806            <span class="keywordflow">if</span> (optarg == NULL) {
02807               fprintf(stderr, <span class="stringliteral">"You must give a filename to read the tools from.\n"</span>);
02808               exit(1);
02809            }
02810            <span class="keywordflow">if</span> (!ProcessToolsFile(optarg)) {
02811               fprintf(stderr, <span class="stringliteral">"*** ERROR processing tools file \"%s\".\n"</span>, optarg);
02812               fprintf(stderr, <span class="stringliteral">"Make sure all lines of the file are formatted like this:\n"</span>);
02813               fprintf(stderr, <span class="stringliteral">"T01 0.024\nT02 0.032\nT03 0.040\n...\n"</span>);
02814               fprintf(stderr, <span class="stringliteral">"*** EXITING to prevent erroneous display.\n"</span>);
02815               exit(1);
02816             }
02817            <span class="keywordflow">break</span>;
02818        <span class="keywordflow">case</span> <span class="charliteral">'d'</span>:
02819            <a class="code" href="gerbv_8c.html#a0">screen</a>.dump_parsed_image = 1;
02820            <span class="keywordflow">break</span>;
02821        <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
02822        <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
02823 <span class="preprocessor">#ifdef HAVE_GETOPT_LONG</span>
02824 <span class="preprocessor"></span>           fprintf(stderr, <span class="stringliteral">"Usage : %s [FLAGS] &lt;gerber file(s)&gt;\n"</span>, argv[0]);
02825            fprintf(stderr, <span class="stringliteral">"where FLAGS could be any of\n"</span>);
02826            fprintf(stderr, <span class="stringliteral">"  --version|-V : Prints version of gerbv\n"</span>);
02827            fprintf(stderr, <span class="stringliteral">"  --help|-h : Prints this help message\n"</span>);
02828            fprintf(stderr, <span class="stringliteral">"  --log=&lt;logfile&gt;|-l &lt;logfile&gt; : Send error messages to &lt;logfile&gt;\n"</span>);
02829            fprintf(stderr, <span class="stringliteral">"  --project=&lt;prjfile&gt;|-p &lt;prjfile&gt; : Load project file &lt;prjfile&gt;\n"</span>);
02830            fprintf(stderr, <span class="stringliteral">"  --tools=&lt;toolfile&gt;|-t &lt;toolfile&gt; : Read Excellon tools from file &lt;toolfile&gt;\n"</span>);
02831            exit(1);
02832            <span class="keywordflow">break</span>;
02833 <span class="preprocessor">#else</span>
02834 <span class="preprocessor"></span>           fprintf(stderr, <span class="stringliteral">"Usage : %s [FLAGS] &lt;gerber file(s)&gt;\n"</span>, argv[0]);
02835            fprintf(stderr, <span class="stringliteral">"where FLAGS could be any of\n"</span>);
02836            fprintf(stderr, <span class="stringliteral">"  -V : Prints version of gerbv\n"</span>);
02837            fprintf(stderr, <span class="stringliteral">"  -h : Prints this help message\n"</span>);
02838            fprintf(stderr, <span class="stringliteral">"  -l &lt;logfile&gt; : Send error messages to &lt;logfile&gt;\n"</span>);
02839            fprintf(stderr, <span class="stringliteral">"  -p &lt;prjfile&gt; : Load project file &lt;prjfile&gt;\n"</span>);
02840            fprintf(stderr, <span class="stringliteral">"  -t &lt;toolfile&gt; : Read Excellon tools from file &lt;toolfile&gt;\n"</span>);
02841            exit(1);
02842            <span class="keywordflow">break</span>;
02843 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_GETOPT_LONG */</span>
02844        <span class="keywordflow">default</span> :
02845            printf(<span class="stringliteral">"Not handled option [%d=%c]\n"</span>, read_opt, read_opt);
02846        }
02847     }
02848     
02849     <span class="comment">/*</span>
02850 <span class="comment">     * Init GTK+</span>
02851 <span class="comment">     */</span>
02852     gtk_init(&amp;argc, &amp;argv);
02853 
02854     <span class="comment">/* </span>
02855 <span class="comment">     * Good defaults according to Ales. Gives aspect ratio of 1.3333...</span>
02856 <span class="comment">     */</span>
02857     <span class="keywordflow">if</span> ((req_width != -1) &amp;&amp; (req_height != -1)) {
02858        width = req_width;
02859        height = req_height;
02860     } <span class="keywordflow">else</span> {
02861        screen_width = gdk_screen_width();
02862        width = screen_width * 3/4;
02863        height = width * 3/4;
02864     }
02865 
02866     <span class="comment">/*</span>
02867 <span class="comment">     * Setup some GTK+ defaults</span>
02868 <span class="comment">     */</span>
02869     <a class="code" href="gerbv_8c.html#a0">screen</a>.tooltips = gtk_tooltips_new();        
02870     <a class="code" href="gerbv_8c.html#a0">screen</a>.background = alloc_color(0, 0, 0, <span class="stringliteral">"black"</span>);
02871     <a class="code" href="gerbv_8c.html#a0">screen</a>.zoom_outline_color  = alloc_color(0, 0, 0, <span class="stringliteral">"gray"</span>);
02872     <a class="code" href="gerbv_8c.html#a0">screen</a>.dist_measure_color  = alloc_color(0, 0, 0, <span class="stringliteral">"lightblue"</span>);
02873 
02874     <span class="comment">/*</span>
02875 <span class="comment">     * Set console error log handler. The default gives us error levels in</span>
02876 <span class="comment">     * in the beginning which I don't want.</span>
02877 <span class="comment">     */</span>
02878     g_log_set_handler (NULL, 
02879                      G_LOG_FLAG_FATAL | G_LOG_FLAG_RECURSION | G_LOG_LEVEL_MASK, 
02880                      gerbv_console_log_handler, NULL); 
02881 
02882     <span class="comment">/* Set default unit to the configured default */</span>
02883     <a class="code" href="gerbv_8c.html#a0">screen</a>.unit = GERBV_DEFAULT_UNIT;
02884 
02885     <span class="comment">/*</span>
02886 <span class="comment">     * Main window </span>
02887 <span class="comment">     */</span>
02888     main_win = gtk_window_new(GTK_WINDOW_TOPLEVEL);
02889     rename_main_window(<span class="stringliteral">""</span>, main_win);
02890 <span class="preprocessor">#ifdef USE_GTK2</span>
02891 <span class="preprocessor"></span>    g_signal_connect(GTK_OBJECT(main_win), <span class="stringliteral">"delete_event"</span>, G_CALLBACK(destroy), NULL);
02892 <span class="preprocessor">#else</span>
02893 <span class="preprocessor"></span>    gtk_signal_connect(GTK_OBJECT(main_win), <span class="stringliteral">"delete_event"</span>, destroy, NULL);
02894     gtk_signal_connect(GTK_OBJECT(main_win), <span class="stringliteral">"destroy"</span>, destroy, NULL);
02895 <span class="preprocessor">#endif</span>
02896 <span class="preprocessor"></span>
02897     <span class="comment">/* </span>
02898 <span class="comment">     * vbox contains menubar and hbox</span>
02899 <span class="comment">     */</span>
02900     vbox = gtk_vbox_new(FALSE, 0);
02901     gtk_container_add(GTK_CONTAINER(main_win), vbox);
02902     
02903     create_menubar(main_win, &amp;menubar);
02904     gtk_box_pack_start(GTK_BOX(vbox), menubar, FALSE, FALSE, 0);
02905     
02906     <span class="comment">/* </span>
02907 <span class="comment">     * hbox contains drawing area and image select area</span>
02908 <span class="comment">     */</span>
02909     hbox = gtk_hbox_new(FALSE, 0);
02910     
02911     <span class="comment">/*</span>
02912 <span class="comment">     * Create drawing area</span>
02913 <span class="comment">     */</span>
02914     <a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area = create_drawing_area(width, height);
02915     gtk_box_pack_start(GTK_BOX(hbox), <a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area, TRUE, TRUE, 0);
02916     
02917     <span class="comment">/*</span>
02918 <span class="comment">     * Build layer buttons with popup menus</span>
02919 <span class="comment">     */</span>
02920     create_popupmenu(&amp;<a class="code" href="gerbv_8c.html#a0">screen</a>.popup_menu);
02921     gtk_box_pack_start(GTK_BOX(hbox), create_layer_buttons(MAX_FILES), 
02922                      FALSE, FALSE, 0);
02923 
02924     gtk_box_pack_start(GTK_BOX(vbox), hbox, TRUE, TRUE, 0);
02925 
02926     <span class="comment">/*</span>
02927 <span class="comment">     * Add status bar (three sections: messages, abs and rel coords)</span>
02928 <span class="comment">     */</span>
02929     hbox = gtk_hbox_new(FALSE, 0);
02930     <a class="code" href="gerbv_8c.html#a0">screen</a>.statusbar.msg = gtk_label_new(<span class="stringliteral">""</span>);
02931     gtk_label_set_justify(GTK_LABEL(<a class="code" href="gerbv_8c.html#a0">screen</a>.statusbar.msg), GTK_JUSTIFY_LEFT);
02932     textStyle = gtk_style_new();
02933 <span class="preprocessor">#ifndef USE_GTK2</span>
02934 <span class="preprocessor"></span>    textStyle-&gt;font = gdk_font_load(setup.status_fontname);
02935 <span class="preprocessor">#else</span>
02936 <span class="preprocessor"></span>    textStyle-&gt;font_desc = pango_font_description_from_string(setup.status_fontname);
02937 <span class="preprocessor">#endif</span>
02938 <span class="preprocessor"></span>    gtk_widget_set_style(GTK_WIDGET(<a class="code" href="gerbv_8c.html#a0">screen</a>.statusbar.msg), textStyle);
02939     <a class="code" href="gerbv_8c.html#a0">screen</a>.statusbar.msgstr[0] = <span class="charliteral">'\0'</span>;
02940     <a class="code" href="gerbv_8c.html#a0">screen</a>.statusbar.coordstr[0] = <span class="charliteral">'\0'</span>;
02941     <a class="code" href="gerbv_8c.html#a0">screen</a>.statusbar.diststr[0] = <span class="charliteral">'\0'</span>;
02942     gtk_box_pack_start(GTK_BOX(hbox), <a class="code" href="gerbv_8c.html#a0">screen</a>.statusbar.msg, FALSE, FALSE, 0);
02943     gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);
02944 
02945     <span class="comment">/*</span>
02946 <span class="comment">     * If project is given, load that one and use it for files and colors.</span>
02947 <span class="comment">     * Else load files (eventually) given on the command line.</span>
02948 <span class="comment">     * This limits you to either give files on the commandline or just load</span>
02949 <span class="comment">     * a project.</span>
02950 <span class="comment">     */</span>
02951     <span class="keywordflow">if</span> (project_filename) {
02952        <a class="code" href="structproject__list__t.html">project_list_t</a> *project_list;
02953 
02954        project_list = <a class="code" href="project_8h.html#a3">read_project_file</a>(project_filename);
02955        
02956        <span class="keywordflow">if</span> (project_list) {
02957            load_project(project_list);
02958            <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.project) {
02959               free(<a class="code" href="gerbv_8c.html#a0">screen</a>.project);
02960               <a class="code" href="gerbv_8c.html#a0">screen</a>.project = NULL;
02961            }
02962            <a class="code" href="gerbv_8c.html#a0">screen</a>.project = (<span class="keywordtype">char</span> *)malloc(strlen(project_filename) + 1);
02963            memset((<span class="keywordtype">void</span> *)<a class="code" href="gerbv_8c.html#a0">screen</a>.project, 0, strlen(project_filename) + 1);
02964            strncpy(<a class="code" href="gerbv_8c.html#a0">screen</a>.project, project_filename, strlen(project_filename));
02965            <span class="comment">/*</span>
02966 <span class="comment">            * Remember where we loaded file from last time</span>
02967 <span class="comment">            */</span>
02968            <span class="keywordflow">if</span> (<a class="code" href="gerbv_8c.html#a0">screen</a>.path)
02969               free(<a class="code" href="gerbv_8c.html#a0">screen</a>.path);
02970            <a class="code" href="gerbv_8c.html#a0">screen</a>.path = (<span class="keywordtype">char</span> *)malloc(strlen(project_filename) + 1);
02971            strcpy(<a class="code" href="gerbv_8c.html#a0">screen</a>.path, project_filename);
02972 <span class="preprocessor">#ifdef HAVE_LIBGEN_H             </span>
02973 <span class="preprocessor"></span>           dirname(<a class="code" href="gerbv_8c.html#a0">screen</a>.path);
02974 <span class="preprocessor">#endif</span>
02975 <span class="preprocessor"></span>           <a class="code" href="gerbv_8c.html#a0">screen</a>.path = strncat(<a class="code" href="gerbv_8c.html#a0">screen</a>.path, <span class="stringliteral">"/"</span>, 1);
02976            
02977             rename_main_window(<a class="code" href="gerbv_8c.html#a0">screen</a>.project, NULL);
02978        } <span class="keywordflow">else</span> {
02979            GERB_MESSAGE(<span class="stringliteral">"Failed to load project\n"</span>);
02980        }
02981 
02982     } <span class="keywordflow">else</span> {
02983        <span class="keywordflow">for</span>(i = optind ; i &lt; argc; i++)
02984            <span class="keywordflow">if</span> (open_image(argv[i], i - optind, FALSE) == -1)
02985               exit(-1);
02986     }
02987 
02988     <span class="comment">/*</span>
02989 <span class="comment">     * Set gtk error log handler</span>
02990 <span class="comment">     */</span>
02991 <span class="preprocessor">#if !defined (__MINGW32__)     </span>
02992 <span class="preprocessor"></span>    g_log_set_handler (NULL, 
02993                      G_LOG_FLAG_FATAL | G_LOG_FLAG_RECURSION | G_LOG_LEVEL_MASK, 
02994                      gerbv_gtk_log_handler, NULL); 
02995 <span class="preprocessor">#endif                       </span>
02996 <span class="preprocessor"></span>
02997     <span class="comment">/*</span>
02998 <span class="comment">     * Connect all events on drawing area </span>
02999 <span class="comment">     */</span>    
03000     gtk_signal_connect(GTK_OBJECT(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area), <span class="stringliteral">"expose_event"</span>,
03001                      GTK_SIGNAL_FUNC(expose_event), NULL);
03002     gtk_signal_connect(GTK_OBJECT(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area),<span class="stringliteral">"configure_event"</span>,
03003                      GTK_SIGNAL_FUNC(configure_event), NULL);
03004     gtk_signal_connect(GTK_OBJECT(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area), <span class="stringliteral">"motion_notify_event"</span>,
03005                      GTK_SIGNAL_FUNC(motion_notify_event), NULL);
03006     gtk_signal_connect(GTK_OBJECT(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area), <span class="stringliteral">"button_press_event"</span>,
03007                      GTK_SIGNAL_FUNC(button_press_event), NULL);
03008     gtk_signal_connect(GTK_OBJECT(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area), <span class="stringliteral">"button_release_event"</span>,
03009                      GTK_SIGNAL_FUNC(button_release_event), NULL);
03010     gtk_signal_connect_after(GTK_OBJECT(main_win), <span class="stringliteral">"key_press_event"</span>,
03011                      GTK_SIGNAL_FUNC(key_press_event), NULL);
03012     gtk_signal_connect_after(GTK_OBJECT(main_win), <span class="stringliteral">"key_release_event"</span>,
03013                      GTK_SIGNAL_FUNC(key_release_event), NULL);
03014 <span class="preprocessor">#ifdef USE_GTK2</span>
03015 <span class="preprocessor"></span>    gtk_signal_connect_after(GTK_OBJECT(main_win), <span class="stringliteral">"scroll_event"</span>,
03016                      GTK_SIGNAL_FUNC(scroll_event), NULL);
03017 <span class="preprocessor">#endif</span>
03018 <span class="preprocessor"></span>
03019     gtk_widget_set_events(<a class="code" href="gerbv_8c.html#a0">screen</a>.drawing_area, GDK_EXPOSURE_MASK
03020                        | GDK_LEAVE_NOTIFY_MASK
03021                        | GDK_BUTTON_PRESS_MASK
03022                        | GDK_BUTTON_RELEASE_MASK
03023                        | GDK_KEY_PRESS_MASK
03024                        | GDK_KEY_RELEASE_MASK
03025                        | GDK_POINTER_MOTION_MASK
03026                        | GDK_POINTER_MOTION_HINT_MASK
03027 #ifdef USE_GTK2
03028                        | GDK_SCROLL_MASK
03029 #endif
03030                        );
03031 
03032     gtk_widget_show_all(main_win);
03033     set_window_icon(main_win);
03034 
03035     <span class="comment">/* It seems this has to be done after the button is shown for</span>
03036 <span class="comment">       the first time, or we get a segmentation fault */</span>
03037     <span class="keywordflow">if</span> (project_filename)
03038        all_layers_on(NULL, NULL);
03039     <span class="keywordflow">else</span>
03040        gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(<a class="code" href="gerbv_8c.html#a0">screen</a>.layer_button[0]),
03041                                  TRUE);
03042     parsed_PNP_data = NULL;                     
03043 
03044     gtk_main();
03045     
03046     <span class="keywordflow">return</span> 0;
03047 } <span class="comment">/* main */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Oct 13 16:09:19 2004 for gerbv by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.8-20040928 </small></address>
</body>
</html>
