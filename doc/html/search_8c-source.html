<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gerbv: src/search.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8-20040928 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a></div>
<h1>search.c</h1><a href="search_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * gEDA - GNU Electronic Design Automation</span>
00003 <span class="comment"> * This file is a part of gerbv.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> *   Copyright (C) 2004 Juergen Haas (juergenhaas@gmx.net)</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> * $Id$</span>
00008 <span class="comment"> *                          by Juergen Haas (juergenhaas@gmx.net)</span>
00009 <span class="comment"> *</span>
00010 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
00011 <span class="comment"> * it under the terms of the GNU General Public License as published by</span>
00012 <span class="comment"> * the Free Software Foundation; either version 2 of the License, or</span>
00013 <span class="comment"> * (at your option) any later version.</span>
00014 <span class="comment"> *</span>
00015 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
00016 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00017 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00018 <span class="comment"> * GNU General Public License for more details.</span>
00019 <span class="comment"> *</span>
00020 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
00021 <span class="comment"> * along with this program; if not, write to the Free Software</span>
00022 <span class="comment"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA</span>
00023 <span class="comment"> */</span>
00024 
00025 
00029 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#include &lt;config.h&gt;</span>
00031 <span class="preprocessor">#endif</span>
00032 <span class="preprocessor"></span>
00033 <span class="preprocessor">#ifdef USE_GTK2</span>
00034 <span class="preprocessor"></span><span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00035 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00036 <span class="preprocessor">#include &lt;string.h&gt;</span>
00037 <span class="preprocessor">#include &lt;math.h&gt;</span>
00038 
00039 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00040 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
00041 <span class="preprocessor">#ifdef HAVE_UNISTD_H</span>
00042 <span class="preprocessor"></span><span class="preprocessor">#include &lt;unistd.h&gt;</span>
00043 <span class="preprocessor">#endif</span>
00044 <span class="preprocessor"></span><span class="preprocessor">#include &lt;errno.h&gt;</span>
00045 <span class="preprocessor">#include &lt;locale.h&gt;</span>
00046 
00047 
00048 <span class="preprocessor">#include &lt;gtk/gtk.h&gt;</span>
00049 <span class="preprocessor">#include &lt;gdk/gdk.h&gt;</span>
00050 
00051 <span class="preprocessor">#include "search_file.h"</span>
00052 <span class="preprocessor">#include "gerb_error.h"</span>
00053 <span class="preprocessor">#include "search.h"</span>
00054 <span class="preprocessor">#include "search_gui.h"</span>
00055 <span class="preprocessor">#include "csv.h"</span>
00056 
00057 
00058 
00061 <a class="code" href="structpnp__state.html">pnp_state_t</a> *
<a name="l00062"></a><a class="code" href="search_8c.html#a0">00062</a> <a class="code" href="search_8c.html#a0">new_pnp_state</a>()
00063 {
00064     <a class="code" href="structpnp__state.html">pnp_state_t</a> *<a class="code" href="structpnp__state.html">pnp_state</a>;
00065 
00066     pnp_state = (<a class="code" href="structpnp__state.html">pnp_state_t</a> *)malloc(<span class="keyword">sizeof</span>(<a class="code" href="structpnp__state.html">pnp_state_t</a>));
00067     <span class="keywordflow">if</span> (pnp_state == NULL) {
00068        free(pnp_state);
00069        <span class="keywordflow">return</span> NULL;
00070     }
00071 
00072     memset(pnp_state, 0, <span class="keyword">sizeof</span>(pnp_state));
00073     
00074     <span class="keywordflow">return</span> pnp_state;
00075 } <span class="comment">/* new_pnp_state */</span>
00076 
00077 
00078 
00080 
<a name="l00082"></a><a class="code" href="search_8c.html#a1">00082</a> <span class="keywordtype">double</span> <a class="code" href="search_8c.html#a1">get_float_unit</a>(<span class="keywordtype">char</span> *str)
00083 {
00084     <span class="keywordtype">double</span> x = 0.0;
00085     <span class="keywordtype">char</span> unit[41];
00086     <span class="comment">/* float, optional space, optional unit mm,cm,in,mil */</span>
00087     sscanf(str, <span class="stringliteral">"%lf %40s"</span>, &amp;x, unit);
00088     <span class="keywordflow">if</span>(strstr(unit,<span class="stringliteral">"in"</span>)) {
00089         x *= 25.4;
00090     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strstr(unit,<span class="stringliteral">"mil"</span>)) {
00091         x *= 0.0254;
00092     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strstr(unit, <span class="stringliteral">"cm"</span>)) {
00093         x *= 10.0;
00094     }
00095     <span class="keywordflow">return</span> x;
00096 }<span class="comment">/*get_float_unit*/</span>
00097 
<a name="l00100"></a><a class="code" href="search_8c.html#a2">00100</a> <span class="keywordtype">int</span> <a class="code" href="search_8c.html#a2">pnp_screen_for_delimiter</a>(<span class="keywordtype">char</span> *str, <span class="keywordtype">int</span> n)
00101 {
00102     <span class="keywordtype">char</span> *ptr;
00103     <span class="keywordtype">char</span> delimiter[4] = <span class="stringliteral">"|,;:"</span>;
00104     <span class="keywordtype">int</span> counter[4];
00105     <span class="keywordtype">int</span> idx, idx_max = 0;
00106     
00107     memset(counter, 0, <span class="keyword">sizeof</span>(counter));
00108     <span class="keywordflow">for</span>(ptr=str; *ptr; ptr++) {
00109         <span class="keywordflow">switch</span>(*ptr) {
00110         <span class="keywordflow">case</span> <span class="charliteral">'|'</span>:
00111             idx = 0;
00112             <span class="keywordflow">break</span>;
00113         <span class="keywordflow">case</span> <span class="charliteral">','</span>:
00114             idx = 1;
00115             <span class="keywordflow">break</span>;
00116         <span class="keywordflow">case</span> <span class="charliteral">';'</span>:
00117             idx = 2;
00118             <span class="keywordflow">break</span>;
00119         <span class="keywordflow">case</span> <span class="charliteral">':'</span>:
00120             idx = 3;
00121             <span class="keywordflow">break</span>;
00122         <span class="keywordflow">default</span>:
00123             <span class="keywordflow">continue</span>;
00124             <span class="keywordflow">break</span>;
00125         }
00126         counter[idx]++;
00127         <span class="keywordflow">if</span>(counter[idx]&gt;counter[idx_max]) {
00128             idx_max = idx;
00129         }
00130     }
00131     <span class="keywordflow">if</span> (counter[idx_max] &gt; n) {
00132         <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> char) delimiter[idx_max];
00133     } <span class="keywordflow">else</span> {
00134         <span class="keywordflow">return</span> -1;
00135     }
00136 }<span class="comment">/*pnp_screen_for_delimiter*/</span>
00137 
00138 
<a name="l00145"></a><a class="code" href="search_8c.html#a3">00145</a> <a class="code" href="structpnp__state.html">pnp_state_t</a> *<a class="code" href="search_8c.html#a3">parse_pnp</a>(<a class="code" href="structpnp__file.html">pnp_file_t</a> *fd)
00146 {
00147     <a class="code" href="structpnp__state.html">pnp_state_t</a>      *<a class="code" href="structpnp__state.html">pnp_state</a> = NULL;
00148     <a class="code" href="structpnp__state.html">pnp_state_t</a>      *pnp_state0 = NULL;
00149     <span class="keywordtype">int</span>               line_counter = 0;
00150     <span class="keywordtype">int</span>               ret;
00151     <span class="keywordtype">char</span>             *row[12];
00152     <span class="keywordtype">int</span>               delimiter=-1;
00153     <span class="keywordtype">char</span>              buf[MAXL+2], buf0[MAXL+2];
00154     <span class="keywordtype">double</span>            tmp_x, tmp_y;
00155     <a class="code" href="structgerb__transf.html">gerb_transf_t</a>    *tr_rot = gerb_transf_new();
00156     
00157     <span class="comment">/* added by t.motylewski@bfad.de</span>
00158 <span class="comment">     * many locales redefine "." as "," and so on, so sscanf has problems when</span>
00159 <span class="comment">     * reading Pick and Place files using %f format */</span>
00160     setlocale(LC_NUMERIC, <span class="stringliteral">"C"</span> );
00161 
00162     <span class="keywordflow">while</span> ( fgets(buf, MAXL, fd-&gt;<a class="code" href="structpnp__file.html#o0">fd</a>) != NULL ) {
00163        <span class="keywordtype">int</span> len = strlen(buf)-1;
00164         line_counter += 1;<span class="comment">/*next line*/</span>
00165        <span class="keywordflow">if</span>(line_counter&lt;2) {
00166            <span class="comment">// TODO in principle column names could be read and interpreted</span>
00167            <span class="keywordflow">continue</span>; <span class="comment">// skip the first line with names of columns</span>
00168        }
00169         <span class="keywordflow">if</span>(len &gt;=0 &amp;&amp; buf[len] == <span class="charliteral">'\n'</span>)
00170             buf[len--] = 0;
00171         <span class="keywordflow">if</span>(len &gt;=0 &amp;&amp; buf[len] == <span class="charliteral">'\r'</span>)
00172             buf[len--] = 0;
00173         <span class="keywordflow">if</span> (len &lt;= 11 )  {  <span class="comment">//lets check a minimum length of 11</span>
00174            <span class="keywordflow">continue</span>;
00175        }
00176        <span class="comment">/* this accepts file both with and without quotes */</span>
00177         <span class="keywordflow">if</span> (!pnp_state) { <span class="comment">//we are in first line</span>
00178             <span class="keywordflow">if</span> ((delimiter = <a class="code" href="search_8c.html#a2">pnp_screen_for_delimiter</a>(buf, 8)) &lt; 0) {
00179             <span class="keywordflow">continue</span>;
00180             }
00181         }    
00182         ret = csv_row_parse(buf, MAXL,  buf0, MAXL, row, 11, delimiter,   CSV_QUOTES);
00183         <span class="comment">// printf("direct:%s, %s, %s, %s, %s, %s, %s, %s, %s, %s,  %s, ret %d\n", row[0], row[1], row[2],row[3], row[4], row[5], row[6], row[7], row[8], row[9], row[10], ret);       </span>
00184         
00185         <span class="keywordflow">if</span>(pnp_state) {
00186             pnp_state = pnp_state-&gt;<a class="code" href="structpnp__state.html#o15">next</a> = <a class="code" href="search_8c.html#a0">new_pnp_state</a>();
00187         } <span class="keywordflow">else</span> {
00188             <span class="comment">// first element</span>
00189             pnp_state0 = pnp_state = <a class="code" href="search_8c.html#a0">new_pnp_state</a>();
00190         }
00191    
00192         <span class="keywordflow">if</span> (row[0] &amp;&amp; row[8]) { <span class="comment">// here could be some better check for the syntax</span>
00193            <span class="keywordtype">int</span> i_length=0, i_width = 0;
00194             memset  (pnp_state-&gt;<a class="code" href="structpnp__state.html#o0">designator</a>, 0, <span class="keyword">sizeof</span>(pnp_state-&gt;<a class="code" href="structpnp__state.html#o0">designator</a>));
00195             sprintf (pnp_state-&gt;<a class="code" href="structpnp__state.html#o0">designator</a>, <span class="stringliteral">"%.*s"</span>, <span class="keyword">sizeof</span>(pnp_state-&gt;<a class="code" href="structpnp__state.html#o0">designator</a>)-1, row[0]);
00196             memset  (pnp_state-&gt;<a class="code" href="structpnp__state.html#o1">footprint</a>, 0, <span class="keyword">sizeof</span>(pnp_state-&gt;<a class="code" href="structpnp__state.html#o1">footprint</a>));
00197             sprintf (pnp_state-&gt;<a class="code" href="structpnp__state.html#o1">footprint</a>, <span class="stringliteral">"%.*s"</span>, <span class="keyword">sizeof</span>(pnp_state-&gt;<a class="code" href="structpnp__state.html#o1">footprint</a>)-1, row[1]);
00198             memset  (pnp_state-&gt;<a class="code" href="structpnp__state.html#o8">layer</a>, 0, <span class="keyword">sizeof</span>(pnp_state-&gt;<a class="code" href="structpnp__state.html#o8">layer</a>));
00199             sprintf (pnp_state-&gt;<a class="code" href="structpnp__state.html#o8">layer</a>, <span class="stringliteral">"%.*s"</span>, <span class="keyword">sizeof</span>(pnp_state-&gt;<a class="code" href="structpnp__state.html#o8">layer</a>)-1, row[8]);
00200             memset  (pnp_state-&gt;<a class="code" href="structpnp__state.html#o10">comment</a>, 0, <span class="keyword">sizeof</span>(pnp_state-&gt;<a class="code" href="structpnp__state.html#o10">comment</a>));
00201             <span class="keywordflow">if</span> (row[10] != NULL) {
00202                 memset  (pnp_state-&gt;<a class="code" href="structpnp__state.html#o10">comment</a>, 0, <span class="keyword">sizeof</span>(pnp_state-&gt;<a class="code" href="structpnp__state.html#o10">comment</a>));
00203                 <span class="keywordflow">if</span> ( ! g_utf8_validate(row[10], -1, NULL)) {
00204                   gchar * str = g_convert(row[10], strlen(row[10]), <span class="stringliteral">"UTF-8"</span>, <span class="stringliteral">"ISO-8859-1"</span>,
00205                         NULL, NULL, NULL);
00206                   <span class="comment">// I have not decided yet whether it is better to use always</span>
00207                   <span class="comment">// "ISO-8859-1" or current locale.</span>
00208                   <span class="comment">// str = g_locale_to_utf8(row[10], -1, NULL, NULL, NULL);</span>
00209                     sprintf (pnp_state-&gt;<a class="code" href="structpnp__state.html#o10">comment</a>, <span class="stringliteral">"%.*s"</span>, <span class="keyword">sizeof</span>(pnp_state-&gt;<a class="code" href="structpnp__state.html#o10">comment</a>)-1, str);
00210                   g_free(str);
00211               } <span class="keywordflow">else</span> 
00212                     sprintf (pnp_state-&gt;<a class="code" href="structpnp__state.html#o10">comment</a>, <span class="stringliteral">"%.*s"</span>, <span class="keyword">sizeof</span>(pnp_state-&gt;<a class="code" href="structpnp__state.html#o10">comment</a>)-1, row[10]);
00213             }
00214     <span class="comment">/*</span>
00215 <span class="comment">    gchar* g_convert(const gchar *str, gssize len, const gchar *to_codeset, const gchar *from_codeset, gsize *bytes_read, gsize *bytes_written, GError **error);</span>
00216 <span class="comment">    */</span>
00217             pnp_state-&gt;<a class="code" href="structpnp__state.html#o2">mid_x</a> = <a class="code" href="search_8c.html#a1">get_float_unit</a>(row[2]);
00218                pnp_state-&gt;<a class="code" href="structpnp__state.html#o3">mid_y</a> = <a class="code" href="search_8c.html#a1">get_float_unit</a>(row[3]);
00219                pnp_state-&gt;<a class="code" href="structpnp__state.html#o4">ref_x</a> = <a class="code" href="search_8c.html#a1">get_float_unit</a>(row[4]);
00220                pnp_state-&gt;<a class="code" href="structpnp__state.html#o5">ref_y</a> = <a class="code" href="search_8c.html#a1">get_float_unit</a>(row[5]);
00221                pnp_state-&gt;<a class="code" href="structpnp__state.html#o6">pad_x</a> = <a class="code" href="search_8c.html#a1">get_float_unit</a>(row[6]);
00222                pnp_state-&gt;<a class="code" href="structpnp__state.html#o7">pad_y</a> = <a class="code" href="search_8c.html#a1">get_float_unit</a>(row[7]);
00223                sscanf(row[9], <span class="stringliteral">"%lf"</span>, &amp;pnp_state-&gt;<a class="code" href="structpnp__state.html#o9">rotation</a>); <span class="comment">// no units, always deg</span>
00224             
00225                <span class="keywordflow">if</span>(sscanf(pnp_state-&gt;<a class="code" href="structpnp__state.html#o1">footprint</a>, <span class="stringliteral">"%02d%02d"</span>, &amp;i_length, &amp;i_width) == 2) {
00226                       <span class="comment">// parse footprints like 0805 or 1206</span>
00227                       pnp_state-&gt;<a class="code" href="structpnp__state.html#o13">length</a> = 0.254 * i_length;
00228                 pnp_state-&gt;<a class="code" href="structpnp__state.html#o12">width</a> = 0.254 * i_width;
00229                       pnp_state-&gt;<a class="code" href="structpnp__state.html#o11">shape</a> = PART_SHAPE_RECTANGLE;
00230                } <span class="keywordflow">else</span> { 
00231                 gerb_transf_reset(tr_rot);
00232                 <a class="code" href="gerb__transf_8c.html#a3">gerb_transf_rotate</a>(tr_rot, -pnp_state-&gt;<a class="code" href="structpnp__state.html#o9">rotation</a> * M_PI/180);<span class="comment">/* rotate it back to get dimensions */</span>
00233                 gerb_transf_apply( pnp_state-&gt;<a class="code" href="structpnp__state.html#o6">pad_x</a> -  pnp_state-&gt;<a class="code" href="structpnp__state.html#o2">mid_x</a>, 
00234                      pnp_state-&gt;<a class="code" href="structpnp__state.html#o7">pad_y</a> - pnp_state-&gt;<a class="code" href="structpnp__state.html#o3">mid_y</a>, tr_rot, 
00235                      &amp;tmp_x, &amp;tmp_y);
00236                 <span class="keywordflow">if</span> ((fabs(tmp_y) &gt; fabs(tmp_x/100)) &amp;&amp; (fabs(tmp_x) &gt; fabs(tmp_y/100))){
00237                     pnp_state-&gt;<a class="code" href="structpnp__state.html#o13">length</a> = 2 * tmp_x;<span class="comment">/* get dimensions*/</span>
00238                     pnp_state-&gt;<a class="code" href="structpnp__state.html#o12">width</a> = 2 * tmp_y;
00239                     pnp_state-&gt;<a class="code" href="structpnp__state.html#o11">shape</a> = PART_SHAPE_STD;
00240                     
00241                 } <span class="keywordflow">else</span> {
00242                     pnp_state-&gt;<a class="code" href="structpnp__state.html#o13">length</a> = 0.0;
00243                     pnp_state-&gt;<a class="code" href="structpnp__state.html#o12">width</a> = 0.0;
00244                     pnp_state-&gt;<a class="code" href="structpnp__state.html#o11">shape</a> = PART_SHAPE_UNKNOWN;
00245                 }
00246             }    
00247 
00248             gtk_list_store_append (GTK_LIST_STORE(fd-&gt;<a class="code" href="structpnp__file.html#o1">model</a>), &amp;interface.<a class="code" href="struct__InterfaceStruct.html#o20">iter</a>); 
00249             gtk_list_store_set (GTK_LIST_STORE(fd-&gt;<a class="code" href="structpnp__file.html#o1">model</a>), &amp;interface.<a class="code" href="struct__InterfaceStruct.html#o20">iter</a>,
00250                 COLUMN_DESIGNATOR, pnp_state-&gt;<a class="code" href="structpnp__state.html#o0">designator</a>, 
00251                COLUMN_footprint, pnp_state-&gt;<a class="code" href="structpnp__state.html#o1">footprint</a>,
00252                COLUMN_mid_x, pnp_state-&gt;<a class="code" href="structpnp__state.html#o2">mid_x</a>,
00253                COLUMN_mid_y, pnp_state-&gt;<a class="code" href="structpnp__state.html#o3">mid_y</a> ,
00254                COLUMN_ref_x, pnp_state-&gt;<a class="code" href="structpnp__state.html#o4">ref_x</a>,
00255                COLUMN_ref_y, pnp_state-&gt;<a class="code" href="structpnp__state.html#o5">ref_y</a>,
00256                COLUMN_pad_x, pnp_state-&gt;<a class="code" href="structpnp__state.html#o6">pad_x</a>,
00257                COLUMN_pad_y, pnp_state-&gt;<a class="code" href="structpnp__state.html#o7">pad_y</a>,
00258             COLUMN_LAYER, pnp_state-&gt;<a class="code" href="structpnp__state.html#o8">layer</a>,
00259             COLUMN_rotation, pnp_state-&gt;<a class="code" href="structpnp__state.html#o9">rotation</a>,
00260                   COLUMN_length, pnp_state-&gt;<a class="code" href="structpnp__state.html#o13">length</a>,
00261                   COLUMN_width, pnp_state-&gt;<a class="code" href="structpnp__state.html#o12">width</a>,
00262                   COLUMN_shape, pnp_state-&gt;<a class="code" href="structpnp__state.html#o11">shape</a>,
00263             COLUMN_COMMENT, pnp_state-&gt;<a class="code" href="structpnp__state.html#o10">comment</a>,
00264                COLUMN_NO_FILES_FOUND, FALSE,
00265                -1);
00266                         
00267             gtk_list_store_append (GTK_LIST_STORE(<a class="code" href="search__file_8c.html#a0">completion_model</a>), &amp;interface.<a class="code" href="struct__InterfaceStruct.html#o20">iter</a>); 
00268             gtk_list_store_set (GTK_LIST_STORE(<a class="code" href="search__file_8c.html#a0">completion_model</a>), &amp;interface.<a class="code" href="struct__InterfaceStruct.html#o20">iter</a>,
00269                0, pnp_state-&gt;<a class="code" href="structpnp__state.html#o0">designator</a>, 
00270                1, pnp_state-&gt;<a class="code" href="structpnp__state.html#o10">comment</a>,
00271                 -1);
00272         }    
00273     }   
00274     gerb_transf_free(tr_rot);       
00275     <span class="keywordflow">return</span> pnp_state0; <span class="comment">/* return the FIRST list node */</span>
00276 }
00277 
00279 <span class="keywordtype">void</span> 
<a name="l00280"></a><a class="code" href="search_8c.html#a4">00280</a> <a class="code" href="search_8c.html#a4">free_pnp_state</a>(<a class="code" href="structpnp__state.html">pnp_state_t</a> *<a class="code" href="structpnp__state.html">pnp_state</a>)
00281 {
00282     <a class="code" href="structpnp__state.html">pnp_state_t</a> *pnp_next;
00283    
00284     <span class="keywordflow">while</span> (pnp_state != NULL) {
00285        pnp_next = pnp_state-&gt;<a class="code" href="structpnp__state.html#o15">next</a>;
00286         free(pnp_state);
00287         pnp_state = pnp_next;
00288     }
00289        
00290     <span class="keywordflow">return</span>;
00291 } <span class="comment">/* free_pnp_state */</span>
00292 
00293 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Oct 13 16:09:21 2004 for gerbv by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.8-20040928 </small></address>
</body>
</html>
