<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gerbv: src/gerber.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8-20040928 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a></div>
<h1>gerber.c</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * gEDA - GNU Electronic Design Automation</span>
00003 <span class="comment"> * This is a part of gerbv</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> *   Copyright (C) 2000-2003 Stefan Petersen (spe@stacken.kth.se)</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> * $Id$</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
00010 <span class="comment"> * it under the terms of the GNU General Public License as published by</span>
00011 <span class="comment"> * the Free Software Foundation; either version 2 of the License, or</span>
00012 <span class="comment"> * (at your option) any later version.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
00015 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00016 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00017 <span class="comment"> * GNU General Public License for more details.</span>
00018 <span class="comment"> *</span>
00019 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
00020 <span class="comment"> * along with this program; if not, write to the Free Software</span>
00021 <span class="comment"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA</span>
00022 <span class="comment"> */</span>
00023 
00024 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00025 <span class="preprocessor">#include &lt;string.h&gt;</span>
00026 <span class="preprocessor">#include &lt;math.h&gt;</span>  <span class="comment">/* pow() */</span>
00027 <span class="preprocessor">#include &lt;glib.h&gt;</span>
00028 <span class="preprocessor">#include &lt;locale.h&gt;</span>
00029 
00030 <span class="preprocessor">#include "gerber.h"</span>
00031 <span class="preprocessor">#include "gerb_error.h"</span>
00032 
00033 <span class="preprocessor">#define NOT_IMPL(fd, s) do { \</span>
00034 <span class="preprocessor">                             GERB_MESSAGE("Not Implemented:%s\n", s); \</span>
00035 <span class="preprocessor">                             while (gerb_fgetc(fd) != (int)'*'); \</span>
00036 <span class="preprocessor">                           } while(0)</span>
00037 <span class="preprocessor"></span>       
00038 
00039 <span class="preprocessor">#define A2I(a,b) (((a &amp; 0xff) &lt;&lt; 8) + (b &amp; 0xff))</span>
00040 <span class="preprocessor"></span>
00041 <span class="keyword">typedef</span> <span class="keyword">struct </span>gerb_state {
00042     <span class="keyword">enum</span> unit_t unit;
00043     <span class="keywordtype">int</span> curr_x;
00044     <span class="keywordtype">int</span> curr_y;
00045     <span class="keywordtype">int</span> prev_x;
00046     <span class="keywordtype">int</span> prev_y;
00047     <span class="keywordtype">int</span> delta_cp_x;
00048     <span class="keywordtype">int</span> delta_cp_y;
00049     <span class="keywordtype">int</span> curr_aperture;
00050     <span class="keywordtype">int</span> changed;
00051     <span class="keyword">enum</span> polarity_t layer_polarity;
00052     <span class="keyword">enum</span> aperture_state_t aperture_state;
00053     <span class="keyword">enum</span> interpolation_t interpolation;
00054     <span class="keyword">enum</span> interpolation_t prev_interpolation;
00055     gerb_net_t *parea_start_node;
00056     <span class="keywordtype">char</span> *curr_layername;
00057     <span class="keywordtype">int</span> in_parea_fill;
00058     <span class="keywordtype">int</span> mq_on;
00059 } gerb_state_t;
00060 
00061 
00062 <span class="comment">/* Local function prototypes */</span>
00063 <span class="keyword">static</span> <span class="keywordtype">void</span> parse_G_code(gerb_file_t *fd, gerb_state_t *state, 
00064                       gerb_format_t *format);
00065 <span class="keyword">static</span> <span class="keywordtype">void</span> parse_D_code(gerb_file_t *fd, gerb_state_t *state);
00066 <span class="keyword">static</span> <span class="keywordtype">int</span> parse_M_code(gerb_file_t *fd);
00067 <span class="keyword">static</span> <span class="keywordtype">void</span> parse_rs274x(gerb_file_t *fd, gerb_image_t *image, 
00068                       gerb_state_t *state);
00069 <span class="keyword">static</span> <span class="keywordtype">int</span> parse_aperture_definition(gerb_file_t *fd, 
00070                                  gerb_aperture_t *aperture,
00071                                  amacro_t *amacro);
00072 <span class="keyword">static</span> <span class="keywordtype">void</span> calc_cirseg_sq(<span class="keyword">struct</span> gerb_net *net, <span class="keywordtype">int</span> cw, 
00073                         <span class="keywordtype">double</span> delta_cp_x, <span class="keywordtype">double</span> delta_cp_y);
00074 <span class="keyword">static</span> <span class="keywordtype">void</span> calc_cirseg_mq(<span class="keyword">struct</span> gerb_net *net, <span class="keywordtype">int</span> cw, 
00075                         <span class="keywordtype">double</span> delta_cp_x, <span class="keywordtype">double</span> delta_cp_y);
00076 <span class="keyword">static</span> gerb_net_t *gen_circle_segments(gerb_net_t *curr_net,
00077                                    <span class="keywordtype">int</span> cw, <span class="keywordtype">int</span> *nuf_pcorners);
00078 
00079 gerb_image_t *
00080 parse_gerb(gerb_file_t *fd)
00081 {
00082     gerb_state_t *state = NULL;
00083     gerb_image_t *image = NULL;
00084     gerb_net_t *curr_net = NULL;
00085     <span class="keywordtype">int</span> read, coord, len;
00086     <span class="keywordtype">double</span> x_scale = 0.0, y_scale = 0.0;
00087     <span class="keywordtype">double</span> delta_cp_x = 0.0, delta_cp_y = 0.0;
00088     <span class="keywordtype">double</span> aperture_size;
00089     <span class="keywordtype">double</span> scale;
00090     
00091     <span class="comment">/* added by t.motylewski@bfad.de</span>
00092 <span class="comment">     * many locales redefine "." as "," and so on, </span>
00093 <span class="comment">     * so sscanf and strtod has problems when</span>
00094 <span class="comment">     * reading files using %f format */</span>
00095     setlocale(LC_NUMERIC, <span class="stringliteral">"C"</span> );
00096 
00097     
00098     state = (gerb_state_t *)malloc(<span class="keyword">sizeof</span>(gerb_state_t));
00099     <span class="keywordflow">if</span> (state == NULL)
00100        GERB_FATAL_ERROR(<span class="stringliteral">"malloc state failed\n"</span>);
00101 
00102     <span class="comment">/*</span>
00103 <span class="comment">     * Set some defaults</span>
00104 <span class="comment">     */</span>
00105     memset((<span class="keywordtype">void</span> *)state, 0, <span class="keyword">sizeof</span>(gerb_state_t));
00106     state-&gt;layer_polarity = DARK;
00107 
00108     <span class="comment">/* </span>
00109 <span class="comment">     * "Inches are assumed if units are not specified"</span>
00110 <span class="comment">     * rs274xrevd_e.pdf, p. 39</span>
00111 <span class="comment">     */</span>
00112     state-&gt;unit = INCH;
00113 
00114     <span class="comment">/* </span>
00115 <span class="comment">     * Create new image</span>
00116 <span class="comment">     */</span>
00117     image = new_gerb_image(image);
00118     <span class="keywordflow">if</span> (image == NULL)
00119        GERB_FATAL_ERROR(<span class="stringliteral">"malloc image failed\n"</span>);
00120     curr_net = image-&gt;netlist;
00121 
00122     <span class="comment">/*</span>
00123 <span class="comment">     * Start parsing</span>
00124 <span class="comment">     */</span>
00125     <span class="keywordflow">while</span> ((read = gerb_fgetc(fd)) != EOF) {
00126        <span class="keywordflow">switch</span> ((char)(read &amp; 0xff)) {
00127        <span class="keywordflow">case</span> <span class="charliteral">'G'</span>:
00128            parse_G_code(fd, state, image-&gt;format);
00129            <span class="keywordflow">break</span>;
00130        <span class="keywordflow">case</span> <span class="charliteral">'D'</span>:
00131            parse_D_code(fd, state);
00132            <span class="keywordflow">break</span>;
00133        <span class="keywordflow">case</span> <span class="charliteral">'M'</span>:
00134            <span class="keywordflow">switch</span>(parse_M_code(fd)) {
00135            <span class="keywordflow">case</span> 1 :
00136            <span class="keywordflow">case</span> 2 :
00137            <span class="keywordflow">case</span> 3 :
00138               free(state);
00139               <span class="keywordflow">return</span> image;
00140               <span class="keywordflow">break</span>;
00141            <span class="keywordflow">default</span>:
00142               GERB_FATAL_ERROR(<span class="stringliteral">"Strange M code found.\n"</span>);
00143            }
00144            <span class="keywordflow">break</span>;
00145        <span class="keywordflow">case</span> <span class="charliteral">'X'</span>:
00146            coord = gerb_fgetint(fd, &amp;len);
00147            <span class="keywordflow">if</span> (image-&gt;format &amp;&amp; image-&gt;format-&gt;omit_zeros == TRAILING) {
00148 
00149               <span class="keywordflow">switch</span> ((image-&gt;format-&gt;x_int + image-&gt;format-&gt;x_dec) - len) {
00150               <span class="keywordflow">case</span> 5:
00151                   coord *= 10;
00152               <span class="keywordflow">case</span> 4:
00153                   coord *= 10;
00154               <span class="keywordflow">case</span> 3:
00155                   coord *= 10;
00156               <span class="keywordflow">case</span> 2:
00157                   coord *= 10;
00158               <span class="keywordflow">case</span> 1:
00159                   coord *= 10;
00160                   <span class="keywordflow">break</span>;
00161               <span class="keywordflow">default</span>:
00162                   ;
00163               }
00164            }
00165            <span class="keywordflow">if</span> (image-&gt;format &amp;&amp; (image-&gt;format-&gt;coordinate==INCREMENTAL))
00166                state-&gt;curr_x += coord;
00167            <span class="keywordflow">else</span>
00168                state-&gt;curr_x = coord;
00169            state-&gt;changed = 1;
00170            <span class="keywordflow">break</span>;
00171        <span class="keywordflow">case</span> <span class="charliteral">'Y'</span>:
00172            coord = gerb_fgetint(fd, &amp;len);
00173            <span class="keywordflow">if</span> (image-&gt;format &amp;&amp; image-&gt;format-&gt;omit_zeros == TRAILING) {
00174 
00175               <span class="keywordflow">switch</span> ((image-&gt;format-&gt;y_int + image-&gt;format-&gt;y_dec) - len) {
00176               <span class="keywordflow">case</span> 5:
00177                   coord *= 10;
00178               <span class="keywordflow">case</span> 4:
00179                   coord *= 10;
00180               <span class="keywordflow">case</span> 3:
00181                   coord *= 10;
00182               <span class="keywordflow">case</span> 2:
00183                   coord *= 10;
00184               <span class="keywordflow">case</span> 1:
00185                   coord *= 10;
00186                   <span class="keywordflow">break</span>;
00187               <span class="keywordflow">default</span>:
00188                   ;
00189               }
00190            }
00191            <span class="keywordflow">if</span> (image-&gt;format &amp;&amp; (image-&gt;format-&gt;coordinate==INCREMENTAL))
00192                state-&gt;curr_y += coord;
00193            <span class="keywordflow">else</span>
00194                state-&gt;curr_y = coord;
00195            state-&gt;changed = 1;
00196            <span class="keywordflow">break</span>;
00197        <span class="keywordflow">case</span> <span class="charliteral">'I'</span>:
00198            state-&gt;delta_cp_x = gerb_fgetint(fd, NULL);
00199            state-&gt;changed = 1;
00200            <span class="keywordflow">break</span>;
00201        <span class="keywordflow">case</span> <span class="charliteral">'J'</span>:
00202            state-&gt;delta_cp_y = gerb_fgetint(fd, NULL);
00203            state-&gt;changed = 1;
00204            <span class="keywordflow">break</span>;
00205        <span class="keywordflow">case</span> <span class="charliteral">'%'</span>:
00206            parse_rs274x(fd, image, state);
00207            <span class="keywordflow">while</span> (gerb_fgetc(fd) != <span class="charliteral">'%'</span>);
00208            <span class="keywordflow">break</span>;
00209        <span class="keywordflow">case</span> <span class="charliteral">'*'</span>:
00210            <span class="keywordflow">if</span> (state-&gt;changed == 0) <span class="keywordflow">break</span>;
00211            state-&gt;changed = 0;
00212 
00213            curr_net-&gt;next = (gerb_net_t *)malloc(<span class="keyword">sizeof</span>(gerb_net_t));
00214            curr_net = curr_net-&gt;next;
00215            memset((<span class="keywordtype">void</span> *)curr_net, 0, <span class="keyword">sizeof</span>(gerb_net_t));
00216 
00217            <span class="comment">/*</span>
00218 <span class="comment">            * Scale to given coordinate format</span>
00219 <span class="comment">            * XXX only "omit leading zeros".</span>
00220 <span class="comment">            */</span>
00221            <span class="keywordflow">if</span> (image &amp;&amp; image-&gt;format ){
00222               x_scale = pow(10.0, (<span class="keywordtype">double</span>)image-&gt;format-&gt;x_dec);
00223               y_scale = pow(10.0, (<span class="keywordtype">double</span>)image-&gt;format-&gt;y_dec);
00224            }
00225            
00226            curr_net-&gt;start_x = (double)state-&gt;prev_x / x_scale;
00227            curr_net-&gt;start_y = (double)state-&gt;prev_y / y_scale;
00228            curr_net-&gt;stop_x = (double)state-&gt;curr_x / x_scale;
00229            curr_net-&gt;stop_y = (double)state-&gt;curr_y / y_scale;
00230            delta_cp_x = (double)state-&gt;delta_cp_x / x_scale;
00231            delta_cp_y = (double)state-&gt;delta_cp_y / y_scale;
00232 
00233 
00234            <span class="keywordflow">switch</span> (state-&gt;interpolation) {
00235            <span class="keywordflow">case</span> CW_CIRCULAR :
00236               curr_net-&gt;cirseg = (gerb_cirseg_t *)malloc(<span class="keyword">sizeof</span>(gerb_cirseg_t));
00237               memset((<span class="keywordtype">void</span> *)curr_net-&gt;cirseg, 0, <span class="keyword">sizeof</span>(gerb_cirseg_t));
00238               <span class="keywordflow">if</span> (state-&gt;mq_on)
00239                   calc_cirseg_mq(curr_net, 1, delta_cp_x, delta_cp_y);
00240               <span class="keywordflow">else</span>
00241                   calc_cirseg_sq(curr_net, 1, delta_cp_x, delta_cp_y);
00242               <span class="keywordflow">break</span>;
00243            <span class="keywordflow">case</span> CCW_CIRCULAR :
00244               curr_net-&gt;cirseg = (gerb_cirseg_t *)malloc(<span class="keyword">sizeof</span>(gerb_cirseg_t));
00245               memset((<span class="keywordtype">void</span> *)curr_net-&gt;cirseg, 0, <span class="keyword">sizeof</span>(gerb_cirseg_t));
00246               <span class="keywordflow">if</span> (state-&gt;mq_on)
00247                   calc_cirseg_mq(curr_net, 0, delta_cp_x, delta_cp_y);
00248               <span class="keywordflow">else</span>
00249                   calc_cirseg_sq(curr_net, 0, delta_cp_x, delta_cp_y);
00250               <span class="keywordflow">break</span>;
00251            <span class="keywordflow">case</span> PAREA_START :
00252               <span class="comment">/* </span>
00253 <span class="comment">               * To be able to get back and fill in number of polygon corners</span>
00254 <span class="comment">               */</span>
00255               state-&gt;parea_start_node = curr_net;
00256               state-&gt;in_parea_fill = 1;
00257               <span class="keywordflow">break</span>;
00258            <span class="keywordflow">case</span> PAREA_END :
00259               state-&gt;parea_start_node = NULL;
00260               state-&gt;in_parea_fill = 0;
00261               <span class="keywordflow">break</span>;
00262            <span class="keywordflow">default</span> :
00263               <span class="keywordflow">break</span>;
00264            }
00265 
00266            <span class="comment">/* </span>
00267 <span class="comment">            * Count number of points in Polygon Area </span>
00268 <span class="comment">            */</span>
00269            <span class="keywordflow">if</span> (state-&gt;in_parea_fill &amp;&amp; state-&gt;parea_start_node) {
00270               <span class="comment">/* </span>
00271 <span class="comment">               * "...all lines drawn with D01 are considered edges of the</span>
00272 <span class="comment">               * polygon. D02 closes and fills the polygon."</span>
00273 <span class="comment">               * p.49 rs274xrevd_e.pdf</span>
00274 <span class="comment">               * D02 -&gt; state-&gt;aperture_state == OFF</span>
00275 <span class="comment">               */</span>
00276               <span class="keywordflow">if</span> (state-&gt;aperture_state == OFF &amp;&amp;
00277                   state-&gt;interpolation != PAREA_START) {
00278                   curr_net-&gt;interpolation = PAREA_END;
00279                   curr_net-&gt;next = (gerb_net_t *)malloc(<span class="keyword">sizeof</span>(gerb_net_t));
00280                   curr_net = curr_net-&gt;next;
00281                   memset((<span class="keywordtype">void</span> *)curr_net, 0, <span class="keyword">sizeof</span>(gerb_net_t));
00282 
00283                   curr_net-&gt;interpolation = PAREA_START;
00284                   state-&gt;parea_start_node = curr_net;
00285                   curr_net-&gt;next = (gerb_net_t *)malloc(<span class="keyword">sizeof</span>(gerb_net_t));
00286                   curr_net = curr_net-&gt;next;
00287                   memset((<span class="keywordtype">void</span> *)curr_net, 0, <span class="keyword">sizeof</span>(gerb_net_t));
00288 
00289                   curr_net-&gt;start_x = (double)state-&gt;prev_x / x_scale;
00290                   curr_net-&gt;start_y = (double)state-&gt;prev_y / y_scale;
00291                   curr_net-&gt;stop_x = (double)state-&gt;curr_x / x_scale;
00292                   curr_net-&gt;stop_y = (double)state-&gt;curr_y / y_scale;
00293               }
00294 
00295               <span class="comment">/*</span>
00296 <span class="comment">               * if this outline is circular, approximate it with short lines</span>
00297 <span class="comment">               */</span>
00298               <span class="keywordflow">if</span> (curr_net-&gt;cirseg) {
00299                   curr_net-&gt;interpolation = state-&gt;interpolation;
00300                   curr_net-&gt;layer_polarity = state-&gt;layer_polarity;
00301                   curr_net-&gt;unit = state-&gt;unit;      
00302                   curr_net = gen_circle_segments(curr_net, state-&gt;interpolation == CW_CIRCULAR, &amp;(state-&gt;parea_start_node-&gt;nuf_pcorners));
00303               }
00304 
00305               state-&gt;parea_start_node-&gt;nuf_pcorners++;
00306            }
00307 
00308            curr_net-&gt;interpolation = state-&gt;interpolation;
00309 
00310            <span class="comment">/*</span>
00311 <span class="comment">            * If we detected the end of Polygon Area Fill we go back to</span>
00312 <span class="comment">            * the interpolation we had before that.</span>
00313 <span class="comment">            * Also if we detected any of the quadrant flags, since some</span>
00314 <span class="comment">            * gerbers don't reset the interpolation (EagleCad again).</span>
00315 <span class="comment">            */</span>
00316            <span class="keywordflow">if</span> ((state-&gt;interpolation == PAREA_START) ||
00317               (state-&gt;interpolation == PAREA_END))
00318               state-&gt;interpolation = state-&gt;prev_interpolation;
00319 
00320            <span class="comment">/*</span>
00321 <span class="comment">            * Save layer polarity and unit</span>
00322 <span class="comment">            */</span>
00323            curr_net-&gt;layer_polarity = state-&gt;layer_polarity;
00324            curr_net-&gt;unit = state-&gt;unit;      
00325 
00326            state-&gt;delta_cp_x = 0.0;
00327            state-&gt;delta_cp_y = 0.0;
00328            curr_net-&gt;aperture = state-&gt;curr_aperture;
00329            curr_net-&gt;aperture_state = state-&gt;aperture_state;
00330 
00331            <span class="comment">/* </span>
00332 <span class="comment">            * Make sure we don't hit any undefined aperture</span>
00333 <span class="comment">            * In macros the first parameter could be basically anything</span>
00334 <span class="comment">            */</span>
00335            <span class="keywordflow">if</span> ((curr_net-&gt;aperture != 0) &amp;&amp; 
00336               (image-&gt;aperture[curr_net-&gt;aperture] != NULL) &amp;&amp;
00337               (image-&gt;aperture[curr_net-&gt;aperture]-&gt;type != MACRO))
00338               aperture_size = image-&gt;aperture[curr_net-&gt;aperture]-&gt;parameter[0];
00339            <span class="keywordflow">else</span> 
00340               aperture_size = 0.0;
00341 
00342            <span class="comment">/*</span>
00343 <span class="comment">            * For next round we save the current position as</span>
00344 <span class="comment">            * the previous position</span>
00345 <span class="comment">            */</span>
00346            state-&gt;prev_x = state-&gt;curr_x;
00347            state-&gt;prev_y = state-&gt;curr_y;
00348 
00349            <span class="comment">/*</span>
00350 <span class="comment">            * If we have an aperture defined at the moment we find </span>
00351 <span class="comment">            * min and max of image with compensation for mm.</span>
00352 <span class="comment">            */</span>
00353            <span class="keywordflow">if</span> ((curr_net-&gt;aperture == 0) &amp;&amp; !state-&gt;in_parea_fill) 
00354               <span class="keywordflow">break</span>;
00355 
00356            <span class="keywordflow">if</span> (curr_net-&gt;unit == MM)
00357               scale = 25.4;
00358            <span class="keywordflow">else</span> 
00359               scale = 1.0;
00360 
00361            <span class="keywordflow">if</span> (image-&gt;info-&gt;min_x &gt; curr_net-&gt;stop_x)
00362               image-&gt;info-&gt;min_x = (curr_net-&gt;stop_x - aperture_size) / scale;
00363            <span class="keywordflow">if</span> (image-&gt;info-&gt;min_y &gt; curr_net-&gt;stop_y)
00364               image-&gt;info-&gt;min_y = (curr_net-&gt;stop_y - aperture_size) / scale;
00365            <span class="keywordflow">if</span> (image-&gt;info-&gt;max_x &lt; curr_net-&gt;stop_x)
00366               image-&gt;info-&gt;max_x = (curr_net-&gt;stop_x + aperture_size) / scale;
00367            <span class="keywordflow">if</span> (image-&gt;info-&gt;max_y &lt; curr_net-&gt;stop_y)
00368               image-&gt;info-&gt;max_y = (curr_net-&gt;stop_y + aperture_size) / scale;
00369            
00370            <span class="keywordflow">break</span>;
00371        <span class="keywordflow">case</span> 10 :   <span class="comment">/* White space */</span>
00372        <span class="keywordflow">case</span> 13 :
00373        <span class="keywordflow">case</span> <span class="charliteral">' '</span> :
00374        <span class="keywordflow">case</span> <span class="charliteral">'\t'</span> :
00375            <span class="keywordflow">break</span>;
00376        <span class="keywordflow">default</span>:
00377            GERB_COMPILE_ERROR(<span class="stringliteral">"Found unknown character (whitespace?) %c[%d]\n"</span>, read, read);
00378        }
00379     }
00380     
00381     GERB_COMPILE_ERROR(<span class="stringliteral">"File is missing gerber End-Of-File\n"</span>);
00382     
00383     <span class="keywordflow">return</span> image;
00384 } <span class="comment">/* parse_gerb */</span>
00385 
00386 
00387 <span class="keyword">static</span> <span class="keywordtype">void</span> 
00388 parse_G_code(gerb_file_t *fd, gerb_state_t *state, gerb_format_t *format)
00389 {
00390     <span class="keywordtype">int</span>  op_int;
00391 
00392     op_int=gerb_fgetint(fd, NULL);
00393     
00394     <span class="keywordflow">switch</span>(op_int) {
00395     <span class="keywordflow">case</span> 0:  <span class="comment">/* Move */</span>
00396        <span class="comment">/* Is this doing anything really? */</span>
00397        <span class="keywordflow">break</span>;
00398     <span class="keywordflow">case</span> 1:  <span class="comment">/* Linear Interpolation (1X scale) */</span>
00399        state-&gt;interpolation = LINEARx1;
00400        <span class="keywordflow">break</span>;
00401     <span class="keywordflow">case</span> 2:  <span class="comment">/* Clockwise Linear Interpolation */</span>
00402        state-&gt;interpolation = CW_CIRCULAR;
00403        <span class="keywordflow">break</span>;
00404     <span class="keywordflow">case</span> 3:  <span class="comment">/* Counter Clockwise Linear Interpolation */</span>
00405        state-&gt;interpolation = CCW_CIRCULAR;
00406        <span class="keywordflow">break</span>;
00407     <span class="keywordflow">case</span> 4:  <span class="comment">/* Ignore Data Block */</span>
00408        <span class="comment">/* Don't do anything, just read 'til * */</span>
00409        <span class="keywordflow">while</span> (gerb_fgetc(fd) != <span class="charliteral">'*'</span>);
00410        <span class="keywordflow">break</span>;
00411     <span class="keywordflow">case</span> 10: <span class="comment">/* Linear Interpolation (10X scale) */</span>
00412        state-&gt;interpolation = LINEARx10;
00413        <span class="keywordflow">break</span>;
00414     <span class="keywordflow">case</span> 11: <span class="comment">/* Linear Interpolation (0.1X scale) */</span>
00415        state-&gt;interpolation = LINEARx01;
00416        <span class="keywordflow">break</span>;
00417     <span class="keywordflow">case</span> 12: <span class="comment">/* Linear Interpolation (0.01X scale) */</span>
00418        state-&gt;interpolation = LINEARx001;
00419        <span class="keywordflow">break</span>;
00420     <span class="keywordflow">case</span> 36: <span class="comment">/* Turn on Polygon Area Fill */</span>
00421        state-&gt;prev_interpolation = state-&gt;interpolation;
00422        state-&gt;interpolation = PAREA_START;
00423        state-&gt;changed = 1;
00424        <span class="keywordflow">break</span>;
00425     <span class="keywordflow">case</span> 37: <span class="comment">/* Turn off Polygon Area Fill */</span>
00426        state-&gt;interpolation = PAREA_END;
00427        state-&gt;changed = 1;
00428        <span class="keywordflow">break</span>;
00429     <span class="keywordflow">case</span> 54: <span class="comment">/* Tool prepare */</span>
00430        <span class="comment">/* XXX Maybe uneccesary??? */</span>
00431        <span class="keywordflow">if</span> (gerb_fgetc(fd) == <span class="charliteral">'D'</span>)
00432            state-&gt;curr_aperture = gerb_fgetint(fd, NULL);
00433        <span class="keywordflow">else</span>
00434            GERB_COMPILE_WARNING(<span class="stringliteral">"Strange code after G54\n"</span>);
00435        <span class="keywordflow">break</span>;
00436     <span class="keywordflow">case</span> 55: <span class="comment">/* Prepare for flash */</span>
00437        <span class="keywordflow">break</span>;
00438     <span class="keywordflow">case</span> 70: <span class="comment">/* Specify inches */</span>
00439        state-&gt;unit = INCH;
00440        <span class="keywordflow">break</span>;
00441     <span class="keywordflow">case</span> 71: <span class="comment">/* Specify millimeters */</span>
00442        state-&gt;unit = MM;
00443        <span class="keywordflow">break</span>;
00444     <span class="keywordflow">case</span> 74: <span class="comment">/* Disable 360 circular interpolation */</span>
00445        state-&gt;mq_on = 0;
00446        <span class="keywordflow">break</span>;
00447     <span class="keywordflow">case</span> 75: <span class="comment">/* Enable 360 circular interpolation */</span>
00448        state-&gt;mq_on = 1;
00449        <span class="keywordflow">break</span>;
00450     <span class="keywordflow">case</span> 90: <span class="comment">/* Specify absolut format */</span>
00451        <span class="keywordflow">if</span> (format) format-&gt;coordinate = ABSOLUTE;
00452        <span class="keywordflow">break</span>;
00453     <span class="keywordflow">case</span> 91: <span class="comment">/* Specify incremental format */</span>
00454        <span class="keywordflow">if</span> (format) format-&gt;coordinate = INCREMENTAL;
00455        <span class="keywordflow">break</span>;
00456     <span class="keywordflow">default</span>:
00457        GERB_COMPILE_ERROR(<span class="stringliteral">"Strange/unhandled G code : %d\n"</span>, op_int);
00458     }
00459     
00460     <span class="keywordflow">return</span>;
00461 } <span class="comment">/* parse_G_code */</span>
00462 
00463 
00464 <span class="keyword">static</span> <span class="keywordtype">void</span> 
00465 parse_D_code(gerb_file_t *fd, gerb_state_t *state)
00466 {
00467     <span class="keywordtype">int</span> a;
00468     
00469     a = gerb_fgetint(fd, NULL);
00470     <span class="keywordflow">switch</span>(a) {
00471     <span class="keywordflow">case</span> 1 : <span class="comment">/* Exposure on */</span>
00472        state-&gt;aperture_state = ON;
00473        state-&gt;changed = 1;
00474        <span class="keywordflow">break</span>;
00475     <span class="keywordflow">case</span> 2 : <span class="comment">/* Exposure off */</span>
00476        state-&gt;aperture_state = OFF;
00477        state-&gt;changed = 1;
00478        <span class="keywordflow">break</span>;
00479     <span class="keywordflow">case</span> 3 : <span class="comment">/* Flash aperture */</span>
00480        state-&gt;aperture_state = FLASH;
00481        state-&gt;changed = 1;
00482        <span class="keywordflow">break</span>;
00483     <span class="keywordflow">default</span>: <span class="comment">/* Aperture in use */</span>
00484        <span class="keywordflow">if</span> ((a &gt;= APERTURE_MIN) &amp;&amp; (a &lt;= APERTURE_MAX)) 
00485            state-&gt;curr_aperture = a;
00486        <span class="keywordflow">else</span>
00487            GERB_COMPILE_ERROR(<span class="stringliteral">"Aperture out of bounds:%d\n"</span>, a);
00488        state-&gt;changed = 0;
00489     }
00490     
00491     <span class="keywordflow">return</span>;
00492 } <span class="comment">/* parse_D_code */</span>
00493 
00494 
00495 <span class="keyword">static</span> <span class="keywordtype">int</span>
00496 parse_M_code(gerb_file_t *fd)
00497 {
00498     <span class="keywordtype">int</span> op_int;
00499 
00500     op_int=gerb_fgetint(fd, NULL);
00501 
00502     <span class="keywordflow">switch</span> (op_int) {
00503     <span class="keywordflow">case</span> 0:  <span class="comment">/* Program stop */</span>
00504        <span class="keywordflow">return</span> 1;
00505     <span class="keywordflow">case</span> 1:  <span class="comment">/* Optional stop */</span>
00506        <span class="keywordflow">return</span> 2;
00507     <span class="keywordflow">case</span> 2:  <span class="comment">/* End of program */</span>
00508        <span class="keywordflow">return</span> 3;
00509     <span class="keywordflow">default</span>:
00510        GERB_COMPILE_ERROR(<span class="stringliteral">"Strange M code [%d]\n"</span>, op_int);
00511     }
00512     <span class="keywordflow">return</span> 0;
00513 } <span class="comment">/* parse_M_code */</span>
00514 
00515 
00516 <span class="keyword">static</span> <span class="keywordtype">void</span> 
00517 parse_rs274x(gerb_file_t *fd, gerb_image_t *image, gerb_state_t *state)
00518 {
00519     <span class="keywordtype">int</span> op[2];
00520     <span class="keywordtype">char</span> str[3];
00521     <span class="keywordtype">int</span> tmp;
00522     gerb_aperture_t *a = NULL;
00523     amacro_t *tmp_amacro;
00524     <span class="keywordtype">int</span> ano;
00525     
00526     op[0] = gerb_fgetc(fd);
00527     op[1] = gerb_fgetc(fd);
00528     
00529     <span class="keywordflow">if</span> ((op[0] == EOF) || (op[1] == EOF))
00530        GERB_COMPILE_ERROR(<span class="stringliteral">"Unexpected EOF found.\n"</span>);
00531 
00532     <span class="keywordflow">switch</span> (A2I(op[0], op[1])){
00533 
00534       <span class="comment">/* Directive parameters */</span>
00535     <span class="keywordflow">case</span> A2I(<span class="charliteral">'A'</span>,<span class="charliteral">'S'</span>): <span class="comment">/* Axis Select */</span>
00536        op[0] = gerb_fgetc(fd);
00537        op[1] = gerb_fgetc(fd);
00538        
00539        <span class="keywordflow">if</span> ((op[0] == EOF) || (op[1] == EOF))
00540            GERB_COMPILE_ERROR(<span class="stringliteral">"Unexpected EOF found.\n"</span>);
00541        
00542        <span class="keywordflow">if</span> (((op[0] == <span class="charliteral">'A'</span>) &amp;&amp; (op[1] == <span class="charliteral">'Y'</span>)) ||
00543            ((op[0] == <span class="charliteral">'B'</span>) &amp;&amp; (op[1] == <span class="charliteral">'X'</span>))) {
00544            NOT_IMPL(fd, <span class="stringliteral">"%MI with reversed axis not supported%"</span>);
00545            <span class="keywordflow">break</span>;
00546        }
00547 
00548        op[0] = gerb_fgetc(fd);
00549        op[1] = gerb_fgetc(fd);
00550 
00551        <span class="keywordflow">if</span> ((op[0] == EOF) || (op[1] == EOF))
00552            GERB_COMPILE_ERROR(<span class="stringliteral">"Unexpected EOF found.\n"</span>);
00553 
00554        <span class="keywordflow">if</span> (((op[0] == <span class="charliteral">'A'</span>) &amp;&amp; (op[1] == <span class="charliteral">'Y'</span>)) ||
00555            ((op[0] == <span class="charliteral">'B'</span>) &amp;&amp; (op[1] == <span class="charliteral">'X'</span>))) {
00556            NOT_IMPL(fd, <span class="stringliteral">"%MI with reversed axis not supported%"</span>);
00557            <span class="keywordflow">break</span>;
00558        }
00559        <span class="keywordflow">break</span>;
00560     <span class="keywordflow">case</span> A2I(<span class="charliteral">'F'</span>,<span class="charliteral">'S'</span>): <span class="comment">/* Format Statement */</span>
00561        image-&gt;format = (gerb_format_t *)malloc(sizeof(gerb_format_t));
00562        <span class="keywordflow">if</span> (image-&gt;format == NULL) 
00563            GERB_FATAL_ERROR(<span class="stringliteral">"Failed malloc for format\n"</span>);
00564        memset((<span class="keywordtype">void</span> *)image-&gt;format, 0, <span class="keyword">sizeof</span>(gerb_format_t));
00565        
00566        <span class="keywordflow">switch</span> (gerb_fgetc(fd)) {
00567        <span class="keywordflow">case</span> <span class="charliteral">'L'</span>:
00568            image-&gt;format-&gt;omit_zeros = LEADING;
00569            <span class="keywordflow">break</span>;
00570        <span class="keywordflow">case</span> <span class="charliteral">'T'</span>:
00571            image-&gt;format-&gt;omit_zeros = TRAILING;
00572            <span class="keywordflow">break</span>;
00573        <span class="keywordflow">case</span> <span class="charliteral">'D'</span>:
00574            image-&gt;format-&gt;omit_zeros = EXPLICIT;
00575            <span class="keywordflow">break</span>;
00576        <span class="keywordflow">default</span>:
00577            GERB_MESSAGE(<span class="stringliteral">"EagleCad bug detected: Defaults to omit leading zeroes\n"</span>);
00578            gerb_ungetc(fd);
00579            image-&gt;format-&gt;omit_zeros = LEADING;
00580        }
00581        
00582        <span class="keywordflow">switch</span> (gerb_fgetc(fd)) {
00583        <span class="keywordflow">case</span> <span class="charliteral">'A'</span>:
00584            image-&gt;format-&gt;coordinate = ABSOLUTE;
00585            <span class="keywordflow">break</span>;
00586        <span class="keywordflow">case</span> <span class="charliteral">'I'</span>:
00587            image-&gt;format-&gt;coordinate = INCREMENTAL;
00588            <span class="keywordflow">break</span>;
00589        <span class="keywordflow">default</span>:
00590            GERB_COMPILE_ERROR(<span class="stringliteral">"Format error: coordinate = %c\n"</span>, op[0]);
00591        }
00592 
00593        <span class="keywordflow">while</span>((op[0] = gerb_fgetc(fd)) != <span class="charliteral">'*'</span>) {
00594            <span class="keywordflow">switch</span> (op[0]) {
00595            <span class="keywordflow">case</span> <span class="charliteral">'N'</span>:
00596               op[0] = (char)gerb_fgetc(fd);
00597               image-&gt;format-&gt;lim_seqno = op[0] - <span class="charliteral">'0'</span>;
00598               <span class="keywordflow">break</span>;
00599            <span class="keywordflow">case</span> <span class="charliteral">'G'</span>:
00600               op[0] = (char)gerb_fgetc(fd);
00601               image-&gt;format-&gt;lim_gf = op[0] - <span class="charliteral">'0'</span>;
00602               <span class="keywordflow">break</span>;
00603            <span class="keywordflow">case</span> <span class="charliteral">'D'</span>:
00604               op[0] = (char)gerb_fgetc(fd);
00605               image-&gt;format-&gt;lim_pf = op[0] - <span class="charliteral">'0'</span>;
00606               <span class="keywordflow">break</span>;
00607            <span class="keywordflow">case</span> <span class="charliteral">'M'</span>:
00608               op[0] = (char)gerb_fgetc(fd);
00609               image-&gt;format-&gt;lim_mf = op[0] - <span class="charliteral">'0'</span>;
00610               <span class="keywordflow">break</span>;
00611            <span class="keywordflow">case</span> <span class="charliteral">'X'</span> :
00612               op[0] = gerb_fgetc(fd);
00613               <span class="keywordflow">if</span> ((op[0] &lt; <span class="charliteral">'0'</span>) || (op[0] &gt; <span class="charliteral">'6'</span>))
00614                   GERB_COMPILE_ERROR(<span class="stringliteral">"Illegal format size : %c\n"</span>, (<span class="keywordtype">char</span>)op[0]);
00615               image-&gt;format-&gt;x_int = op[0] - <span class="charliteral">'0'</span>;
00616               op[0] = gerb_fgetc(fd);
00617               <span class="keywordflow">if</span> ((op[0] &lt; <span class="charliteral">'0'</span>) || (op[0] &gt; <span class="charliteral">'6'</span>))
00618                   GERB_COMPILE_ERROR(<span class="stringliteral">"Illegal format size : %c\n"</span>, (<span class="keywordtype">char</span>)op[0]);
00619               image-&gt;format-&gt;x_dec = op[0] - <span class="charliteral">'0'</span>;
00620               <span class="keywordflow">break</span>;
00621            <span class="keywordflow">case</span> <span class="charliteral">'Y'</span>:
00622               op[0] = gerb_fgetc(fd);
00623               <span class="keywordflow">if</span> ((op[0] &lt; <span class="charliteral">'0'</span>) || (op[0] &gt; <span class="charliteral">'6'</span>))
00624                   GERB_COMPILE_ERROR(<span class="stringliteral">"Illegal format size : %c\n"</span>, (<span class="keywordtype">char</span>)op[0]);
00625               image-&gt;format-&gt;y_int = op[0] - <span class="charliteral">'0'</span>;
00626               op[0] = gerb_fgetc(fd);
00627               <span class="keywordflow">if</span> ((op[0] &lt; <span class="charliteral">'0'</span>) || (op[0] &gt; <span class="charliteral">'6'</span>))
00628                   GERB_COMPILE_ERROR(<span class="stringliteral">"Illegal format size : %c\n"</span>, (<span class="keywordtype">char</span>)op[0]);
00629               image-&gt;format-&gt;y_dec = op[0] - <span class="charliteral">'0'</span>;
00630               <span class="keywordflow">break</span>;
00631            <span class="keywordflow">default</span> :
00632               GERB_COMPILE_ERROR(<span class="stringliteral">"Not handled  type of format statement [%c]\n"</span>, op[0]);
00633            }
00634        }
00635        <span class="keywordflow">break</span>;
00636     <span class="keywordflow">case</span> A2I(<span class="charliteral">'M'</span>,<span class="charliteral">'I'</span>): <span class="comment">/* Mirror Image */</span>
00637        NOT_IMPL(fd, <span class="stringliteral">"%MI%"</span>);
00638        <span class="keywordflow">break</span>;
00639     <span class="keywordflow">case</span> A2I(<span class="charliteral">'M'</span>,<span class="charliteral">'O'</span>): <span class="comment">/* Mode of Units */</span>
00640 
00641        op[0] = gerb_fgetc(fd);
00642        op[1] = gerb_fgetc(fd);
00643        
00644        <span class="keywordflow">if</span> ((op[0] == EOF) || (op[1] == EOF))
00645            GERB_COMPILE_ERROR(<span class="stringliteral">"Unexpected EOF found.\n"</span>);
00646 
00647        <span class="keywordflow">switch</span> (A2I(op[0],op[1])) {
00648        <span class="keywordflow">case</span> A2I(<span class="charliteral">'I'</span>,<span class="charliteral">'N'</span>):
00649            state-&gt;unit = INCH;
00650            <span class="keywordflow">break</span>;
00651        <span class="keywordflow">case</span> A2I(<span class="charliteral">'M'</span>,<span class="charliteral">'M'</span>):
00652            state-&gt;unit = MM;
00653            <span class="keywordflow">break</span>;
00654        <span class="keywordflow">default</span>:
00655            GERB_COMPILE_ERROR(<span class="stringliteral">"Illegal unit:%c%c\n"</span>, op[0], op[1]);
00656        }
00657        <span class="keywordflow">break</span>;
00658     <span class="keywordflow">case</span> A2I(<span class="charliteral">'O'</span>,<span class="charliteral">'F'</span>): <span class="comment">/* Offset */</span>
00659        op[0] = gerb_fgetc(fd);
00660        <span class="keywordflow">while</span> (op[0] != <span class="charliteral">'*'</span>) {
00661            <span class="keywordflow">switch</span> (op[0]) {
00662            <span class="keywordflow">case</span> <span class="charliteral">'A'</span> :
00663               image-&gt;info-&gt;offset_a = gerb_fgetdouble(fd);
00664               <span class="keywordflow">break</span>;
00665            <span class="keywordflow">case</span> <span class="charliteral">'B'</span> :
00666               image-&gt;info-&gt;offset_b = gerb_fgetdouble(fd);
00667               <span class="keywordflow">break</span>;
00668            <span class="keywordflow">default</span> :
00669               GERB_COMPILE_ERROR(<span class="stringliteral">"Wrong character in offset:%c\n"</span>, op[0]);
00670            }
00671            op[0] = gerb_fgetc(fd);
00672        }
00673        <span class="keywordflow">return</span>;
00674     <span class="keywordflow">case</span> A2I(<span class="charliteral">'S'</span>,<span class="charliteral">'F'</span>): <span class="comment">/* Scale Factor */</span>
00675        if (gerb_fgetc(fd) == 'A')
00676            image-&gt;info-&gt;scale_factor_A = gerb_fgetdouble(fd);
00677        <span class="keywordflow">else</span> 
00678            gerb_ungetc(fd);
00679        <span class="keywordflow">if</span> (gerb_fgetc(fd) == <span class="charliteral">'B'</span>)
00680            image-&gt;info-&gt;scale_factor_B = gerb_fgetdouble(fd);
00681        <span class="keywordflow">else</span> 
00682            gerb_ungetc(fd);
00683        <span class="keywordflow">if</span> ((fabs(image-&gt;info-&gt;scale_factor_A - 1.0) &gt; 0.00001) ||
00684            (fabs(image-&gt;info-&gt;scale_factor_B - 1.0) &gt; 0.00001))
00685            NOT_IMPL(fd, <span class="stringliteral">"%SF% != 1.0"</span>);
00686        <span class="keywordflow">break</span>;
00687     <span class="keywordflow">case</span> A2I(<span class="charliteral">'I'</span>,<span class="charliteral">'C'</span>): <span class="comment">/* Input Code */</span>
00688        <span class="comment">/* Thanks to Stephen Adam for providing this information. As he writes:</span>
00689 <span class="comment">        *      btw, here's a logic puzzle for you.  If you need to</span>
00690 <span class="comment">        * read the gerber file to see how it's encoded, then</span>
00691 <span class="comment">        * how can you read it?</span>
00692 <span class="comment">        */</span>
00693        op[0] = gerb_fgetc(fd);
00694        op[1] = gerb_fgetc(fd);
00695        
00696        <span class="keywordflow">if</span> ((op[0] == EOF) || (op[1] == EOF))
00697            GERB_COMPILE_ERROR(<span class="stringliteral">"Unexpected EOF found.\n"</span>);
00698 
00699        <span class="keywordflow">switch</span> (A2I(op[0],op[1])) {
00700        <span class="keywordflow">case</span> A2I(<span class="charliteral">'A'</span>,<span class="charliteral">'S'</span>):
00701            image-&gt;info-&gt;encoding = ASCII;
00702            <span class="keywordflow">break</span>;
00703        <span class="keywordflow">case</span> A2I(<span class="charliteral">'E'</span>,<span class="charliteral">'B'</span>):
00704            image-&gt;info-&gt;encoding = EBCDIC;
00705            <span class="keywordflow">break</span>;
00706        <span class="keywordflow">case</span> A2I(<span class="charliteral">'B'</span>,<span class="charliteral">'C'</span>):
00707            image-&gt;info-&gt;encoding = BCD;
00708            <span class="keywordflow">break</span>;
00709        <span class="keywordflow">case</span> A2I(<span class="charliteral">'I'</span>,<span class="charliteral">'S'</span>):
00710            image-&gt;info-&gt;encoding = ISO_ASCII;
00711            <span class="keywordflow">break</span>;
00712        <span class="keywordflow">case</span> A2I(<span class="charliteral">'E'</span>,<span class="charliteral">'I'</span>):
00713            image-&gt;info-&gt;encoding = EIA;
00714            <span class="keywordflow">break</span>;
00715        <span class="keywordflow">default</span>:
00716            GERB_COMPILE_ERROR(<span class="stringliteral">"Strange inputcode : %c%c\n"</span>, op[0], op[1]);
00717        }
00718        <span class="keywordflow">break</span>;
00719 
00720        <span class="comment">/* Image parameters */</span>
00721     <span class="keywordflow">case</span> A2I(<span class="charliteral">'I'</span>,<span class="charliteral">'J'</span>): <span class="comment">/* Image Justify */</span>
00722        NOT_IMPL(fd, <span class="stringliteral">"%IJ%"</span>);
00723        <span class="keywordflow">break</span>;
00724     <span class="keywordflow">case</span> A2I(<span class="charliteral">'I'</span>,<span class="charliteral">'N'</span>): <span class="comment">/* Image Name */</span>
00725        image-&gt;info-&gt;name = gerb_fgetstring(fd, <span class="charliteral">'*'</span>);
00726        <span class="keywordflow">break</span>;
00727     <span class="keywordflow">case</span> A2I(<span class="charliteral">'I'</span>,<span class="charliteral">'O'</span>): <span class="comment">/* Image Offset */</span>
00728        NOT_IMPL(fd, <span class="stringliteral">"%IO%"</span>);
00729        <span class="keywordflow">break</span>;
00730     <span class="keywordflow">case</span> A2I(<span class="charliteral">'I'</span>,<span class="charliteral">'P'</span>): <span class="comment">/* Image Polarity */</span>
00731        
00732        <span class="keywordflow">for</span> (ano = 0; ano &lt; 3; ano++) {
00733            op[0] = gerb_fgetc(fd);
00734            <span class="keywordflow">if</span> (op[0] == EOF)
00735               GERB_COMPILE_ERROR(<span class="stringliteral">"Unexpected EOF found.\n"</span>);
00736            str[ano] = (<span class="keywordtype">char</span>)op[0];
00737        }
00738        
00739        <span class="keywordflow">if</span> (strncmp(str, <span class="stringliteral">"POS"</span>, 3) == 0) 
00740            image-&gt;info-&gt;polarity = POSITIVE;
00741        <span class="keywordflow">else</span> if (strncmp(str, <span class="stringliteral">"NEG"</span>, 3) == 0)
00742            image-&gt;info-&gt;polarity = NEGATIVE;
00743        <span class="keywordflow">else</span> 
00744            GERB_COMPILE_ERROR(<span class="stringliteral">"Strange polarity : %c%c%c\n"</span>, str[0], str[1], str[2]);
00745        
00746        <span class="keywordflow">break</span>;
00747     <span class="keywordflow">case</span> A2I(<span class="charliteral">'I'</span>,<span class="charliteral">'R'</span>): <span class="comment">/* Image Rotation */</span>
00748        tmp = gerb_fgetint(fd, NULL);
00749        <span class="keywordflow">if</span> (tmp != 0)
00750            NOT_IMPL(fd, <span class="stringliteral">"%IR%"</span>);
00751        <span class="keywordflow">break</span>;
00752     <span class="keywordflow">case</span> A2I(<span class="charliteral">'P'</span>,<span class="charliteral">'F'</span>): <span class="comment">/* Plotter Film */</span>
00753        NOT_IMPL(fd, <span class="stringliteral">"%PF%"</span>);
00754        <span class="keywordflow">break</span>;
00755        
00756        <span class="comment">/* Aperture parameters */</span>
00757     <span class="keywordflow">case</span> A2I(<span class="charliteral">'A'</span>,<span class="charliteral">'D'</span>): <span class="comment">/* Aperture Description */</span>
00758        a = (gerb_aperture_t *)malloc(<span class="keyword">sizeof</span>(gerb_aperture_t));
00759        memset((<span class="keywordtype">void</span> *)a, 0, <span class="keyword">sizeof</span>(gerb_aperture_t));
00760        ano = parse_aperture_definition(fd, a, image-&gt;amacro);
00761        if ((ano &gt;= APERTURE_MIN) &amp;&amp; (ano &lt;= APERTURE_MAX)) {
00762            a-&gt;unit = state-&gt;unit;
00763            image-&gt;aperture[ano] = a;
00764        } <span class="keywordflow">else</span>
00765            GERB_COMPILE_ERROR(<span class="stringliteral">"Aperture number out of bounds : %d\n"</span>, ano);
00766        <span class="keywordflow">break</span>;
00767     <span class="keywordflow">case</span> A2I(<span class="charliteral">'A'</span>,<span class="charliteral">'M'</span>): <span class="comment">/* Aperture Macro */</span>
00768        tmp_amacro = image-&gt;amacro;
00769        image-&gt;amacro = parse_aperture_macro(fd);
00770        image-&gt;amacro-&gt;next = tmp_amacro;
00771 <span class="preprocessor">#ifdef AMACRO_DEBUG</span>
00772 <span class="preprocessor"></span>       print_program(image-&gt;amacro);
00773 <span class="preprocessor">#endif</span>
00774 <span class="preprocessor"></span>       <span class="keywordflow">break</span>;
00775 
00776        <span class="comment">/* Layer */</span>
00777     <span class="keywordflow">case</span> A2I(<span class="charliteral">'L'</span>,<span class="charliteral">'N'</span>): <span class="comment">/* Layer Name */</span>
00778        state-&gt;curr_layername = gerb_fgetstring(fd, '*');
00779        <span class="keywordflow">break</span>;
00780     <span class="keywordflow">case</span> A2I(<span class="charliteral">'L'</span>,<span class="charliteral">'P'</span>): <span class="comment">/* Layer Polarity */</span>
00781        switch (gerb_fgetc(fd)) {
00782        <span class="keywordflow">case</span> <span class="charliteral">'D'</span>: <span class="comment">/* Dark Polarity (default) */</span>
00783            state-&gt;layer_polarity = DARK;
00784            <span class="keywordflow">break</span>;
00785        <span class="keywordflow">case</span> <span class="charliteral">'C'</span>: <span class="comment">/* Clear Polarity */</span>
00786            state-&gt;layer_polarity = CLEAR;
00787            <span class="keywordflow">break</span>;
00788        <span class="keywordflow">default</span>:
00789            GERB_COMPILE_WARNING(<span class="stringliteral">"Strange Layer Polarity: %c\n"</span>, op[0]);
00790        }
00791        <span class="keywordflow">break</span>;
00792     <span class="keywordflow">case</span> A2I(<span class="charliteral">'K'</span>,<span class="charliteral">'O'</span>): <span class="comment">/* Knock Out */</span>
00793        NOT_IMPL(fd, <span class="stringliteral">"%KO%"</span>);
00794        <span class="keywordflow">break</span>;
00795     <span class="keywordflow">case</span> A2I(<span class="charliteral">'S'</span>,<span class="charliteral">'R'</span>): <span class="comment">/* Step and Repeat */</span>
00796        op[0] = gerb_fgetc(fd);
00797        <span class="keywordflow">if</span> (op[0] == <span class="charliteral">'*'</span>) { <span class="comment">/* Disable previous SR parameters */</span>
00798            image-&gt;info-&gt;step_and_repeat.X = 1;
00799            image-&gt;info-&gt;step_and_repeat.Y = 1;
00800            image-&gt;info-&gt;step_and_repeat.dist_X = 0.0;
00801            image-&gt;info-&gt;step_and_repeat.dist_Y = 0.0;
00802            <span class="keywordflow">break</span>;
00803        }
00804        <span class="keywordflow">while</span> (op[0] != <span class="charliteral">'*'</span>) { 
00805            <span class="keywordflow">switch</span> (op[0]) {
00806            <span class="keywordflow">case</span> <span class="charliteral">'X'</span>:
00807               image-&gt;info-&gt;step_and_repeat.X = gerb_fgetint(fd, NULL);
00808               <span class="keywordflow">break</span>;
00809            <span class="keywordflow">case</span> <span class="charliteral">'Y'</span>:
00810               image-&gt;info-&gt;step_and_repeat.Y = gerb_fgetint(fd, NULL);
00811               <span class="keywordflow">break</span>;
00812            <span class="keywordflow">case</span> <span class="charliteral">'I'</span>:
00813               image-&gt;info-&gt;step_and_repeat.dist_X = gerb_fgetdouble(fd);
00814               <span class="keywordflow">break</span>;
00815            <span class="keywordflow">case</span> <span class="charliteral">'J'</span>:
00816               image-&gt;info-&gt;step_and_repeat.dist_Y = gerb_fgetdouble(fd);
00817               <span class="keywordflow">break</span>;
00818            <span class="keywordflow">default</span>:
00819               GERB_COMPILE_ERROR(<span class="stringliteral">"Step-and-repeat parameter error\n"</span>);
00820            }
00821            op[0] = gerb_fgetc(fd);
00822        }
00823        <span class="keywordflow">if</span> ((image-&gt;info-&gt;step_and_repeat.X != 1) || 
00824            (image-&gt;info-&gt;step_and_repeat.Y != 1) ||
00825            (fabs(image-&gt;info-&gt;step_and_repeat.dist_X) &gt; 0.000001) ||
00826            (fabs(image-&gt;info-&gt;step_and_repeat.dist_Y) &gt; 0.000001))
00827            NOT_IMPL(fd, <span class="stringliteral">"%SR%"</span>);
00828        <span class="keywordflow">break</span>;     
00829     <span class="keywordflow">case</span> A2I(<span class="charliteral">'R'</span>,<span class="charliteral">'O'</span>): <span class="comment">/* Rotate */</span>
00830        NOT_IMPL(fd, <span class="stringliteral">"%RO%"</span>);
00831        <span class="keywordflow">break</span>;
00832     <span class="keywordflow">default</span>:
00833        GERB_COMPILE_ERROR(<span class="stringliteral">"Unknown extension found %%%c%c%%\n"</span>, op[0], op[1]);
00834     }
00835     
00836     <span class="keywordflow">return</span>;
00837 } <span class="comment">/* parse_rs274x */</span>
00838 
00839 
00840 <span class="keyword">static</span> <span class="keywordtype">int</span> 
00841 parse_aperture_definition(gerb_file_t *fd, gerb_aperture_t *aperture,
00842                        amacro_t *amacro)
00843 {
00844     <span class="keywordtype">int</span> ano, i;
00845     <span class="keywordtype">char</span> *ad;
00846     <span class="keywordtype">char</span> *token;
00847     amacro_t *curr_amacro;
00848     
00849     <span class="keywordflow">if</span> (gerb_fgetc(fd) != <span class="charliteral">'D'</span>)
00850        <span class="keywordflow">return</span> -1;
00851     
00852     <span class="comment">/*</span>
00853 <span class="comment">     * Get aperture no</span>
00854 <span class="comment">     */</span>
00855     ano = gerb_fgetint(fd, NULL);
00856 
00857     <span class="comment">/*</span>
00858 <span class="comment">     * Read in the whole aperture defintion and tokenize it</span>
00859 <span class="comment">     */</span>
00860     ad = gerb_fgetstring(fd, <span class="charliteral">'*'</span>);
00861     token = strtok(ad, <span class="stringliteral">","</span>);
00862 
00863     <span class="keywordflow">if</span> (strlen(token) == 1) {
00864        <span class="keywordflow">switch</span> (token[0]) {
00865        <span class="keywordflow">case</span> <span class="charliteral">'C'</span>:
00866            aperture-&gt;type = CIRCLE;
00867            <span class="keywordflow">break</span>;
00868        <span class="keywordflow">case</span> <span class="charliteral">'R'</span> :
00869            aperture-&gt;type = RECTANGLE;
00870            <span class="keywordflow">break</span>;
00871        <span class="keywordflow">case</span> <span class="charliteral">'O'</span> :
00872            aperture-&gt;type = OVAL;
00873            <span class="keywordflow">break</span>;
00874        <span class="keywordflow">case</span> <span class="charliteral">'P'</span> :
00875            aperture-&gt;type = POLYGON;
00876            <span class="keywordflow">break</span>;
00877        }
00878        <span class="comment">/* Here a should a T be defined, but I don't know what it represents */</span>
00879     } <span class="keywordflow">else</span> {
00880        aperture-&gt;type = MACRO;
00881        <span class="comment">/*</span>
00882 <span class="comment">        * In aperture definition, point to the aperture macro </span>
00883 <span class="comment">        * used in the defintion</span>
00884 <span class="comment">        */</span>
00885        curr_amacro = amacro;
00886        <span class="keywordflow">while</span> (curr_amacro) {
00887            <span class="keywordflow">if</span> ((strlen(curr_amacro-&gt;name) == strlen(token)) &amp;&amp;
00888               (strcmp(curr_amacro-&gt;name, token) == 0)) {
00889               aperture-&gt;amacro = curr_amacro;
00890               <span class="keywordflow">break</span>;
00891            }
00892            curr_amacro = curr_amacro-&gt;next;
00893        }
00894     }
00895 
00896     <span class="comment">/*</span>
00897 <span class="comment">     * Parse all parameters</span>
00898 <span class="comment">     */</span>
00899     <span class="keywordflow">for</span> (token = strtok(NULL, <span class="stringliteral">"X"</span>), i = 0; token != NULL; 
00900         token = strtok(NULL, <span class="stringliteral">"X"</span>), i++)
00901        aperture-&gt;parameter[i] = strtod(token, NULL);
00902            
00903     aperture-&gt;nuf_parameters = i;
00904 
00905     gerb_ungetc(fd);
00906 
00907     free(ad);
00908 
00909     <span class="keywordflow">return</span> ano;
00910 } <span class="comment">/* parse_aperture_definition */</span>
00911 
00912 
00913 <span class="keyword">static</span> <span class="keywordtype">void</span> 
00914 calc_cirseg_sq(<span class="keyword">struct</span> gerb_net *net, <span class="keywordtype">int</span> cw, 
00915               <span class="keywordtype">double</span> delta_cp_x, <span class="keywordtype">double</span> delta_cp_y)
00916 {
00917     <span class="keywordtype">double</span> d1x, d1y, d2x, d2y;
00918     <span class="keywordtype">double</span> alfa, beta;
00919     <span class="keywordtype">int</span> quadrant = 0;
00920 
00921     
00922     <span class="comment">/*</span>
00923 <span class="comment">     * Quadrant detection (based on ccw, converted below if cw)</span>
00924 <span class="comment">     *  Y ^</span>
00925 <span class="comment">     *   /!\</span>
00926 <span class="comment">     *    !</span>
00927 <span class="comment">     *    ----&gt;X</span>
00928 <span class="comment">     */</span>
00929     <span class="keywordflow">if</span> (net-&gt;start_x &gt; net-&gt;stop_x)
00930        <span class="comment">/* 1st and 2nd quadrant */</span>
00931        <span class="keywordflow">if</span> (net-&gt;start_y &lt; net-&gt;stop_y)
00932            quadrant = 1;
00933        <span class="keywordflow">else</span>
00934            quadrant = 2;
00935     <span class="keywordflow">else</span>
00936        <span class="comment">/* 3rd and 4th quadrant */</span>
00937        <span class="keywordflow">if</span> (net-&gt;start_y &gt; net-&gt;stop_y)
00938            quadrant = 3;
00939        <span class="keywordflow">else</span>
00940            quadrant = 4;
00941 
00942     <span class="comment">/* </span>
00943 <span class="comment">     * If clockwise, rotate quadrant</span>
00944 <span class="comment">     */</span>
00945     <span class="keywordflow">if</span> (cw) {
00946        <span class="keywordflow">switch</span> (quadrant) {
00947        <span class="keywordflow">case</span> 1 : 
00948            quadrant = 3;
00949            <span class="keywordflow">break</span>;
00950        <span class="keywordflow">case</span> 2 : 
00951            quadrant = 4;
00952            <span class="keywordflow">break</span>;
00953        <span class="keywordflow">case</span> 3 : 
00954            quadrant = 1;
00955            <span class="keywordflow">break</span>;
00956        <span class="keywordflow">case</span> 4 : 
00957            quadrant = 2;
00958            <span class="keywordflow">break</span>;
00959        <span class="keywordflow">default</span> : 
00960            GERB_COMPILE_ERROR(<span class="stringliteral">"Unknow quadrant value while converting to cw\n"</span>);
00961        }
00962     }
00963 
00964     <span class="comment">/*</span>
00965 <span class="comment">     * Calculate arc center point</span>
00966 <span class="comment">     */</span>
00967     <span class="keywordflow">switch</span> (quadrant) {
00968     <span class="keywordflow">case</span> 1 :
00969        net-&gt;cirseg-&gt;cp_x = net-&gt;start_x - delta_cp_x;
00970        net-&gt;cirseg-&gt;cp_y = net-&gt;start_y - delta_cp_y;
00971        <span class="keywordflow">break</span>;
00972     <span class="keywordflow">case</span> 2 :
00973        net-&gt;cirseg-&gt;cp_x = net-&gt;start_x + delta_cp_x;
00974        net-&gt;cirseg-&gt;cp_y = net-&gt;start_y - delta_cp_y;
00975        <span class="keywordflow">break</span>;
00976     <span class="keywordflow">case</span> 3 : 
00977        net-&gt;cirseg-&gt;cp_x = net-&gt;start_x + delta_cp_x;
00978        net-&gt;cirseg-&gt;cp_y = net-&gt;start_y + delta_cp_y;
00979        <span class="keywordflow">break</span>;
00980     <span class="keywordflow">case</span> 4 :
00981        net-&gt;cirseg-&gt;cp_x = net-&gt;start_x - delta_cp_x;
00982        net-&gt;cirseg-&gt;cp_y = net-&gt;start_y + delta_cp_y;
00983        <span class="keywordflow">break</span>;
00984     <span class="keywordflow">default</span> :
00985        GERB_COMPILE_ERROR(<span class="stringliteral">"Strange quadrant : %d\n"</span>, quadrant);
00986     }
00987 
00988     <span class="comment">/*</span>
00989 <span class="comment">     * Some good values </span>
00990 <span class="comment">     */</span>
00991     d1x = fabs(net-&gt;start_x - net-&gt;cirseg-&gt;cp_x);
00992     d1y = fabs(net-&gt;start_y - net-&gt;cirseg-&gt;cp_y);
00993     d2x = fabs(net-&gt;stop_x - net-&gt;cirseg-&gt;cp_x);
00994     d2y = fabs(net-&gt;stop_y - net-&gt;cirseg-&gt;cp_y);
00995 
00996     alfa = atan2(d1y, d1x);
00997     beta = atan2(d2y, d2x);
00998 
00999     <span class="comment">/*</span>
01000 <span class="comment">     * Avoid divide by zero when sin(0) = 0 and cos(90) = 0</span>
01001 <span class="comment">     */</span>
01002     net-&gt;cirseg-&gt;width = alfa &lt; beta ? 
01003        2 * (d1x / cos(alfa)) : 2 * (d2x / cos(beta));
01004     net-&gt;cirseg-&gt;height = alfa &gt; beta ? 
01005        2 * (d1y / sin(alfa)) : 2 * (d2y / sin(beta));
01006 
01007     <span class="keywordflow">if</span> (alfa &lt; 0.000001 &amp;&amp; beta &lt; 0.000001) {
01008        net-&gt;cirseg-&gt;height = 0;
01009     }
01010 
01011 <span class="preprocessor">#define RAD2DEG(a) (a * 180 / M_PI) </span>
01012 <span class="preprocessor"></span>    
01013     <span class="keywordflow">switch</span> (quadrant) {
01014     <span class="keywordflow">case</span> 1 :
01015        net-&gt;cirseg-&gt;angle1 = RAD2DEG(alfa);
01016        net-&gt;cirseg-&gt;angle2 = RAD2DEG(beta);
01017        <span class="keywordflow">break</span>;
01018     <span class="keywordflow">case</span> 2 :
01019        net-&gt;cirseg-&gt;angle1 = 180.0 - RAD2DEG(alfa);
01020        net-&gt;cirseg-&gt;angle2 = 180.0 - RAD2DEG(beta);
01021        <span class="keywordflow">break</span>;
01022     <span class="keywordflow">case</span> 3 : 
01023        net-&gt;cirseg-&gt;angle1 = 180.0 + RAD2DEG(alfa);
01024        net-&gt;cirseg-&gt;angle2 = 180.0 + RAD2DEG(beta);
01025        <span class="keywordflow">break</span>;
01026     <span class="keywordflow">case</span> 4 :
01027        net-&gt;cirseg-&gt;angle1 = 360.0 - RAD2DEG(alfa);
01028        net-&gt;cirseg-&gt;angle2 = 360.0 - RAD2DEG(beta);
01029        <span class="keywordflow">break</span>;
01030     <span class="keywordflow">default</span> :
01031        GERB_COMPILE_ERROR(<span class="stringliteral">"Strange quadrant : %d\n"</span>, quadrant);
01032     }
01033 
01034     <span class="keywordflow">if</span> (net-&gt;cirseg-&gt;width &lt; 0.0)
01035        GERB_COMPILE_WARNING(<span class="stringliteral">"Negative width [%f] in quadrant %d [%f][%f]\n"</span>, 
01036                           net-&gt;cirseg-&gt;width, quadrant, alfa, beta);
01037     
01038     <span class="keywordflow">if</span> (net-&gt;cirseg-&gt;height &lt; 0.0)
01039        GERB_COMPILE_WARNING(<span class="stringliteral">"Negative height [%f] in quadrant %d [%f][%f]\n"</span>, 
01040             net-&gt;cirseg-&gt;height, quadrant, RAD2DEG(alfa), RAD2DEG(beta));
01041 
01042     <span class="keywordflow">return</span>;
01043 
01044 } <span class="comment">/* calc_cirseg_sq */</span>
01045 
01046 
01047 <span class="keyword">static</span> <span class="keywordtype">void</span> 
01048 calc_cirseg_mq(<span class="keyword">struct</span> gerb_net *net, <span class="keywordtype">int</span> cw, 
01049               <span class="keywordtype">double</span> delta_cp_x, <span class="keywordtype">double</span> delta_cp_y)
01050 {
01051     <span class="keywordtype">double</span> d1x, d1y, d2x, d2y;
01052     <span class="keywordtype">double</span> alfa, beta;
01053 
01054     net-&gt;cirseg-&gt;cp_x = net-&gt;start_x + delta_cp_x;
01055     net-&gt;cirseg-&gt;cp_y = net-&gt;start_y + delta_cp_y;
01056 
01057     <span class="comment">/*</span>
01058 <span class="comment">     * Some good values </span>
01059 <span class="comment">     */</span>
01060     d1x = net-&gt;start_x - net-&gt;cirseg-&gt;cp_x;
01061     d1y = net-&gt;start_y - net-&gt;cirseg-&gt;cp_y;
01062     d2x = net-&gt;stop_x - net-&gt;cirseg-&gt;cp_x;
01063     d2y = net-&gt;stop_y - net-&gt;cirseg-&gt;cp_y;
01064     
01065     alfa = atan2(d1y, d1x);
01066     beta = atan2(d2y, d2x);
01067 
01068     net-&gt;cirseg-&gt;width = sqrt(delta_cp_x*delta_cp_x + delta_cp_y*delta_cp_y);
01069     net-&gt;cirseg-&gt;width *= 2.0;
01070     net-&gt;cirseg-&gt;height = net-&gt;cirseg-&gt;width;
01071 
01072     net-&gt;cirseg-&gt;angle1 = RAD2DEG(alfa);
01073     net-&gt;cirseg-&gt;angle2 = RAD2DEG(beta);
01074 
01075     <span class="comment">/*</span>
01076 <span class="comment">     * Make sure it's always positive angles</span>
01077 <span class="comment">     */</span>
01078     <span class="keywordflow">if</span> (net-&gt;cirseg-&gt;angle1 &lt; 0.0) {
01079        net-&gt;cirseg-&gt;angle1 += 360.0;
01080        net-&gt;cirseg-&gt;angle2 += 360.0;
01081     }
01082 
01083     <span class="keywordflow">if</span> (net-&gt;cirseg-&gt;angle2 &lt; 0.0) 
01084        net-&gt;cirseg-&gt;angle2 += 360.0;
01085 
01086     <span class="keywordflow">if</span>(net-&gt;cirseg-&gt;angle2 == 0.0) 
01087        net-&gt;cirseg-&gt;angle2 = 360.0;
01088 
01089     <span class="comment">/*</span>
01090 <span class="comment">     * This is a sanity check for angles after the nature of atan2.</span>
01091 <span class="comment">     * If cw we must make sure angle1-angle2 are always positive,</span>
01092 <span class="comment">     * If ccw we must make sure angle2-angle1 are always negative.</span>
01093 <span class="comment">     * We should really return one angle and the difference as GTK</span>
01094 <span class="comment">     * uses them. But what the heck, it works for me.</span>
01095 <span class="comment">     */</span>
01096     <span class="keywordflow">if</span> (cw) {
01097        <span class="keywordflow">if</span> (net-&gt;cirseg-&gt;angle1 &lt;= net-&gt;cirseg-&gt;angle2)
01098            net-&gt;cirseg-&gt;angle2 -= 360.0;
01099     } <span class="keywordflow">else</span> {
01100        <span class="keywordflow">if</span> (net-&gt;cirseg-&gt;angle1 &gt;= net-&gt;cirseg-&gt;angle2)
01101            net-&gt;cirseg-&gt;angle2 += 360.0;
01102     }
01103 
01104     <span class="keywordflow">return</span>;
01105 } <span class="comment">/* calc_cirseg_mq */</span>
01106 
01107 
01108 <span class="keyword">static</span> gerb_net_t *
01109 gen_circle_segments(gerb_net_t *curr_net, <span class="keywordtype">int</span> cw, <span class="keywordtype">int</span> *nuf_pcorners)
01110 {
01111     <span class="keywordtype">double</span> end_x, end_y;
01112     <span class="keywordtype">double</span> angle, angle_diff;
01113     <span class="keywordtype">double</span> cp_x, cp_y;
01114     <span class="keywordtype">double</span> radius;
01115     <span class="keywordtype">int</span> steps, i;
01116     gerb_net_t * new_net;
01117 
01118     radius = curr_net-&gt;cirseg-&gt;width / 2.0;
01119     cp_x = curr_net-&gt;cirseg-&gt;cp_x;
01120     cp_y = curr_net-&gt;cirseg-&gt;cp_y;
01121 
01122     end_x = curr_net-&gt;stop_x;
01123     end_y = curr_net-&gt;stop_y;
01124 
01125     angle = curr_net-&gt;cirseg-&gt;angle1;
01126     angle_diff = curr_net-&gt;cirseg-&gt;angle2 - curr_net-&gt;cirseg-&gt;angle1;
01127 
01128     <span class="comment">/*</span>
01129 <span class="comment">     * compute number of segments, each is approx 1 degree</span>
01130 <span class="comment">     */</span>
01131     <span class="keywordflow">if</span> (cw)
01132         steps = (int)(1.0 - angle_diff);
01133     <span class="keywordflow">else</span>
01134         steps = (int)(1.0 + angle_diff);
01135 
01136     <span class="keywordflow">for</span> (i = 1; i &lt; steps; i++) {
01137 <span class="preprocessor">#define DEG2RAD(a) (((a) * M_PI) / 180.0) </span>
01138 <span class="preprocessor"></span>
01139        <span class="comment">/*</span>
01140 <span class="comment">        * calculate end point for this segment</span>
01141 <span class="comment">        */</span>
01142        curr_net-&gt;stop_x = cp_x + radius * cos (DEG2RAD(angle + (angle_diff * i) / steps));
01143        curr_net-&gt;stop_y = cp_y + radius * sin (DEG2RAD(angle + (angle_diff * i) / steps));
01144 
01145        <span class="comment">/*</span>
01146 <span class="comment">        * create a new net, and copy current into it, (but not cirseg)</span>
01147 <span class="comment">        */</span>
01148        new_net = (gerb_net_t *)malloc(<span class="keyword">sizeof</span>(gerb_net_t));
01149        *new_net = *curr_net;
01150        new_net-&gt;cirseg = NULL;
01151 
01152        <span class="comment">/*</span>
01153 <span class="comment">        * set start point to be old stop</span>
01154 <span class="comment">        */</span>
01155        new_net-&gt;start_x = curr_net-&gt;stop_x;
01156        new_net-&gt;start_y = curr_net-&gt;stop_y;
01157 
01158        curr_net-&gt;next = new_net;
01159        curr_net = new_net;
01160 
01161        <span class="comment">/*</span>
01162 <span class="comment">        * increment the polygon corner count</span>
01163 <span class="comment">        */</span>
01164        (*nuf_pcorners)++;
01165     }
01166 
01167     <span class="comment">/*</span>
01168 <span class="comment">     * ensure the last point is at the end passed in</span>
01169 <span class="comment">     */</span>
01170     curr_net-&gt;stop_x = end_x;
01171     curr_net-&gt;stop_y = end_y;
01172 
01173     (*nuf_pcorners)++;
01174 
01175     <span class="keywordflow">return</span> curr_net;
01176 } <span class="comment">/* gen_circle_segments */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Oct 13 16:09:18 2004 for gerbv by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.8-20040928 </small></address>
</body>
</html>
