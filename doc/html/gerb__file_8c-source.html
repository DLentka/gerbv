<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gerbv: src/gerb_file.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8-20040928 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a></div>
<h1>gerb_file.c</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * gEDA - GNU Electronic Design Automation</span>
00003 <span class="comment"> * This file is a part of gerbv.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> *   Copyright (C) 2000-2002 Stefan Petersen (spe@stacken.kth.se)</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> * $Id$</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
00010 <span class="comment"> * it under the terms of the GNU General Public License as published by</span>
00011 <span class="comment"> * the Free Software Foundation; either version 2 of the License, or</span>
00012 <span class="comment"> * (at your option) any later version.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
00015 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00016 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00017 <span class="comment"> * GNU General Public License for more details.</span>
00018 <span class="comment"> *</span>
00019 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
00020 <span class="comment"> * along with this program; if not, write to the Free Software</span>
00021 <span class="comment"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA</span>
00022 <span class="comment"> */</span>
00023 
00024 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00025 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00026 <span class="preprocessor">#endif</span>
00027 <span class="preprocessor"></span>
00028 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00029 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00030 <span class="preprocessor">#include &lt;string.h&gt;</span>
00031 
00032 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00033 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
00034 <span class="preprocessor">#ifdef HAVE_UNISTD_H</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#include &lt;unistd.h&gt;</span>
00036 <span class="preprocessor">#endif</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_SYS_MMAN_H</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/mman.h&gt;</span>
00039 <span class="preprocessor">#endif</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#include &lt;errno.h&gt;</span>
00041 <span class="preprocessor">#include "gerb_error.h"</span>
00042 <span class="preprocessor">#include "gerb_file.h"</span>
00043 
00044 
00045 
00046 
00047 
00048 
00049 
00050 gerb_file_t *
00051 gerb_fopen(<span class="keywordtype">char</span> *filename)
00052 {
00053     gerb_file_t *fd;
00054     <span class="keyword">struct </span>stat statinfo;
00055     
00056 
00057 <span class="preprocessor">#ifdef HAVE_SYS_MMAN_H</span>
00058 <span class="preprocessor"></span>    fd = (gerb_file_t *)malloc(<span class="keyword">sizeof</span>(gerb_file_t));
00059     <span class="keywordflow">if</span> (fd == NULL) {
00060        <span class="keywordflow">return</span> NULL;
00061     }
00062 
00063     fd-&gt;fd = fopen(filename, <span class="stringliteral">"r"</span>);
00064     <span class="keywordflow">if</span> (fd-&gt;fd == NULL) {
00065        <span class="keywordflow">return</span> NULL;
00066     }
00067 
00068     fd-&gt;ptr = 0;
00069     fd-&gt;fileno = fileno(fd-&gt;fd);
00070     fstat(fd-&gt;fileno, &amp;statinfo);
00071     <span class="keywordflow">if</span> (!S_ISREG(statinfo.st_mode)) {
00072        errno = EISDIR;
00073        <span class="keywordflow">return</span> NULL;
00074     }
00075     <span class="keywordflow">if</span> ((int)statinfo.st_size == 0) {
00076        errno = EIO; <span class="comment">/* More compatible with the world outside Linux */</span>
00077        <span class="keywordflow">return</span> NULL;
00078     }
00079     fd-&gt;datalen = (int)statinfo.st_size;
00080     fd-&gt;data = (<span class="keywordtype">char</span> *)mmap(0, statinfo.st_size, PROT_READ, MAP_PRIVATE, 
00081                          fd-&gt;fileno, 0);
00082     <span class="keywordflow">if</span>(fd-&gt;data == MAP_FAILED) {
00083        fclose(fd-&gt;fd);
00084        free(fd);
00085        fd = NULL;
00086     }
00087 <span class="preprocessor">#else</span>
00088 <span class="preprocessor"></span>    <span class="comment">/* all systems without mmap, not only MINGW32 */</span>
00089     fd = (gerb_file_t *)malloc(<span class="keyword">sizeof</span>(gerb_file_t));
00090     <span class="keywordflow">if</span> (fd == NULL) {
00091        <span class="keywordflow">return</span> NULL;
00092     }
00093 
00094     <span class="keywordflow">if</span> (stat(filename, &amp;statinfo)) {
00095         perror(<span class="stringliteral">"snarf_file"</span>);
00096         <span class="keywordflow">return</span> NULL;
00097     }
00098     
00099     fd-&gt;fd = fopen(filename, <span class="stringliteral">"r"</span>);
00100     fd-&gt;ptr = 0;
00101     fd-&gt;fileno = fileno(fd-&gt;fd);
00102     fstat(fd-&gt;fileno, &amp;statinfo);
00103     <span class="keywordflow">if</span> (!S_ISREG(statinfo.st_mode)) {
00104        errno = EISDIR;
00105        <span class="keywordflow">return</span> NULL;
00106     }
00107     <span class="keywordflow">if</span> ((int)statinfo.st_size == 0) {
00108        errno = EIO; <span class="comment">/* More compatible with the world outside Linux */</span>
00109        <span class="keywordflow">return</span> NULL;
00110     }
00111     fd-&gt;datalen = (int)statinfo.st_size;
00112     fd-&gt;data = calloc(1, statinfo.st_size + 1);
00113     <span class="keywordflow">if</span> (fd-&gt;data == NULL) {
00114         fclose(fd-&gt;fd);
00115         free(fd);
00116         <span class="keywordflow">return</span> NULL;
00117     }
00118     fread((<span class="keywordtype">void</span>*)fd-&gt;data, 1, statinfo.st_size, fd-&gt;fd);
00119 <span class="preprocessor">#endif</span>
00120 <span class="preprocessor"></span>    <span class="keywordflow">return</span> fd;
00121 } <span class="comment">/* gerb_fopen */</span>
00122 
00123 
00124 <span class="keywordtype">int</span>
00125 gerb_fgetc(gerb_file_t *fd)
00126 {
00127 
00128     <span class="keywordflow">if</span> (fd-&gt;ptr &gt; fd-&gt;datalen || fd-&gt;datalen == 0)
00129        <span class="keywordflow">return</span> EOF;
00130 
00131     <span class="keywordflow">return</span> (int) fd-&gt;data[fd-&gt;ptr++];
00132 } <span class="comment">/* gerb_fgetc */</span>
00133 
00134 
00135 <span class="keywordtype">int</span>
00136 gerb_fgetint(gerb_file_t *fd, <span class="keywordtype">int</span> *len)
00137 {
00138     <span class="keywordtype">long</span> <span class="keywordtype">int</span> result;
00139     <span class="keywordtype">char</span> *end;
00140     
00141     result = strtol(fd-&gt;data + fd-&gt;ptr, &amp;end, 10);
00142 
00143     <span class="keywordflow">if</span> (len) {
00144        *len = end - (fd-&gt;data + fd-&gt;ptr);
00145     }
00146 
00147     fd-&gt;ptr = end - fd-&gt;data;
00148 
00149     <span class="keywordflow">return</span> (int)result;
00150 } <span class="comment">/* gerb_fgetint */</span>
00151 
00152 
00153 <span class="keywordtype">double</span>
00154 gerb_fgetdouble(gerb_file_t *fd)
00155 {
00156     <span class="keywordtype">double</span> result;
00157     <span class="keywordtype">char</span> *end;
00158     
00159     result = strtod(fd-&gt;data + fd-&gt;ptr, &amp;end);
00160     fd-&gt;ptr = end - fd-&gt;data;
00161 
00162     <span class="keywordflow">return</span> result;
00163 } <span class="comment">/* gerb_fgetdouble */</span>
00164 
00165 
00166 <span class="keywordtype">char</span> *
00167 gerb_fgetstring(gerb_file_t *fd, <span class="keywordtype">char</span> term)
00168 {
00169     <span class="keywordtype">char</span> *strend;
00170     <span class="keywordtype">char</span> *newstr;
00171     <span class="keywordtype">int</span> len;
00172     
00173     strend = strchr(fd-&gt;data + fd-&gt;ptr, term);
00174     <span class="keywordflow">if</span> (strend == NULL)
00175        <span class="keywordflow">return</span> NULL;
00176 
00177     len = strend - (fd-&gt;data + fd-&gt;ptr);
00178 
00179     newstr = (<span class="keywordtype">char</span> *)malloc(len + 1);
00180     <span class="keywordflow">if</span> (newstr == NULL)
00181        <span class="keywordflow">return</span> NULL;
00182     strncpy(newstr, fd-&gt;data + fd-&gt;ptr, len);
00183     newstr[len] = <span class="charliteral">'\0'</span>;
00184     fd-&gt;ptr += len;
00185 
00186     <span class="keywordflow">return</span> newstr;
00187 } <span class="comment">/* gerb_fgetstring */</span>
00188 
00189 
00190 <span class="keywordtype">void</span> 
00191 gerb_ungetc(gerb_file_t *fd)
00192 {
00193     <span class="keywordflow">if</span> (fd-&gt;ptr)
00194        fd-&gt;ptr--;
00195 
00196     <span class="keywordflow">return</span>;
00197 } <span class="comment">/* gerb_ungetc */</span>
00198 
00199 
00200 <span class="keywordtype">void</span>
00201 gerb_fclose(gerb_file_t *fd)
00202 {
00203 <span class="preprocessor">#ifdef HAVE_SYS_MMAN_H</span>
00204 <span class="preprocessor"></span>    munmap(fd-&gt;data, fd-&gt;datalen);
00205 <span class="preprocessor">#else</span>
00206 <span class="preprocessor"></span>    free(fd-&gt;data);
00207 <span class="preprocessor">#endif   </span>
00208 <span class="preprocessor"></span>    fclose(fd-&gt;fd);
00209     free(fd);
00210     
00211     <span class="keywordflow">return</span>;
00212 } <span class="comment">/* gerb_fclose */</span>
00213 
00214 
00215 <span class="keywordtype">char</span> *
00216 gerb_find_file(<span class="keywordtype">char</span> *filename, <span class="keywordtype">char</span> **paths)
00217 {
00218     <span class="keywordtype">char</span> *curr_path = NULL;
00219     <span class="keywordtype">char</span> *complete_path = NULL;
00220     <span class="keywordtype">int</span>        i;
00221 
00222     <span class="keywordflow">for</span> (i = 0; paths[i] != NULL; i++) {
00223 
00224        <span class="comment">/*</span>
00225 <span class="comment">        * Environment variables start with a $ sign </span>
00226 <span class="comment">        */</span>
00227        <span class="keywordflow">if</span> (paths[i][0] == <span class="charliteral">'$'</span>) {
00228            <span class="keywordtype">char</span> *env_name, *env_value, *tmp;
00229            <span class="keywordtype">int</span> len;
00230 
00231            <span class="comment">/* Extract environment name. Remember we start with a $ */</span>
00232         
00233            tmp = strchr(paths[i], path_separator);
00234            <span class="keywordflow">if</span> (tmp == NULL) 
00235               len = strlen(paths[i]) - 1;
00236            <span class="keywordflow">else</span>
00237               len = tmp - paths[i] - 1;
00238            env_name = (<span class="keywordtype">char</span> *)malloc(len);
00239            strncpy(env_name, (<span class="keywordtype">char</span> *)(paths[i] + 1), len);
00240            env_name[len] = <span class="charliteral">'\0'</span>;
00241 
00242            env_value = getenv(env_name);
00243            <span class="keywordflow">if</span> (env_value == NULL) <span class="keywordflow">break</span>;
00244            curr_path = (<span class="keywordtype">char</span> *)malloc(strlen(env_value) + strlen(&amp;paths[i][len + 1]) + 1);
00245            strcpy(curr_path, env_value);
00246            strcat(curr_path, &amp;paths[i][len + 1]);
00247            free(env_name);
00248        } <span class="keywordflow">else</span> {
00249            curr_path = paths[i];
00250        }
00251 
00252        <span class="comment">/*</span>
00253 <span class="comment">        * Build complete path (inc. filename) and check if file exists.</span>
00254 <span class="comment">        */</span>
00255        complete_path = (<span class="keywordtype">char</span> *)malloc(strlen(curr_path) + strlen(filename) + 2);
00256        strcpy(complete_path, curr_path);
00257        complete_path[strlen(curr_path)] = path_separator;
00258        complete_path[strlen(curr_path) + 1] = <span class="charliteral">'\0'</span>;
00259        strncat(complete_path, filename, strlen(filename));
00260 
00261        <span class="keywordflow">if</span> (access(complete_path, R_OK) != -1)
00262            <span class="keywordflow">break</span>;
00263 <span class="comment">//    GERB_MESSAGE("Could not Find %s", complete_path);</span>
00264        free(complete_path);
00265        complete_path = NULL;
00266     }
00267 
00268     <span class="keywordflow">return</span> complete_path;
00269 } <span class="comment">/* gerb_find_file */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Oct 13 16:09:18 2004 for gerbv by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.8-20040928 </small></address>
</body>
</html>
