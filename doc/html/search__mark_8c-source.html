<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gerbv: src/search_mark.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8-20040928 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a></div>
<h1>search_mark.c</h1><a href="search__mark_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * gEDA - GNU Electronic Design Automation</span>
00003 <span class="comment"> * This file is a part of gerbv.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> *   Copyright (C) 2000-2003 Stefan Petersen (spe@stacken.kth.se)</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> * $Id$</span>
00008 <span class="comment"> *  </span>
00009 <span class="comment"> *                                      Juergen H. (juergenhaas@gmx.net)and</span>
00010 <span class="comment"> *                                      Tomasz M. (T.Motylewski@bfad.de)</span>
00011 <span class="comment"> *</span>
00012 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
00013 <span class="comment"> * it under the terms of the GNU General Public License as published by</span>
00014 <span class="comment"> * the Free Software Foundation; either version 2 of the License, or</span>
00015 <span class="comment"> * (at your option) any later version.</span>
00016 <span class="comment"> *</span>
00017 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
00018 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00019 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00020 <span class="comment"> * GNU General Public License for more details.</span>
00021 <span class="comment"> *</span>
00022 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
00023 <span class="comment"> * along with this program; if not, write to the Free Software</span>
00024 <span class="comment"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA</span>
00025 <span class="comment"> */</span>
00026 
00027 
00032 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#include &lt;config.h&gt;</span>
00034 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_CONFIG_H */</span>
00035 
00036 <span class="preprocessor">#ifdef USE_GTK2</span>
00037 <span class="preprocessor"></span>
00038 <span class="preprocessor">#include &lt;assert.h&gt;</span>
00039 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00040 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00041 <span class="preprocessor">#include &lt;math.h&gt;</span>
00042 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00043 
00044 <span class="preprocessor">#ifdef HAVE_STRING_H</span>
00045 <span class="preprocessor"></span><span class="preprocessor">#include &lt;string.h&gt;</span>
00046 <span class="preprocessor">#endif</span>
00047 <span class="preprocessor"></span>
00048 <span class="preprocessor">#ifdef HAVE_UNISTD_H</span>
00049 <span class="preprocessor"></span><span class="preprocessor">#include &lt;unistd.h&gt;</span>
00050 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_UNISTD_H */</span>
00051 
00052 <span class="preprocessor">#include &lt;gtk/gtk.h&gt;</span>
00053 <span class="preprocessor">#include &lt;gdk/gdk.h&gt;</span>
00054 <span class="preprocessor">#include &lt;gdk/gdkkeysyms.h&gt;</span>
00055 
00056 <span class="preprocessor">#ifdef HAVE_GETOPT_H</span>
00057 <span class="preprocessor"></span><span class="preprocessor">#include &lt;getopt.h&gt;</span>
00058 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_GETOPT_H */</span>
00059 
00060 <span class="preprocessor">#ifdef USE_GTK2</span>
00061 <span class="preprocessor"></span><span class="preprocessor">#include &lt;pango/pango.h&gt;</span>
00062 <span class="preprocessor">#endif </span><span class="comment">/* USE_GTK2 */</span>
00063 
00064 <span class="preprocessor">#include &lt;assert.h&gt;</span>
00065 
00066 <span class="preprocessor">#include "gerber.h"</span>
00067 <span class="preprocessor">#include "drill.h"</span>
00068 <span class="preprocessor">#include "gerb_error.h"</span>
00069 <span class="preprocessor">#include "draw.h"</span>
00070 <span class="preprocessor">#include "color.h"</span>
00071 <span class="preprocessor">#include "gerbv_screen.h"</span>
00072 <span class="preprocessor">#include "gerbv_icon.h"</span>
00073 <span class="preprocessor">#include "search.h"</span>
00074 <span class="preprocessor">#include "search_file.h"</span>
00075 <span class="preprocessor">#include "search_mark.h"</span>
00076 <span class="preprocessor">#include "log.h"</span>
00077 <span class="preprocessor">#include "setup.h"</span>
00078 <span class="preprocessor">#include "<a class="code" href="project_8h.html">project.h</a>"</span>
00079 
00080 <span class="preprocessor">#include "search_gui.h"</span>
00081 <span class="comment">/* CHECKME - here gi18n is disabled */</span>
00082 <span class="preprocessor">#define _(String) (String)</span>
00083 <span class="preprocessor"></span>
00084 
<a name="l00091"></a><a class="code" href="search__mark_8c.html#a0">00091</a> <span class="keywordtype">void</span> <a class="code" href="search__mark_8c.html#a0">create_marked_layer</a>(<span class="keywordtype">int</span> idx) {
00092     <span class="keywordtype">int</span>            r, g, b;
00093     GtkStyle      *defstyle, *newstyle;
00094     gerb_net_t    *curr_net = NULL;
00095     gerb_image_t  *image = NULL;
00096     GList         *list;
00097     <span class="keywordtype">char</span>          *tmp_name = NULL;
00098     <a class="code" href="structgerb__transf.html">gerb_transf_t</a> *tr_rot = gerb_transf_new();
00099   <span class="comment">//  GtkTreeIter   iter;</span>
00100     
00101         
00102 <span class="comment">/*   if ((interface.selection != NULL) </span>
00103 <span class="comment">      &amp;&amp; (gtk_tree_selection_count_selected_rows (GTK_TREE_SELECTION(interface.selection)) == 0) </span>
00104 <span class="comment">      &amp;&amp; (!screen.file[idx]-&gt;color)) {</span>
00105 <span class="comment">           </span>
00106 <span class="comment">         return;</span>
00107 <span class="comment">    }*/</span>
00108     
00109     <span class="keywordflow">if</span>(!<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]) {
00110         <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx] = (gerbv_fileinfo_t *)malloc(<span class="keyword">sizeof</span>(gerbv_fileinfo_t));
00111         memset((<span class="keywordtype">void</span> *)<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx], 0, <span class="keyword">sizeof</span>(gerbv_fileinfo_t));
00112         <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;name = tmp_name;
00113     }
00114     <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;image = new_gerb_image(<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;image);
00115     image = <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;image;
00116     <span class="keywordflow">if</span> (image == NULL) {
00117        GERB_FATAL_ERROR(<span class="stringliteral">"malloc image failed\n"</span>);
00118         <span class="keywordflow">return</span>;
00119     }
00120     curr_net = image-&gt;netlist;
00121 
00122     <span class="keywordflow">if</span> (!<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;color) {
00123       <span class="comment">//  int   idx0;</span>
00124       <span class="comment">//  char  tmp_iter_str[MAXL];</span>
00125         r = (12341 + 657371 * idx) % (int)(MAX_COLOR_RESOLUTION);
00126         g = (23473 + 434382 * idx) % (int)(MAX_COLOR_RESOLUTION);
00127         b = (90341 + 123393 * idx) % (int)(MAX_COLOR_RESOLUTION);
00128 
00129         <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;color = alloc_color(r, g, b, NULL);
00130         <a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;inverted = 0;
00131 
00132         <span class="comment">/* This code will remove the layer which the selection is drawn onto from</span>
00133 <span class="comment">         * the available layers to be drawn on in future, dactivate, because the</span>
00134 <span class="comment">         * number of layers decreases quite fast*/</span>
00135          
00136         <span class="comment">/* combo_box_model = gtk_list_store_new (2, G_TYPE_INT, G_TYPE_STRING); </span>
00137 <span class="comment">        for (idx0 =  0; idx0 &lt; MAX_FILES; idx0++) {</span>
00138 <span class="comment"></span>
00139 <span class="comment">            if (screen.file[idx0] == NULL) {</span>
00140 <span class="comment">                gtk_list_store_append(combo_box_model, &amp;iter);</span>
00141 <span class="comment">                gtk_list_store_set (combo_box_model, &amp;iter, 0, idx0, -1);</span>
00142 <span class="comment">            } </span>
00143 <span class="comment">        }</span>
00144 <span class="comment">        gtk_combo_box_set_model(GTK_COMBO_BOX(interface.layer_active), GTK_TREE_MODEL(combo_box_model));</span>
00145 <span class="comment">        //sprintf(tmp_iter_str, "%i", idx);</span>
00146 <span class="comment">        //gtk_tree_model_get_iter_from_string(GTK_TREE_MODEL(combo_box_model), &amp;iter, tmp_iter_str);</span>
00147 <span class="comment">        gtk_tree_model_get_iter_first(GTK_TREE_MODEL(combo_box_model), &amp;iter);</span>
00148 <span class="comment">        gtk_combo_box_set_active_iter   (GTK_COMBO_BOX(interface.layer_active), &amp;iter);</span>
00149 <span class="comment">        */</span>
00150     }    
00151 
00152     <span class="comment">/* </span>
00153 <span class="comment">     * Set color on layer button</span>
00154 <span class="comment">     */</span>
00155     defstyle = gtk_widget_get_default_style();
00156     newstyle = gtk_style_copy(defstyle);
00157     newstyle-&gt;bg[GTK_STATE_NORMAL] = *(<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;color);
00158     newstyle-&gt;bg[GTK_STATE_ACTIVE] = *(<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;color);
00159     newstyle-&gt;bg[GTK_STATE_PRELIGHT] = *(<a class="code" href="gerbv_8c.html#a0">screen</a>.file[idx]-&gt;color);
00160     gtk_widget_set_style(<a class="code" href="gerbv_8c.html#a0">screen</a>.layer_button[idx], newstyle);
00161 
00162     <span class="comment">/* </span>
00163 <span class="comment">     * Tool tips on button is the file name </span>
00164 <span class="comment">     */</span>
00165     gtk_tooltips_set_tip(<a class="code" href="gerbv_8c.html#a0">screen</a>.tooltips, <a class="code" href="gerbv_8c.html#a0">screen</a>.layer_button[idx],
00166                       <span class="stringliteral">"selected parts"</span>, NULL); 
00167               
00168     image-&gt;info-&gt;min_x = -1;
00169     image-&gt;info-&gt;min_y = -1;
00170     image-&gt;info-&gt;max_x = 5;
00171     image-&gt;info-&gt;max_y = 5;
00172     image-&gt;info-&gt;scale_factor_A = 1.0;
00173     image-&gt;info-&gt;scale_factor_B = 1.0;
00174     image-&gt;info-&gt;offset_a = 0.0;
00175     image-&gt;info-&gt;offset_b = 0.0;
00176     image-&gt;info-&gt;step_and_repeat.X = 1.0;
00177     image-&gt;info-&gt;step_and_repeat.Y = 1.0;
00178     image-&gt;info-&gt;step_and_repeat.dist_X = 0.0;
00179     image-&gt;info-&gt;step_and_repeat.dist_Y = 0.0;
00180 
00181     image-&gt;aperture[0] = (gerb_aperture_t *)malloc(<span class="keyword">sizeof</span>(gerb_aperture_t));
00182     memset((<span class="keywordtype">void</span> *) image-&gt;aperture[0], 0, <span class="keyword">sizeof</span>(gerb_aperture_t));
00183     image-&gt;aperture[0]-&gt;type = CIRCLE;
00184     image-&gt;aperture[0]-&gt;amacro = NULL;
00185     image-&gt;aperture[0]-&gt;parameter[0] = 0.4;
00186     image-&gt;aperture[0]-&gt;parameter[1] = 0.0;
00187     image-&gt;aperture[0]-&gt;parameter[2] = 0.0;
00188     image-&gt;aperture[0]-&gt;parameter[3] = 0.0;
00189     image-&gt;aperture[0]-&gt;parameter[4] = 0.0;
00190     image-&gt;aperture[0]-&gt;nuf_parameters = 1;
00191     image-&gt;aperture[0]-&gt;unit = MM;
00192 
00193            
00194     list = gtk_tree_selection_get_selected_rows (GTK_TREE_SELECTION(interface.<a class="code" href="struct__InterfaceStruct.html#o19">selection</a>),
00195                                                   (GtkTreeModel **)&amp;interface.<a class="code" href="struct__InterfaceStruct.html#o17">model</a>);
00196     <span class="keywordflow">if</span> (list == NULL) 
00197         <span class="keywordflow">return</span>;                             
00198     list = g_list_first (list);
00199    
00200     <span class="keywordflow">do</span> {
00201         gchar *designator, *footprint, *layer, *comment;
00202         <span class="keywordtype">double</span> mid_x, mid_y, ref_x, ref_y, pad_x, pad_y, rotation, radius;
00203            <span class="keywordtype">double</span> length, width;
00204            <span class="keywordtype">int</span> shape;
00205         GtkTreeIter iter;
00206         gboolean no_files_found;
00207           
00208         gtk_tree_model_get_iter (GTK_TREE_MODEL(interface.<a class="code" href="struct__InterfaceStruct.html#o17">model</a>), &amp;iter, 
00209                           list-&gt;data);
00210         
00211         gtk_tree_model_get (GTK_TREE_MODEL(interface.<a class="code" href="struct__InterfaceStruct.html#o17">model</a>), &amp;iter,
00212                          COLUMN_DESIGNATOR, &amp;designator,
00213                     COLUMN_footprint, &amp;footprint,
00214                           COLUMN_mid_x, &amp;mid_x,
00215                     COLUMN_mid_y, &amp;mid_y,
00216                     COLUMN_ref_x, &amp;ref_x,
00217                     COLUMN_ref_y, &amp;ref_y,
00218                     COLUMN_pad_x, &amp;pad_x,
00219                     COLUMN_pad_y, &amp;pad_y,
00220                     COLUMN_LAYER, &amp;layer,
00221                     COLUMN_rotation, &amp;rotation,
00222                              COLUMN_length, &amp;length,
00223                              COLUMN_width, &amp;width,
00224                              COLUMN_shape, &amp;shape,
00225                     COLUMN_COMMENT, &amp;comment,
00226                              COLUMN_NO_FILES_FOUND, &amp;no_files_found,
00227                                                -1);
00228         curr_net-&gt;next = (gerb_net_t *)malloc(<span class="keyword">sizeof</span>(gerb_net_t));
00229         curr_net = curr_net-&gt;next;
00230         assert(curr_net);
00231         memset((<span class="keywordtype">void</span> *)curr_net, 0, <span class="keyword">sizeof</span>(gerb_net_t));
00232         rotation *= M_PI/180; <span class="comment">/* convert deg to rad */</span>
00233 
00234            <span class="keywordflow">switch</span>(shape) {
00235            <span class="keywordflow">case</span> PART_SHAPE_RECTANGLE:
00236         <span class="keywordflow">case</span> PART_SHAPE_STD:
00237            <span class="comment">// TODO: draw rectangle length x width taking into account rotation or pad x,y</span>
00238             gerb_transf_reset(tr_rot);
00239             <a class="code" href="gerb__transf_8c.html#a3">gerb_transf_rotate</a>(tr_rot, rotation);
00240             <a class="code" href="gerb__transf_8c.html#a4">gerb_transf_shift</a>(tr_rot, mid_x, mid_y);
00241 
00242             gerb_transf_apply(length/2, width/2, tr_rot, 
00243                 &amp;curr_net-&gt;start_x, &amp;curr_net-&gt;start_y);
00244             gerb_transf_apply(-length/2, width/2, tr_rot, 
00245                 &amp;curr_net-&gt;stop_x, &amp;curr_net-&gt;stop_y);
00246     
00247             curr_net-&gt;aperture = 0;
00248             curr_net-&gt;layer_polarity = POSITIVE;
00249             curr_net-&gt;unit = MM;
00250             curr_net-&gt;aperture_state = ON;
00251             curr_net-&gt;interpolation = LINEARx1;
00252             
00253             curr_net-&gt;next = (gerb_net_t *)malloc(<span class="keyword">sizeof</span>(gerb_net_t));
00254             curr_net = curr_net-&gt;next;
00255             assert(curr_net);
00256             memset((<span class="keywordtype">void</span> *)curr_net, 0, <span class="keyword">sizeof</span>(gerb_net_t));
00257             
00258             gerb_transf_apply(-length/2, width/2, tr_rot, 
00259                 &amp;curr_net-&gt;start_x, &amp;curr_net-&gt;start_y);
00260             gerb_transf_apply(-length/2, -width/2, tr_rot, 
00261                 &amp;curr_net-&gt;stop_x, &amp;curr_net-&gt;stop_y);
00262                     
00263             curr_net-&gt;aperture = 0;
00264             curr_net-&gt;layer_polarity = POSITIVE;
00265             curr_net-&gt;unit = MM;
00266             curr_net-&gt;aperture_state = ON;
00267             curr_net-&gt;interpolation = LINEARx1;
00268             
00269             curr_net-&gt;next = (gerb_net_t *)malloc(<span class="keyword">sizeof</span>(gerb_net_t));
00270             curr_net = curr_net-&gt;next;
00271             assert(curr_net);
00272             memset((<span class="keywordtype">void</span> *)curr_net, 0, <span class="keyword">sizeof</span>(gerb_net_t));
00273             
00274             gerb_transf_apply(-length/2, -width/2, tr_rot, 
00275                 &amp;curr_net-&gt;start_x, &amp;curr_net-&gt;start_y);
00276             gerb_transf_apply(length/2, -width/2, tr_rot, 
00277                 &amp;curr_net-&gt;stop_x, &amp;curr_net-&gt;stop_y);
00278                     
00279             curr_net-&gt;aperture = 0;
00280             curr_net-&gt;layer_polarity = POSITIVE;
00281             curr_net-&gt;unit = MM;
00282             curr_net-&gt;aperture_state = ON;
00283             curr_net-&gt;interpolation = LINEARx1;
00284 
00285             curr_net-&gt;next = (gerb_net_t *)malloc(<span class="keyword">sizeof</span>(gerb_net_t));
00286             curr_net = curr_net-&gt;next;
00287             assert(curr_net);
00288             memset((<span class="keywordtype">void</span> *)curr_net, 0, <span class="keyword">sizeof</span>(gerb_net_t));
00289             
00290             gerb_transf_apply(length/2, -width/2, tr_rot, 
00291                 &amp;curr_net-&gt;start_x, &amp;curr_net-&gt;start_y);
00292             gerb_transf_apply(length/2, width/2, tr_rot, 
00293                 &amp;curr_net-&gt;stop_x, &amp;curr_net-&gt;stop_y);
00294                 
00295             curr_net-&gt;aperture = 0;
00296             curr_net-&gt;layer_polarity = POSITIVE;
00297             curr_net-&gt;unit = MM;
00298             curr_net-&gt;aperture_state = ON;
00299             curr_net-&gt;interpolation = LINEARx1;
00300 
00301             curr_net-&gt;next = (gerb_net_t *)malloc(<span class="keyword">sizeof</span>(gerb_net_t));
00302             curr_net = curr_net-&gt;next;
00303             assert(curr_net);
00304             memset((<span class="keywordtype">void</span> *)curr_net, 0, <span class="keyword">sizeof</span>(gerb_net_t));
00305             
00306             <span class="keywordflow">if</span> (shape == PART_SHAPE_RECTANGLE) {
00307                 gerb_transf_apply(length/4, -width/2, tr_rot, 
00308                     &amp;curr_net-&gt;start_x, &amp;curr_net-&gt;start_y);
00309                 gerb_transf_apply(length/4, width/2, tr_rot, 
00310                     &amp;curr_net-&gt;stop_x, &amp;curr_net-&gt;stop_y);
00311             } <span class="keywordflow">else</span> {
00312                 gerb_transf_apply(length/4, width/2, tr_rot, 
00313                     &amp;curr_net-&gt;start_x, &amp;curr_net-&gt;start_y);
00314                 gerb_transf_apply(length/4, width/4, tr_rot, 
00315                     &amp;curr_net-&gt;stop_x, &amp;curr_net-&gt;stop_y);
00316                     
00317                 curr_net-&gt;aperture = 0;
00318                 curr_net-&gt;layer_polarity = POSITIVE;
00319                 curr_net-&gt;unit = MM;
00320                 curr_net-&gt;aperture_state = ON;
00321                 curr_net-&gt;interpolation = LINEARx1;
00322                 
00323                 curr_net-&gt;next = (gerb_net_t *)malloc(<span class="keyword">sizeof</span>(gerb_net_t));
00324                 curr_net = curr_net-&gt;next;
00325                 assert(curr_net);
00326                 memset((<span class="keywordtype">void</span> *)curr_net, 0, <span class="keyword">sizeof</span>(gerb_net_t));
00327                 gerb_transf_apply(length/2, width/4, tr_rot, 
00328                     &amp;curr_net-&gt;start_x, &amp;curr_net-&gt;start_y);
00329                 gerb_transf_apply(length/4, width/4, tr_rot, 
00330                     &amp;curr_net-&gt;stop_x, &amp;curr_net-&gt;stop_y);
00331                     
00332             }
00333                                 
00334                 
00335             curr_net-&gt;aperture = 0;
00336             curr_net-&gt;layer_polarity = POSITIVE;
00337             curr_net-&gt;unit = MM;
00338             curr_net-&gt;aperture_state = ON;
00339             curr_net-&gt;interpolation = LINEARx1;
00340             
00341             <span class="keywordflow">break</span>;
00342             
00343        <span class="keywordflow">case</span> PART_SHAPE_UNKNOWN:
00344        <span class="keywordflow">default</span>:
00345 
00346             curr_net-&gt;start_x = mid_x;
00347             curr_net-&gt;start_y = mid_y;
00348             curr_net-&gt;stop_x = pad_x;
00349             curr_net-&gt;stop_y = pad_y;
00350     
00351             curr_net-&gt;aperture = 0;
00352             curr_net-&gt;layer_polarity = POSITIVE;
00353             curr_net-&gt;unit = MM;
00354             curr_net-&gt;aperture_state = ON;
00355             curr_net-&gt;interpolation = LINEARx1;
00356         
00357             curr_net-&gt;next = (gerb_net_t *)malloc(<span class="keyword">sizeof</span>(gerb_net_t));
00358             curr_net = curr_net-&gt;next;
00359             assert(curr_net);
00360             memset((<span class="keywordtype">void</span> *)curr_net, 0, <span class="keyword">sizeof</span>(gerb_net_t));
00361   
00362 
00363             curr_net-&gt;start_x = mid_x;
00364             curr_net-&gt;start_y = mid_y;
00365             curr_net-&gt;stop_x = pad_x;
00366             curr_net-&gt;stop_y = pad_y;
00367     
00368             curr_net-&gt;aperture = 0;
00369             curr_net-&gt;layer_polarity = POSITIVE;
00370             curr_net-&gt;unit = MM;
00371             curr_net-&gt;aperture_state = ON;
00372             curr_net-&gt;interpolation = CW_CIRCULAR;
00373             curr_net-&gt;cirseg = (gerb_cirseg_t *)malloc(<span class="keyword">sizeof</span>(gerb_cirseg_t));
00374             memset((<span class="keywordtype">void</span> *)curr_net-&gt;cirseg, 0, <span class="keyword">sizeof</span>(gerb_cirseg_t));
00375             curr_net-&gt;cirseg-&gt;angle1 = 0.0;
00376             curr_net-&gt;cirseg-&gt;angle2 = 360.0;
00377             curr_net-&gt;cirseg-&gt;cp_x = mid_x;
00378             curr_net-&gt;cirseg-&gt;cp_y = mid_y;
00379             radius = sqrt((pad_x-mid_x)*(pad_x-mid_x) + (pad_y-mid_y)*(pad_y-mid_y));
00380             curr_net-&gt;cirseg-&gt;width = 2*radius; <span class="comment">/* fabs(pad_x-mid_x) */</span>
00381             curr_net-&gt;cirseg-&gt;height = 2*radius;
00382             <span class="keywordflow">break</span>;
00383        }
00384                            
00385         
00386        <span class="comment">// if (!no_files_found)   GERB_MESSAGE("%s %s: mid_x %f\n", designator, comment, mid_x);</span>
00387         g_free(designator);
00388         g_free(footprint);
00389         g_free(layer);
00390         g_free(comment);      
00391         
00392     } <span class="keywordflow">while</span> ((list = g_list_next(list)));
00393          
00394     curr_net-&gt;next = NULL;             
00395   <span class="comment">//  g_list_free (list);</span>
00396     gerb_transf_free(tr_rot);
00397 
00398     gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON
00399                              (<a class="code" href="gerbv_8c.html#a0">screen</a>.layer_button[idx]),TRUE); 
00400                               
00401     
00402 } <span class="comment">/* create_marked_layer */</span>
00403 
00404 <span class="preprocessor">#endif </span><span class="comment">/* USE_GTK2  */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Oct 13 16:09:21 2004 for gerbv by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.8-20040928 </small></address>
</body>
</html>
