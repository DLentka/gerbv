<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gerbv: src/amacro.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8-20040928 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a></div>
<h1>amacro.c</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * gEDA - GNU Electronic Design Automation</span>
00003 <span class="comment"> * This files is a part of gerbv.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> *   Copyright (C) 2000-2002 Stefan Petersen (spe@stacken.kth.se)</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> * $Id$</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
00010 <span class="comment"> * it under the terms of the GNU General Public License as published by</span>
00011 <span class="comment"> * the Free Software Foundation; either version 2 of the License, or</span>
00012 <span class="comment"> * (at your option) any later version.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
00015 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00016 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00017 <span class="comment"> * GNU General Public License for more details.</span>
00018 <span class="comment"> *</span>
00019 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
00020 <span class="comment"> * along with this program; if not, write to the Free Software</span>
00021 <span class="comment"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA</span>
00022 <span class="comment"> */</span>
00023 
00024 
00025 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00026 <span class="preprocessor">#include &lt;string.h&gt;</span>
00027 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00028 
00029 <span class="preprocessor">#include "amacro.h"</span>
00030 
00031 <span class="comment">/*</span>
00032 <span class="comment"> * Allocates a new instruction structure</span>
00033 <span class="comment"> */</span>
00034 <span class="keyword">static</span> instruction_t *
00035 new_instruction()
00036 {
00037     instruction_t *instruction;
00038 
00039     instruction = (instruction_t *)malloc(<span class="keyword">sizeof</span>(instruction_t));
00040     <span class="keywordflow">if</span> (instruction == NULL) {
00041        free(instruction);
00042        <span class="keywordflow">return</span> NULL;
00043     }
00044 
00045     memset(instruction, 0, <span class="keyword">sizeof</span>(instruction_t));
00046     
00047     <span class="keywordflow">return</span> instruction;
00048 } <span class="comment">/* new_instruction */</span>
00049 
00050 
00051 <span class="comment">/*</span>
00052 <span class="comment"> * Allocates a new amacro structure</span>
00053 <span class="comment"> */</span>
00054 <span class="keyword">static</span> amacro_t *
00055 new_amacro()
00056 {
00057     amacro_t *amacro;
00058 
00059     amacro = (amacro_t *)malloc(<span class="keyword">sizeof</span>(amacro_t));
00060     <span class="keywordflow">if</span> (amacro == NULL) {
00061        free(amacro);
00062        <span class="keywordflow">return</span> NULL;
00063     }
00064 
00065     memset(amacro, 0, <span class="keyword">sizeof</span>(amacro_t));
00066     
00067     <span class="keywordflow">return</span> amacro;
00068 } <span class="comment">/* new_amacro */</span>
00069 
00070 
00071 <span class="comment">/*</span>
00072 <span class="comment"> * Parses the definition of an aperture macro</span>
00073 <span class="comment"> */</span>
00074 amacro_t *
00075 parse_aperture_macro(gerb_file_t *fd)
00076 {
00077     amacro_t *amacro;
00078     instruction_t *ip = NULL;
00079     <span class="keywordtype">int</span> primitive = 0;
00080     <span class="keyword">enum</span> opcodes math_op = NOP;
00081     <span class="keywordtype">int</span> comma = 0, neg = 0; <span class="comment">/* negative numbers succeding , */</span>
00082 
00083     amacro = new_amacro();
00084 
00085     <span class="comment">/*</span>
00086 <span class="comment">     * Get macroname</span>
00087 <span class="comment">     */</span>
00088     amacro-&gt;name = gerb_fgetstring(fd, <span class="charliteral">'*'</span>);
00089 
00090     <span class="comment">/*</span>
00091 <span class="comment">     * Since I'm lazy I have a dummy head. Therefore the first </span>
00092 <span class="comment">     * instruction in all programs will be NOP.</span>
00093 <span class="comment">     */</span>
00094     amacro-&gt;program = new_instruction();
00095     ip = amacro-&gt;program;
00096 
00097     <span class="keywordflow">while</span>(1) {
00098        <span class="comment">/*</span>
00099 <span class="comment">        * First element describes which primitive element to use</span>
00100 <span class="comment">        */</span>
00101        <span class="keywordflow">if</span> (primitive == 0) {
00102            primitive = gerb_fgetint(fd, NULL);
00103        }
00104 
00105        <span class="keywordflow">switch</span> (gerb_fgetc(fd)) {
00106        <span class="keywordflow">case</span> <span class="charliteral">'$'</span>:
00107            ip-&gt;next = new_instruction(); <span class="comment">/* XXX Check return value */</span>
00108            ip = ip-&gt;next;
00109            ip-&gt;opcode = PPUSH;
00110            amacro-&gt;nuf_push++;
00111            ip-&gt;data.ival = gerb_fgetint(fd, NULL);
00112            comma = 0;
00113            <span class="keywordflow">break</span>;
00114        <span class="keywordflow">case</span> <span class="charliteral">'*'</span>:
00115            <span class="keywordflow">if</span> (math_op != NOP) {
00116               ip-&gt;next = new_instruction(); <span class="comment">/* XXX Check return value */</span>
00117               ip = ip-&gt;next;
00118               ip-&gt;opcode = math_op;
00119               math_op = NOP;
00120            }
00121            <span class="comment">/*</span>
00122 <span class="comment">            * Check is due to some gerber files has spurious empty lines.</span>
00123 <span class="comment">            * (EagleCad of course).</span>
00124 <span class="comment">            */</span>
00125            <span class="keywordflow">if</span> (primitive != 0) {
00126               ip-&gt;next = new_instruction(); <span class="comment">/* XXX Check return value */</span>
00127               ip = ip-&gt;next;
00128               ip-&gt;opcode = PRIM;
00129               ip-&gt;data.ival = primitive;
00130               primitive = 0;
00131            }
00132            <span class="keywordflow">break</span>;
00133        <span class="keywordflow">case</span> <span class="charliteral">','</span>:
00134            <span class="keywordflow">if</span> (math_op != NOP) {
00135               ip-&gt;next = new_instruction(); <span class="comment">/* XXX Check return value */</span>
00136               ip = ip-&gt;next;
00137               ip-&gt;opcode = math_op;
00138               math_op = NOP;
00139            }
00140            comma = 1;
00141            <span class="keywordflow">break</span>;
00142        <span class="keywordflow">case</span> <span class="charliteral">'+'</span>:
00143            <span class="keywordflow">if</span> (math_op != NOP) {
00144               ip-&gt;next = new_instruction(); <span class="comment">/* XXX Check return value */</span>
00145               ip = ip-&gt;next;
00146               ip-&gt;opcode = math_op;
00147            }
00148            math_op = ADD;
00149            <span class="keywordflow">break</span>;
00150        <span class="keywordflow">case</span> <span class="charliteral">'-'</span>:
00151            <span class="keywordflow">if</span> (comma) {
00152               neg = 1;
00153               comma = 0;
00154               <span class="keywordflow">break</span>;
00155            }
00156            <span class="keywordflow">if</span> (math_op != NOP) {
00157               ip-&gt;next = new_instruction(); <span class="comment">/* XXX Check return value */</span>
00158               ip = ip-&gt;next;
00159               ip-&gt;opcode = math_op;
00160            }
00161            math_op = SUB;
00162            <span class="keywordflow">break</span>;
00163        <span class="keywordflow">case</span> <span class="charliteral">'/'</span>:
00164            <span class="keywordflow">if</span> (math_op != NOP) {
00165               ip-&gt;next = new_instruction(); <span class="comment">/* XXX Check return value */</span>
00166               ip = ip-&gt;next;
00167               ip-&gt;opcode = math_op;
00168            }
00169            math_op = DIV;
00170            comma = 0;
00171            <span class="keywordflow">break</span>;
00172        <span class="keywordflow">case</span> <span class="charliteral">'X'</span>:
00173        <span class="keywordflow">case</span> <span class="charliteral">'x'</span>:
00174            <span class="keywordflow">if</span> (math_op != NOP) {
00175               ip-&gt;next = new_instruction(); <span class="comment">/* XXX Check return value */</span>
00176               ip = ip-&gt;next;
00177               ip-&gt;opcode = math_op;
00178            }
00179            math_op = MUL;
00180            comma = 0;
00181            <span class="keywordflow">break</span>;
00182        <span class="keywordflow">case</span> <span class="charliteral">'0'</span>:
00183        <span class="keywordflow">case</span> <span class="charliteral">'1'</span>:
00184        <span class="keywordflow">case</span> <span class="charliteral">'2'</span>:
00185        <span class="keywordflow">case</span> <span class="charliteral">'3'</span>:
00186        <span class="keywordflow">case</span> <span class="charliteral">'4'</span>:
00187        <span class="keywordflow">case</span> <span class="charliteral">'5'</span>:
00188        <span class="keywordflow">case</span> <span class="charliteral">'6'</span>:
00189        <span class="keywordflow">case</span> <span class="charliteral">'7'</span>:
00190        <span class="keywordflow">case</span> <span class="charliteral">'8'</span>:
00191        <span class="keywordflow">case</span> <span class="charliteral">'9'</span>:
00192            (void)gerb_ungetc(fd);
00193            ip-&gt;next = new_instruction(); <span class="comment">/* XXX Check return value */</span>
00194            ip = ip-&gt;next;
00195            ip-&gt;opcode = PUSH;
00196            amacro-&gt;nuf_push++;
00197            ip-&gt;data.fval = gerb_fgetdouble(fd);
00198            <span class="keywordflow">if</span> (neg) 
00199               ip-&gt;data.fval = -ip-&gt;data.fval;
00200            neg = 0;
00201            comma = 0;
00202            <span class="keywordflow">break</span>;
00203        <span class="keywordflow">case</span> <span class="charliteral">'%'</span>:
00204            gerb_ungetc(fd);  <span class="comment">/* Must return with % first in string</span>
00205 <span class="comment">                             since the main parser needs it */</span>
00206            <span class="keywordflow">return</span> amacro;
00207        <span class="keywordflow">default</span> :
00208            <span class="comment">/* Whitespace */</span>
00209            <span class="keywordflow">break</span>;
00210        }
00211     }
00212 }
00213 
00214 
00215 <span class="keywordtype">void</span> 
00216 free_amacro(amacro_t *amacro)
00217 {
00218     amacro_t *am1, *am2;
00219     instruction_t *instr1, *instr2;
00220     
00221     am1 = amacro;
00222     <span class="keywordflow">while</span> (am1 != NULL) {
00223        free(am1-&gt;name);
00224        am1-&gt;name = NULL;
00225 
00226        instr1 = am1-&gt;program;
00227        <span class="keywordflow">while</span> (instr1 != NULL) {
00228            instr2 = instr1;
00229            instr1 = instr1-&gt;next;
00230            free(instr2);
00231            instr2 = NULL;
00232        }
00233 
00234        am2 = am1;
00235        am1 = am1-&gt;next;
00236        free(am2);
00237        am2 = NULL;
00238     }
00239        
00240     <span class="keywordflow">return</span>;
00241 } <span class="comment">/* free_amacro */</span>
00242 
00243 
00244 <span class="keywordtype">void</span> 
00245 print_program(amacro_t *amacro)
00246 {
00247     instruction_t *ip;
00248 
00249     printf(<span class="stringliteral">"Macroname [%s] :\n"</span>, amacro-&gt;name);
00250     <span class="keywordflow">for</span> (ip = amacro-&gt;program ; ip != NULL; ip = ip-&gt;next) {
00251        <span class="keywordflow">switch</span>(ip-&gt;opcode) {
00252        <span class="keywordflow">case</span> NOP:
00253            printf(<span class="stringliteral">" NOP\n"</span>);
00254            <span class="keywordflow">break</span>;
00255        <span class="keywordflow">case</span> PUSH: 
00256            printf(<span class="stringliteral">" PUSH %f\n"</span>, ip-&gt;data.fval);
00257            <span class="keywordflow">break</span>;
00258        <span class="keywordflow">case</span> PPUSH:
00259            printf(<span class="stringliteral">" PPUSH %d\n"</span>, ip-&gt;data.ival);
00260            <span class="keywordflow">break</span>;
00261        <span class="keywordflow">case</span> ADD:
00262            printf(<span class="stringliteral">" ADD\n"</span>);
00263            <span class="keywordflow">break</span>;
00264        <span class="keywordflow">case</span> SUB:
00265            printf(<span class="stringliteral">" SUB\n"</span>);
00266            <span class="keywordflow">break</span>;
00267        <span class="keywordflow">case</span> MUL:
00268            printf(<span class="stringliteral">" MUL\n"</span>);
00269            <span class="keywordflow">break</span>;
00270        <span class="keywordflow">case</span> DIV:
00271            printf(<span class="stringliteral">" DIV\n"</span>);
00272            <span class="keywordflow">break</span>;
00273        <span class="keywordflow">case</span> PRIM:
00274            printf(<span class="stringliteral">" PRIM %d\n"</span>, ip-&gt;data.ival);
00275            <span class="keywordflow">break</span>;
00276        <span class="keywordflow">default</span> :
00277            printf(<span class="stringliteral">"  ERROR!\n"</span>);
00278            <span class="keywordflow">break</span>;
00279        }
00280     }
00281 } <span class="comment">/* print_program */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Oct 13 16:09:18 2004 for gerbv by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.8-20040928 </small></address>
</body>
</html>
