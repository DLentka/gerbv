<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gerbv: src/scheme.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8-20040928 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a></div>
<h1>scheme.c</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/* T I N Y S C H E M E    1 . 3 3</span>
00002 <span class="comment"> *   Dimitrios Souflis (dsouflis@acm.org)</span>
00003 <span class="comment"> *   Based on MiniScheme (original credits follow)</span>
00004 <span class="comment"> * (MINISCM)               coded by Atsushi Moriwaki (11/5/1989)</span>
00005 <span class="comment"> * (MINISCM)           E-MAIL :  moriwaki@kurims.kurims.kyoto-u.ac.jp</span>
00006 <span class="comment"> * (MINISCM) This version has been modified by R.C. Secrist.</span>
00007 <span class="comment"> * (MINISCM)</span>
00008 <span class="comment"> * (MINISCM) Mini-Scheme is now maintained by Akira KIDA.</span>
00009 <span class="comment"> * (MINISCM)</span>
00010 <span class="comment"> * (MINISCM) This is a revised and modified version by Akira KIDA.</span>
00011 <span class="comment"> * (MINISCM)  current version is 0.85k4 (15 May 1994)</span>
00012 <span class="comment"> *</span>
00013 <span class="comment"> */</span>
00014 
00015 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00016 <span class="preprocessor"></span><span class="preprocessor">#include &lt;config.h&gt;</span>
00017 <span class="preprocessor">#endif</span>
00018 <span class="preprocessor"></span>
00019 <span class="preprocessor">#define _SCHEME_SOURCE</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#include "scheme-private.h"</span>
00021 <span class="preprocessor">#if USE_DL</span>
00022 <span class="preprocessor"></span><span class="preprocessor"># include "dynload.h"</span>
00023 <span class="preprocessor">#endif</span>
00024 <span class="preprocessor"></span><span class="preprocessor">#if USE_MATH</span>
00025 <span class="preprocessor"></span><span class="preprocessor">#include &lt;math.h&gt;</span>
00026 <span class="preprocessor">#endif</span>
00027 <span class="preprocessor"></span><span class="preprocessor">#include &lt;limits.h&gt;</span>
00028 <span class="preprocessor">#include &lt;float.h&gt;</span>
00029 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00030 <span class="preprocessor">#ifdef HAVE_UNISTD_H</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#include &lt;unistd.h&gt;</span> <span class="comment">/* access() on Linux */</span>
00032 <span class="preprocessor">#endif</span>
00033 <span class="preprocessor"></span>
00034 <span class="preprocessor">#if USE_STRCASECMP</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#include &lt;strings.h&gt;</span>
00036 <span class="preprocessor">#define stricmp strcasecmp</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00038 <span class="preprocessor"></span>
00039 <span class="comment">/* Used for documentation purposes, to signal functions in 'interface' */</span>
00040 <span class="preprocessor">#define INTERFACE</span>
00041 <span class="preprocessor"></span>
00042 <span class="preprocessor">#define TOK_EOF     (-1)</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#define TOK_LPAREN  0</span>
00044 <span class="preprocessor"></span><span class="preprocessor">#define TOK_RPAREN  1</span>
00045 <span class="preprocessor"></span><span class="preprocessor">#define TOK_DOT     2</span>
00046 <span class="preprocessor"></span><span class="preprocessor">#define TOK_ATOM    3</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#define TOK_QUOTE   4</span>
00048 <span class="preprocessor"></span><span class="preprocessor">#define TOK_COMMENT 5</span>
00049 <span class="preprocessor"></span><span class="preprocessor">#define TOK_DQUOTE  6</span>
00050 <span class="preprocessor"></span><span class="preprocessor">#define TOK_BQUOTE  7</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#define TOK_COMMA   8</span>
00052 <span class="preprocessor"></span><span class="preprocessor">#define TOK_ATMARK  9</span>
00053 <span class="preprocessor"></span><span class="preprocessor">#define TOK_SHARP   10</span>
00054 <span class="preprocessor"></span><span class="preprocessor">#define TOK_SHARP_CONST 11</span>
00055 <span class="preprocessor"></span><span class="preprocessor">#define TOK_VEC     12</span>
00056 <span class="preprocessor"></span>
00057 <span class="preprocessor"># define BACKQUOTE '`'</span>
00058 <span class="preprocessor"></span>
00059 <span class="comment">/*</span>
00060 <span class="comment"> *  Basic memory allocation units</span>
00061 <span class="comment"> */</span>
00062 
00063 <span class="preprocessor">#define banner "TinyScheme 1.33"</span>
00064 <span class="preprocessor"></span>
00065 <span class="preprocessor">#ifdef HAVE_STRING_H</span>
00066 <span class="preprocessor"></span><span class="preprocessor">#include &lt;string.h&gt;</span>
00067 <span class="preprocessor">#endif</span>
00068 <span class="preprocessor"></span><span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00069 <span class="preprocessor">#ifndef macintosh</span>
00070 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_MALLOC_H</span>
00071 <span class="preprocessor"></span><span class="preprocessor"># include &lt;malloc.h&gt;</span>
00072 <span class="preprocessor">#endif</span>
00073 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00074 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> stricmp(<span class="keyword">const</span> <span class="keywordtype">char</span> *s1, <span class="keyword">const</span> <span class="keywordtype">char</span> *s2)
00075 {
00076   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c1, c2;
00077   <span class="keywordflow">do</span> {
00078     c1 = tolower(*s1);
00079     c2 = tolower(*s2);
00080     <span class="keywordflow">if</span> (c1 &lt; c2)
00081       <span class="keywordflow">return</span> -1;
00082     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (c1 &gt; c2)
00083       <span class="keywordflow">return</span> 1;
00084     s1++, s2++;
00085   } <span class="keywordflow">while</span> (c1 != 0);
00086   <span class="keywordflow">return</span> 0;
00087 }
00088 <span class="preprocessor">#endif </span><span class="comment">/* macintosh */</span>
00089 
00090 <span class="preprocessor">#if USE_STRLWR</span>
00091 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *strlwr(<span class="keywordtype">char</span> *s) {
00092   <span class="keyword">const</span> <span class="keywordtype">char</span> *p=s;
00093   <span class="keywordflow">while</span>(*s) {
00094     *s=tolower(*s);
00095     s++;
00096   }
00097   <span class="keywordflow">return</span> p;
00098 }
00099 <span class="preprocessor">#endif</span>
00100 <span class="preprocessor"></span>
00101 <span class="preprocessor">#ifndef prompt</span>
00102 <span class="preprocessor"></span><span class="preprocessor"># define prompt "&gt; "</span>
00103 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00104 <span class="preprocessor"></span>
00105 <span class="preprocessor">#ifndef InitFile</span>
00106 <span class="preprocessor"></span><span class="preprocessor"># define InitFile "init.scm"</span>
00107 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00108 <span class="preprocessor"></span>
00109 <span class="preprocessor">#ifndef FIRST_CELLSEGS</span>
00110 <span class="preprocessor"></span><span class="preprocessor"># define FIRST_CELLSEGS 3</span>
00111 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00112 <span class="preprocessor"></span>
00113 <span class="keyword">enum</span> scheme_types {
00114   T_STRING=1,
00115   T_NUMBER=2,
00116   T_SYMBOL=3,
00117   T_PROC=4,
00118   T_PAIR=5,
00119   T_CLOSURE=6,
00120   T_CONTINUATION=7,
00121   T_FOREIGN=8,
00122   T_CHARACTER=9,
00123   T_PORT=10,
00124   T_VECTOR=11,
00125   T_MACRO=12,
00126   T_PROMISE=13,
00127   T_ENVIRONMENT=14,
00128   T_LAST_SYSTEM_TYPE=14
00129 };
00130 
00131 <span class="comment">/* ADJ is enough slack to align cells in a TYPE_BITS-bit boundary */</span>
00132 <span class="preprocessor">#define ADJ 32</span>
00133 <span class="preprocessor"></span><span class="preprocessor">#define TYPE_BITS 5</span>
00134 <span class="preprocessor"></span><span class="preprocessor">#define T_MASKTYPE      31    </span><span class="comment">/* 0000000000011111 */</span>
00135 <span class="preprocessor">#define T_SYNTAX      4096    </span><span class="comment">/* 0001000000000000 */</span>
00136 <span class="preprocessor">#define T_IMMUTABLE   8192    </span><span class="comment">/* 0010000000000000 */</span>
00137 <span class="preprocessor">#define T_ATOM       16384    </span><span class="comment">/* 0100000000000000 */</span>   <span class="comment">/* only for gc */</span>
00138 <span class="preprocessor">#define CLRATOM      49151    </span><span class="comment">/* 1011111111111111 */</span>   <span class="comment">/* only for gc */</span>
00139 <span class="preprocessor">#define MARK         32768    </span><span class="comment">/* 1000000000000000 */</span>
00140 <span class="preprocessor">#define UNMARK       32767    </span><span class="comment">/* 0111111111111111 */</span>
00141 
00142 <span class="comment">/* operator code */</span>
00143 <span class="keyword">enum</span> scheme_opcodes { 
00144 <span class="preprocessor">#define _OP_DEF(A,B,C,D,E,OP) OP, </span>
00145 <span class="preprocessor"></span><span class="preprocessor">#include "opdefines.h"</span> 
00146   OP_MAXDEFINED 
00147 }; 
00148 
00149 
00150 <span class="keyword">static</span> num num_add(num a, num b);
00151 <span class="keyword">static</span> num num_mul(num a, num b);
00152 <span class="keyword">static</span> num num_div(num a, num b);
00153 <span class="keyword">static</span> num num_intdiv(num a, num b);
00154 <span class="keyword">static</span> num num_sub(num a, num b);
00155 <span class="keyword">static</span> num num_rem(num a, num b);
00156 <span class="keyword">static</span> num num_mod(num a, num b);
00157 <span class="keyword">static</span> <span class="keywordtype">int</span> num_eq(num a, num b);
00158 <span class="keyword">static</span> <span class="keywordtype">int</span> num_gt(num a, num b);
00159 <span class="keyword">static</span> <span class="keywordtype">int</span> num_ge(num a, num b);
00160 <span class="keyword">static</span> <span class="keywordtype">int</span> num_lt(num a, num b);
00161 <span class="keyword">static</span> <span class="keywordtype">int</span> num_le(num a, num b);
00162 
00163 <span class="preprocessor">#if USE_MATH</span>
00164 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">double</span> round_per_R5RS(<span class="keywordtype">double</span> x);
00165 <span class="preprocessor">#endif</span>
00166 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> is_zero_double(<span class="keywordtype">double</span> x);
00167 
00168 <span class="keyword">static</span> num num_zero;
00169 <span class="keyword">static</span> num num_one;
00170 
00171 <span class="comment">/* macros for cell operations */</span>
00172 <span class="preprocessor">#define typeflag(p)      ((p)-&gt;_flag)</span>
00173 <span class="preprocessor"></span><span class="preprocessor">#define type(p)          (typeflag(p)&amp;T_MASKTYPE)</span>
00174 <span class="preprocessor"></span>
00175 INTERFACE INLINE <span class="keywordtype">int</span> is_string(pointer p)     { <span class="keywordflow">return</span> (type(p)==T_STRING); }
00176 <span class="preprocessor">#define strvalue(p)      ((p)-&gt;_object._string._svalue)</span>
00177 <span class="preprocessor"></span><span class="preprocessor">#define strlength(p)        ((p)-&gt;_object._string._length)</span>
00178 <span class="preprocessor"></span>
00179 INTERFACE INLINE <span class="keywordtype">int</span> is_vector(pointer p)    { <span class="keywordflow">return</span> (type(p)==T_VECTOR); }
00180 INTERFACE <span class="keyword">static</span> <span class="keywordtype">void</span> fill_vector(pointer vec, pointer obj);
00181 INTERFACE <span class="keyword">static</span> pointer vector_elem(pointer vec, <span class="keywordtype">int</span> ielem);
00182 INTERFACE <span class="keyword">static</span> pointer set_vector_elem(pointer vec, <span class="keywordtype">int</span> ielem, pointer a);
00183 INTERFACE INLINE <span class="keywordtype">int</span> is_number(pointer p)    { <span class="keywordflow">return</span> (type(p)==T_NUMBER); }
00184 INTERFACE INLINE <span class="keywordtype">int</span> is_integer(pointer p) { 
00185   <span class="keywordflow">return</span> ((p)-&gt;_object._number.is_fixnum); 
00186 }
00187 INTERFACE INLINE <span class="keywordtype">int</span> is_real(pointer p) { 
00188   <span class="keywordflow">return</span> (!(p)-&gt;_object._number.is_fixnum); 
00189 }
00190 
00191 INTERFACE INLINE <span class="keywordtype">int</span> is_character(pointer p) { <span class="keywordflow">return</span> (type(p)==T_CHARACTER); }
00192 INTERFACE INLINE <span class="keywordtype">char</span> *string_value(pointer p) { <span class="keywordflow">return</span> strvalue(p); }
00193 INLINE num nvalue(pointer p)       { <span class="keywordflow">return</span> ((p)-&gt;_object._number); }
00194 INTERFACE <span class="keywordtype">long</span> ivalue(pointer p)      { <span class="keywordflow">return</span> (is_integer(p)?(p)-&gt;_object._number.value.ivalue:(long)(p)-&gt;_object._number.value.rvalue); }
00195 INTERFACE <span class="keywordtype">double</span> rvalue(pointer p)    { <span class="keywordflow">return</span> (!is_integer(p)?(p)-&gt;_object._number.value.rvalue:(double)(p)-&gt;_object._number.value.ivalue); }
00196 <span class="preprocessor">#define ivalue_unchecked(p)       ((p)-&gt;_object._number.value.ivalue)</span>
00197 <span class="preprocessor"></span><span class="preprocessor">#define rvalue_unchecked(p)       ((p)-&gt;_object._number.value.rvalue)</span>
00198 <span class="preprocessor"></span><span class="preprocessor">#define set_integer(p)   (p)-&gt;_object._number.is_fixnum=1;</span>
00199 <span class="preprocessor"></span><span class="preprocessor">#define set_real(p)      (p)-&gt;_object._number.is_fixnum=0;</span>
00200 <span class="preprocessor"></span>INTERFACE  <span class="keywordtype">long</span> charvalue(pointer p)  { <span class="keywordflow">return</span> ivalue_unchecked(p); }
00201 
00202 INTERFACE INLINE <span class="keywordtype">int</span> is_port(pointer p)     { <span class="keywordflow">return</span> (type(p)==T_PORT); }
00203 <span class="preprocessor">#define is_inport(p) (type(p)==T_PORT &amp;&amp; p-&gt;_object._port-&gt;kind&amp;port_input)</span>
00204 <span class="preprocessor"></span><span class="preprocessor">#define is_outport(p) (type(p)==T_PORT &amp;&amp; p-&gt;_object._port-&gt;kind&amp;port_output)</span>
00205 <span class="preprocessor"></span>
00206 INTERFACE INLINE <span class="keywordtype">int</span> is_pair(pointer p)     { <span class="keywordflow">return</span> (type(p)==T_PAIR); }
00207 <span class="preprocessor">#define car(p)           ((p)-&gt;_object._cons._car)</span>
00208 <span class="preprocessor"></span><span class="preprocessor">#define cdr(p)           ((p)-&gt;_object._cons._cdr)</span>
00209 <span class="preprocessor"></span>INTERFACE pointer pair_car(pointer p)   { <span class="keywordflow">return</span> car(p); }
00210 INTERFACE pointer pair_cdr(pointer p)   { <span class="keywordflow">return</span> cdr(p); }
00211 INTERFACE pointer set_car(pointer p, pointer q) { <span class="keywordflow">return</span> car(p)=q; }
00212 INTERFACE pointer set_cdr(pointer p, pointer q) { <span class="keywordflow">return</span> cdr(p)=q; }
00213 
00214 INTERFACE INLINE <span class="keywordtype">int</span> is_symbol(pointer p)   { <span class="keywordflow">return</span> (type(p)==T_SYMBOL); }
00215 INTERFACE INLINE <span class="keywordtype">char</span> *symname(pointer p)   { <span class="keywordflow">return</span> strvalue(car(p)); }
00216 <span class="preprocessor">#if USE_PLIST</span>
00217 <span class="preprocessor"></span>SCHEME_EXPORT INLINE <span class="keywordtype">int</span> hasprop(pointer p)     { <span class="keywordflow">return</span> (typeflag(p)&amp;T_SYMBOL); }
00218 <span class="preprocessor">#define symprop(p)       cdr(p)</span>
00219 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00220 <span class="preprocessor"></span>
00221 INTERFACE INLINE <span class="keywordtype">int</span> is_syntax(pointer p)   { <span class="keywordflow">return</span> (typeflag(p)&amp;T_SYNTAX); }
00222 INTERFACE INLINE <span class="keywordtype">int</span> is_proc(pointer p)     { <span class="keywordflow">return</span> (type(p)==T_PROC); }
00223 INTERFACE INLINE <span class="keywordtype">int</span> is_foreign(pointer p)  { <span class="keywordflow">return</span> (type(p)==T_FOREIGN); }
00224 INTERFACE INLINE <span class="keywordtype">char</span> *syntaxname(pointer p) { <span class="keywordflow">return</span> strvalue(car(p)); }
00225 <span class="preprocessor">#define procnum(p)       ivalue(p)</span>
00226 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *procname(pointer x);
00227 
00228 INTERFACE INLINE <span class="keywordtype">int</span> is_closure(pointer p)  { <span class="keywordflow">return</span> (type(p)==T_CLOSURE); }
00229 INTERFACE INLINE <span class="keywordtype">int</span> is_macro(pointer p)    { <span class="keywordflow">return</span> (type(p)==T_MACRO); }
00230 INTERFACE INLINE pointer closure_code(pointer p)   { <span class="keywordflow">return</span> car(p); }
00231 INTERFACE INLINE pointer closure_env(pointer p)    { <span class="keywordflow">return</span> cdr(p); }
00232 
00233 INTERFACE INLINE <span class="keywordtype">int</span> is_continuation(pointer p)    { <span class="keywordflow">return</span> (type(p)==T_CONTINUATION); }
00234 <span class="preprocessor">#define cont_dump(p)     cdr(p)</span>
00235 <span class="preprocessor"></span>
00236 <span class="comment">/* To do: promise should be forced ONCE only */</span>
00237 INTERFACE INLINE <span class="keywordtype">int</span> is_promise(pointer p)  { <span class="keywordflow">return</span> (type(p)==T_PROMISE); }
00238 
00239 INTERFACE INLINE <span class="keywordtype">int</span> is_environment(pointer p) { <span class="keywordflow">return</span> (type(p)==T_ENVIRONMENT); }
00240 <span class="preprocessor">#define setenvironment(p)    typeflag(p) = T_ENVIRONMENT</span>
00241 <span class="preprocessor"></span>
00242 <span class="preprocessor">#define is_atom(p)       (typeflag(p)&amp;T_ATOM)</span>
00243 <span class="preprocessor"></span><span class="preprocessor">#define setatom(p)       typeflag(p) |= T_ATOM</span>
00244 <span class="preprocessor"></span><span class="preprocessor">#define clratom(p)       typeflag(p) &amp;= CLRATOM</span>
00245 <span class="preprocessor"></span>
00246 <span class="preprocessor">#define is_mark(p)       (typeflag(p)&amp;MARK)</span>
00247 <span class="preprocessor"></span><span class="preprocessor">#define setmark(p)       typeflag(p) |= MARK</span>
00248 <span class="preprocessor"></span><span class="preprocessor">#define clrmark(p)       typeflag(p) &amp;= UNMARK</span>
00249 <span class="preprocessor"></span>
00250 INTERFACE INLINE <span class="keywordtype">int</span> is_immutable(pointer p) { <span class="keywordflow">return</span> (typeflag(p)&amp;T_IMMUTABLE); }
00251 <span class="comment">/*#define setimmutable(p)  typeflag(p) |= T_IMMUTABLE*/</span>
00252 INTERFACE INLINE <span class="keywordtype">void</span> setimmutable(pointer p) { typeflag(p) |= T_IMMUTABLE; }
00253 
00254 <span class="preprocessor">#define caar(p)          car(car(p))</span>
00255 <span class="preprocessor"></span><span class="preprocessor">#define cadr(p)          car(cdr(p))</span>
00256 <span class="preprocessor"></span><span class="preprocessor">#define cdar(p)          cdr(car(p))</span>
00257 <span class="preprocessor"></span><span class="preprocessor">#define cddr(p)          cdr(cdr(p))</span>
00258 <span class="preprocessor"></span><span class="preprocessor">#define cadar(p)         car(cdr(car(p)))</span>
00259 <span class="preprocessor"></span><span class="preprocessor">#define caddr(p)         car(cdr(cdr(p)))</span>
00260 <span class="preprocessor"></span><span class="preprocessor">#define cadaar(p)        car(cdr(car(car(p))))</span>
00261 <span class="preprocessor"></span><span class="preprocessor">#define cadddr(p)        car(cdr(cdr(cdr(p))))</span>
00262 <span class="preprocessor"></span><span class="preprocessor">#define cddddr(p)        cdr(cdr(cdr(cdr(p))))</span>
00263 <span class="preprocessor"></span>
00264 <span class="preprocessor">#if USE_CHAR_CLASSIFIERS</span>
00265 <span class="preprocessor"></span><span class="keyword">static</span> INLINE <span class="keywordtype">int</span> Cisalpha(<span class="keywordtype">int</span> c) { <span class="keywordflow">return</span> isascii(c) &amp;&amp; isalpha(c); }
00266 <span class="keyword">static</span> INLINE <span class="keywordtype">int</span> Cisdigit(<span class="keywordtype">int</span> c) { <span class="keywordflow">return</span> isascii(c) &amp;&amp; isdigit(c); }
00267 <span class="keyword">static</span> INLINE <span class="keywordtype">int</span> Cisspace(<span class="keywordtype">int</span> c) { <span class="keywordflow">return</span> isascii(c) &amp;&amp; isspace(c); }
00268 <span class="keyword">static</span> INLINE <span class="keywordtype">int</span> Cisupper(<span class="keywordtype">int</span> c) { <span class="keywordflow">return</span> isascii(c) &amp;&amp; isupper(c); }
00269 <span class="keyword">static</span> INLINE <span class="keywordtype">int</span> Cislower(<span class="keywordtype">int</span> c) { <span class="keywordflow">return</span> isascii(c) &amp;&amp; islower(c); }
00270 <span class="preprocessor">#endif</span>
00271 <span class="preprocessor"></span>
00272 <span class="preprocessor">#if USE_ASCII_NAMES</span>
00273 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *charnames[32]={
00274  <span class="stringliteral">"nul"</span>,
00275  <span class="stringliteral">"soh"</span>,
00276  <span class="stringliteral">"stx"</span>,
00277  <span class="stringliteral">"etx"</span>,
00278  <span class="stringliteral">"eot"</span>,
00279  <span class="stringliteral">"enq"</span>,
00280  <span class="stringliteral">"ack"</span>,
00281  <span class="stringliteral">"bel"</span>,
00282  <span class="stringliteral">"bs"</span>,
00283  <span class="stringliteral">"ht"</span>,
00284  <span class="stringliteral">"lf"</span>,
00285  <span class="stringliteral">"vt"</span>,
00286  <span class="stringliteral">"ff"</span>,
00287  <span class="stringliteral">"cr"</span>,
00288  <span class="stringliteral">"so"</span>,
00289  <span class="stringliteral">"si"</span>,
00290  <span class="stringliteral">"dle"</span>,
00291  <span class="stringliteral">"dc1"</span>,
00292  <span class="stringliteral">"dc2"</span>,
00293  <span class="stringliteral">"dc3"</span>,
00294  <span class="stringliteral">"dc4"</span>,
00295  <span class="stringliteral">"nak"</span>,
00296  <span class="stringliteral">"syn"</span>,
00297  <span class="stringliteral">"etb"</span>,
00298  <span class="stringliteral">"can"</span>,
00299  <span class="stringliteral">"em"</span>,
00300  <span class="stringliteral">"sub"</span>,
00301  <span class="stringliteral">"esc"</span>,
00302  <span class="stringliteral">"fs"</span>,
00303  <span class="stringliteral">"gs"</span>,
00304  <span class="stringliteral">"rs"</span>,
00305  <span class="stringliteral">"us"</span>
00306 };
00307 
00308 <span class="keyword">static</span> <span class="keywordtype">int</span> is_ascii_name(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> *pc) {
00309   <span class="keywordtype">int</span> i;
00310   <span class="keywordflow">for</span>(i=0; i&lt;32; i++) {
00311      <span class="keywordflow">if</span>(stricmp(name,charnames[i])==0) {
00312           *pc=i;
00313           <span class="keywordflow">return</span> 1;
00314      }
00315   }
00316   <span class="keywordflow">if</span>(stricmp(name,<span class="stringliteral">"del"</span>)==0) {
00317      *pc=127;
00318      <span class="keywordflow">return</span> 1;
00319   }
00320   <span class="keywordflow">return</span> 0;
00321 }
00322 
00323 <span class="preprocessor">#endif</span>
00324 <span class="preprocessor"></span>
00325 <span class="keyword">static</span> <span class="keywordtype">int</span> file_push(scheme *sc, <span class="keyword">const</span> <span class="keywordtype">char</span> *fname);
00326 <span class="keyword">static</span> <span class="keywordtype">void</span> file_pop(scheme *sc);
00327 <span class="keyword">static</span> <span class="keywordtype">int</span> file_interactive(scheme *sc);
00328 <span class="keyword">static</span> INLINE <span class="keywordtype">int</span> is_one_of(<span class="keywordtype">char</span> *s, <span class="keywordtype">int</span> c);
00329 <span class="keyword">static</span> <span class="keywordtype">int</span> alloc_cellseg(scheme *sc, <span class="keywordtype">int</span> n);
00330 <span class="keyword">static</span> <span class="keywordtype">long</span> binary_decode(<span class="keyword">const</span> <span class="keywordtype">char</span> *s);
00331 <span class="keyword">static</span> INLINE pointer get_cell(scheme *sc, pointer a, pointer b);
00332 <span class="keyword">static</span> pointer _get_cell(scheme *sc, pointer a, pointer b);
00333 <span class="keyword">static</span> pointer get_consecutive_cells(scheme *sc, <span class="keywordtype">int</span> n);
00334 <span class="keyword">static</span> pointer find_consecutive_cells(scheme *sc, <span class="keywordtype">int</span> n);
00335 <span class="keyword">static</span> <span class="keywordtype">void</span> finalize_cell(scheme *sc, pointer a);
00336 <span class="keyword">static</span> <span class="keywordtype">int</span> count_consecutive_cells(pointer x, <span class="keywordtype">int</span> needed);
00337 <span class="keyword">static</span> pointer find_slot_in_env(scheme *sc, pointer env, pointer sym, <span class="keywordtype">int</span> all);
00338 <span class="keyword">static</span> pointer mk_number(scheme *sc, num n);
00339 <span class="keyword">static</span> pointer mk_empty_string(scheme *sc, <span class="keywordtype">int</span> len, <span class="keywordtype">char</span> fill);
00340 <span class="keyword">static</span> <span class="keywordtype">char</span> *store_string(scheme *sc, <span class="keywordtype">int</span> len, <span class="keyword">const</span> <span class="keywordtype">char</span> *str, <span class="keywordtype">char</span> fill);
00341 <span class="keyword">static</span> pointer mk_vector(scheme *sc, <span class="keywordtype">int</span> len);
00342 <span class="keyword">static</span> pointer mk_atom(scheme *sc, <span class="keywordtype">char</span> *q);
00343 <span class="keyword">static</span> pointer mk_sharp_const(scheme *sc, <span class="keywordtype">char</span> *name);
00344 <span class="keyword">static</span> pointer mk_port(scheme *sc, port *p);
00345 <span class="keyword">static</span> pointer port_from_filename(scheme *sc, <span class="keyword">const</span> <span class="keywordtype">char</span> *fn, <span class="keywordtype">int</span> prop);
00346 <span class="keyword">static</span> pointer port_from_file(scheme *sc, FILE *, <span class="keywordtype">int</span> prop);
00347 <span class="keyword">static</span> pointer port_from_string(scheme *sc, <span class="keywordtype">char</span> *start, <span class="keywordtype">char</span> *past_the_end, <span class="keywordtype">int</span> prop);
00348 <span class="keyword">static</span> port *port_rep_from_filename(scheme *sc, <span class="keyword">const</span> <span class="keywordtype">char</span> *fn, <span class="keywordtype">int</span> prop);
00349 <span class="keyword">static</span> port *port_rep_from_file(scheme *sc, FILE *, <span class="keywordtype">int</span> prop);
00350 <span class="keyword">static</span> port *port_rep_from_string(scheme *sc, <span class="keywordtype">char</span> *start, <span class="keywordtype">char</span> *past_the_end, <span class="keywordtype">int</span> prop);
00351 <span class="keyword">static</span> <span class="keywordtype">void</span> port_close(scheme *sc, pointer p, <span class="keywordtype">int</span> flag);
00352 <span class="keyword">static</span> <span class="keywordtype">void</span> mark(pointer a);
00353 <span class="keyword">static</span> <span class="keywordtype">void</span> gc(scheme *sc, pointer a, pointer b);
00354 <span class="keyword">static</span> <span class="keywordtype">int</span> basic_inchar(port *pt);
00355 <span class="keyword">static</span> <span class="keywordtype">int</span> inchar(scheme *sc);
00356 <span class="keyword">static</span> <span class="keywordtype">void</span> backchar(scheme *sc, <span class="keywordtype">int</span> c);
00357 <span class="keyword">static</span> <span class="keywordtype">char</span>   *readstr_upto(scheme *sc, <span class="keywordtype">char</span> *delim);
00358 <span class="keyword">static</span> pointer readstrexp(scheme *sc);
00359 <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> skipspace(scheme *sc);
00360 <span class="keyword">static</span> <span class="keywordtype">int</span> token(scheme *sc);
00361 <span class="keyword">static</span> <span class="keywordtype">void</span> printslashstring(scheme *sc, <span class="keywordtype">char</span> *s, <span class="keywordtype">int</span> len);
00362 <span class="keyword">static</span> <span class="keywordtype">void</span> atom2str(scheme *sc, pointer l, <span class="keywordtype">int</span> f, <span class="keywordtype">char</span> **pp, <span class="keywordtype">int</span> *plen);
00363 <span class="keyword">static</span> <span class="keywordtype">void</span> printatom(scheme *sc, pointer l, <span class="keywordtype">int</span> f);
00364 <span class="keyword">static</span> pointer mk_proc(scheme *sc, <span class="keyword">enum</span> scheme_opcodes op);
00365 <span class="keyword">static</span> pointer mk_closure(scheme *sc, pointer c, pointer e);
00366 <span class="keyword">static</span> pointer mk_continuation(scheme *sc, pointer d);
00367 <span class="keyword">static</span> pointer reverse(scheme *sc, pointer a);
00368 <span class="keyword">static</span> pointer reverse_in_place(scheme *sc, pointer term, pointer list);
00369 <span class="keyword">static</span> pointer append(scheme *sc, pointer a, pointer b);
00370 <span class="keyword">static</span> <span class="keywordtype">int</span> list_length(scheme *sc, pointer a);
00371 <span class="keyword">static</span> <span class="keywordtype">int</span> eqv(pointer a, pointer b);
00372 <span class="keyword">static</span> <span class="keywordtype">void</span> dump_stack_mark(scheme *);
00373 <span class="keyword">static</span> pointer opexe_0(scheme *sc, <span class="keyword">enum</span> scheme_opcodes op);
00374 <span class="keyword">static</span> pointer opexe_1(scheme *sc, <span class="keyword">enum</span> scheme_opcodes op);
00375 <span class="keyword">static</span> pointer opexe_2(scheme *sc, <span class="keyword">enum</span> scheme_opcodes op);
00376 <span class="keyword">static</span> pointer opexe_3(scheme *sc, <span class="keyword">enum</span> scheme_opcodes op);
00377 <span class="keyword">static</span> pointer opexe_4(scheme *sc, <span class="keyword">enum</span> scheme_opcodes op);
00378 <span class="keyword">static</span> pointer opexe_5(scheme *sc, <span class="keyword">enum</span> scheme_opcodes op);
00379 <span class="keyword">static</span> pointer opexe_6(scheme *sc, <span class="keyword">enum</span> scheme_opcodes op);
00380 <span class="keyword">static</span> <span class="keywordtype">void</span> Eval_Cycle(scheme *sc, <span class="keyword">enum</span> scheme_opcodes op);
00381 <span class="keyword">static</span> <span class="keywordtype">void</span> assign_syntax(scheme *sc, <span class="keywordtype">char</span> *name);
00382 <span class="keyword">static</span> <span class="keywordtype">int</span> syntaxnum(pointer p);
00383 <span class="keyword">static</span> <span class="keywordtype">void</span> assign_proc(scheme *sc, <span class="keyword">enum</span> scheme_opcodes, <span class="keywordtype">char</span> *name);
00384 
00385 <span class="preprocessor">#define num_ivalue(n)       (n.is_fixnum?(n).value.ivalue:(long)(n).value.rvalue)</span>
00386 <span class="preprocessor"></span><span class="preprocessor">#define num_rvalue(n)       (!n.is_fixnum?(n).value.rvalue:(double)(n).value.ivalue)</span>
00387 <span class="preprocessor"></span>
00388 <span class="keyword">static</span> num num_add(num a, num b) {
00389  num ret;
00390  ret.is_fixnum=a.is_fixnum &amp;&amp; b.is_fixnum;
00391  <span class="keywordflow">if</span>(ret.is_fixnum) {
00392      ret.value.ivalue= a.value.ivalue+b.value.ivalue;
00393  } <span class="keywordflow">else</span> {
00394      ret.value.rvalue=num_rvalue(a)+num_rvalue(b);
00395  }
00396  <span class="keywordflow">return</span> ret;
00397 }
00398 
00399 <span class="keyword">static</span> num num_mul(num a, num b) {
00400  num ret;
00401  ret.is_fixnum=a.is_fixnum &amp;&amp; b.is_fixnum;
00402  <span class="keywordflow">if</span>(ret.is_fixnum) {
00403      ret.value.ivalue= a.value.ivalue*b.value.ivalue;
00404  } <span class="keywordflow">else</span> {
00405      ret.value.rvalue=num_rvalue(a)*num_rvalue(b);
00406  }
00407  <span class="keywordflow">return</span> ret;
00408 }
00409 
00410 <span class="keyword">static</span> num num_div(num a, num b) {
00411  num ret;
00412  ret.is_fixnum=a.is_fixnum &amp;&amp; b.is_fixnum &amp;&amp; a.value.ivalue%b.value.ivalue==0;
00413  <span class="keywordflow">if</span>(ret.is_fixnum) {
00414      ret.value.ivalue= a.value.ivalue/b.value.ivalue;
00415  } <span class="keywordflow">else</span> {
00416      ret.value.rvalue=num_rvalue(a)/num_rvalue(b);
00417  }
00418  <span class="keywordflow">return</span> ret;
00419 }
00420 
00421 <span class="keyword">static</span> num num_intdiv(num a, num b) {
00422  num ret;
00423  ret.is_fixnum=a.is_fixnum &amp;&amp; b.is_fixnum;
00424  <span class="keywordflow">if</span>(ret.is_fixnum) {
00425      ret.value.ivalue= a.value.ivalue/b.value.ivalue;
00426  } <span class="keywordflow">else</span> {
00427      ret.value.rvalue=num_rvalue(a)/num_rvalue(b);
00428  }
00429  <span class="keywordflow">return</span> ret;
00430 }
00431 
00432 <span class="keyword">static</span> num num_sub(num a, num b) {
00433  num ret;
00434  ret.is_fixnum=a.is_fixnum &amp;&amp; b.is_fixnum;
00435  <span class="keywordflow">if</span>(ret.is_fixnum) {
00436      ret.value.ivalue= a.value.ivalue-b.value.ivalue;
00437  } <span class="keywordflow">else</span> {
00438      ret.value.rvalue=num_rvalue(a)-num_rvalue(b);
00439  }
00440  <span class="keywordflow">return</span> ret;
00441 }
00442 
00443 <span class="keyword">static</span> num num_rem(num a, num b) {
00444  num ret;
00445  <span class="keywordtype">long</span> e1, e2, res;
00446  ret.is_fixnum=a.is_fixnum &amp;&amp; b.is_fixnum;
00447  e1=num_ivalue(a);
00448  e2=num_ivalue(b);
00449  res=e1%e2;
00450  <span class="keywordflow">if</span>(res*e1&lt;0) {    <span class="comment">/* remainder should have same sign as first operand */</span>
00451      e2=labs(e2);
00452      <span class="keywordflow">if</span>(res&gt;0) {
00453           res-=e2;
00454      } <span class="keywordflow">else</span> {
00455           res+=e2;
00456      }
00457  }
00458  ret.value.ivalue=res;
00459  <span class="keywordflow">return</span> ret;
00460 }
00461 
00462 <span class="keyword">static</span> num num_mod(num a, num b) {
00463  num ret;
00464  <span class="keywordtype">long</span> e1, e2, res;
00465  ret.is_fixnum=a.is_fixnum &amp;&amp; b.is_fixnum;
00466  e1=num_ivalue(a);
00467  e2=num_ivalue(b);
00468  res=e1%e2;
00469  <span class="keywordflow">if</span>(res*e2&lt;0) {    <span class="comment">/* modulo should have same sign as second operand */</span>
00470      e2=labs(e2);
00471      <span class="keywordflow">if</span>(res&gt;0) {
00472           res-=e2;
00473      } <span class="keywordflow">else</span> {
00474           res+=e2;
00475      }
00476  }
00477  ret.value.ivalue=res;
00478  <span class="keywordflow">return</span> ret;
00479 }
00480 
00481 <span class="keyword">static</span> <span class="keywordtype">int</span> num_eq(num a, num b) {
00482  <span class="keywordtype">int</span> ret;
00483  <span class="keywordtype">int</span> is_fixnum=a.is_fixnum &amp;&amp; b.is_fixnum;
00484  <span class="keywordflow">if</span>(is_fixnum) {
00485      ret= a.value.ivalue==b.value.ivalue;
00486  } <span class="keywordflow">else</span> {
00487      ret=num_rvalue(a)==num_rvalue(b);
00488  }
00489  <span class="keywordflow">return</span> ret;
00490 }
00491 
00492 
00493 <span class="keyword">static</span> <span class="keywordtype">int</span> num_gt(num a, num b) {
00494  <span class="keywordtype">int</span> ret;
00495  <span class="keywordtype">int</span> is_fixnum=a.is_fixnum &amp;&amp; b.is_fixnum;
00496  <span class="keywordflow">if</span>(is_fixnum) {
00497      ret= a.value.ivalue&gt;b.value.ivalue;
00498  } <span class="keywordflow">else</span> {
00499      ret=num_rvalue(a)&gt;num_rvalue(b);
00500  }
00501  <span class="keywordflow">return</span> ret;
00502 }
00503 
00504 <span class="keyword">static</span> <span class="keywordtype">int</span> num_ge(num a, num b) {
00505  <span class="keywordflow">return</span> !num_lt(a,b);
00506 }
00507 
00508 <span class="keyword">static</span> <span class="keywordtype">int</span> num_lt(num a, num b) {
00509  <span class="keywordtype">int</span> ret;
00510  <span class="keywordtype">int</span> is_fixnum=a.is_fixnum &amp;&amp; b.is_fixnum;
00511  <span class="keywordflow">if</span>(is_fixnum) {
00512      ret= a.value.ivalue&lt;b.value.ivalue;
00513  } <span class="keywordflow">else</span> {
00514      ret=num_rvalue(a)&lt;num_rvalue(b);
00515  }
00516  <span class="keywordflow">return</span> ret;
00517 }
00518 
00519 <span class="keyword">static</span> <span class="keywordtype">int</span> num_le(num a, num b) {
00520  <span class="keywordflow">return</span> !num_gt(a,b);
00521 }
00522 
00523 <span class="preprocessor">#if USE_MATH</span>
00524 <span class="preprocessor"></span><span class="comment">/* Round to nearest. Round to even if midway */</span>
00525 <span class="keyword">static</span> <span class="keywordtype">double</span> round_per_R5RS(<span class="keywordtype">double</span> x) {
00526  <span class="keywordtype">double</span> fl=floor(x);
00527  <span class="keywordtype">double</span> ce=ceil(x);
00528  <span class="keywordtype">double</span> dfl=x-fl;
00529  <span class="keywordtype">double</span> dce=ce-x;
00530  <span class="keywordflow">if</span>(dfl&gt;dce) {
00531      <span class="keywordflow">return</span> ce;
00532  } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(dfl&lt;dce) {
00533      <span class="keywordflow">return</span> fl;
00534  } <span class="keywordflow">else</span> {
00535      <span class="keywordflow">if</span>(fmod(fl,2.0)==0.0) {       <span class="comment">/* I imagine this holds */</span>
00536           <span class="keywordflow">return</span> fl;
00537      } <span class="keywordflow">else</span> {
00538           <span class="keywordflow">return</span> ce;
00539      }
00540  }
00541 }
00542 <span class="preprocessor">#endif</span>
00543 <span class="preprocessor"></span>
00544 <span class="keyword">static</span> <span class="keywordtype">int</span> is_zero_double(<span class="keywordtype">double</span> x) {
00545  <span class="keywordflow">return</span> x&lt;DBL_MIN &amp;&amp; x&gt;-DBL_MIN;
00546 }
00547 
00548 <span class="keyword">static</span> <span class="keywordtype">long</span> binary_decode(<span class="keyword">const</span> <span class="keywordtype">char</span> *s) {
00549  <span class="keywordtype">long</span> x=0;
00550 
00551  <span class="keywordflow">while</span>(*s!=0 &amp;&amp; (*s==<span class="charliteral">'1'</span> || *s==<span class="charliteral">'0'</span>)) {
00552      x&lt;&lt;=1;
00553      x+=*s-<span class="charliteral">'0'</span>;
00554      s++;
00555  }
00556 
00557  <span class="keywordflow">return</span> x;
00558 }
00559 
00560 <span class="comment">/* allocate new cell segment */</span>
00561 <span class="keyword">static</span> <span class="keywordtype">int</span> alloc_cellseg(scheme *sc, <span class="keywordtype">int</span> n) {
00562      pointer newp;
00563      pointer last;
00564      pointer p;
00565      <span class="keywordtype">char</span> *cp;
00566      <span class="keywordtype">long</span> i;
00567      <span class="keywordtype">int</span> k;
00568      <span class="keywordtype">int</span> adj=ADJ;
00569 
00570      <span class="keywordflow">if</span>(adj&lt;<span class="keyword">sizeof</span>(<span class="keyword">struct </span>cell)) {
00571        adj=<span class="keyword">sizeof</span>(<span class="keyword">struct </span>cell);
00572      }
00573 
00574      <span class="keywordflow">for</span> (k = 0; k &lt; n; k++) {
00575           <span class="keywordflow">if</span> (sc-&gt;last_cell_seg &gt;= CELL_NSEGMENT - 1)
00576                <span class="keywordflow">return</span> k;
00577           cp = (<span class="keywordtype">char</span>*) sc-&gt;malloc(CELL_SEGSIZE * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> cell)+adj);
00578           <span class="keywordflow">if</span> (cp == 0)
00579                <span class="keywordflow">return</span> k;
00580          i = ++sc-&gt;last_cell_seg ;
00581          sc-&gt;alloc_seg[i] = cp;
00582          <span class="comment">/* adjust in TYPE_BITS-bit boundary */</span>
00583          <span class="keywordflow">if</span>((long)cp%adj!=0) {
00584            cp=(<span class="keywordtype">char</span>*)(adj*((long)cp/adj+1));
00585          }
00586         <span class="comment">/* insert new segment in address order */</span>
00587          newp=(pointer)cp;
00588         sc-&gt;cell_seg[i] = newp;
00589         <span class="keywordflow">while</span> (i &gt; 0 &amp;&amp; sc-&gt;cell_seg[i - 1] &gt; sc-&gt;cell_seg[i]) {
00590               p = sc-&gt;cell_seg[i];
00591             sc-&gt;cell_seg[i] = sc-&gt;cell_seg[i - 1];
00592             sc-&gt;cell_seg[--i] = p;
00593         }
00594           sc-&gt;fcells += CELL_SEGSIZE;
00595         last = newp + CELL_SEGSIZE - 1;
00596           <span class="keywordflow">for</span> (p = newp; p &lt;= last; p++) {
00597                typeflag(p) = 0;
00598                cdr(p) = p + 1;
00599                car(p) = sc-&gt;NIL;
00600           }
00601         <span class="comment">/* insert new cells in address order on free list */</span>
00602         <span class="keywordflow">if</span> (sc-&gt;free_cell == sc-&gt;NIL || p &lt; sc-&gt;free_cell) {
00603              cdr(last) = sc-&gt;free_cell;
00604              sc-&gt;free_cell = newp;
00605         } <span class="keywordflow">else</span> {
00606               p = sc-&gt;free_cell;
00607               <span class="keywordflow">while</span> (cdr(p) != sc-&gt;NIL &amp;&amp; newp &gt; cdr(p))
00608                    p = cdr(p);
00609               cdr(last) = cdr(p);
00610               cdr(p) = newp;
00611         }
00612      }
00613      <span class="keywordflow">return</span> n;
00614 }
00615 
00616 <span class="keyword">static</span> INLINE pointer get_cell(scheme *sc, pointer a, pointer b) {
00617   <span class="keywordflow">if</span> (sc-&gt;free_cell != sc-&gt;NIL) {
00618     pointer x = sc-&gt;free_cell;
00619     sc-&gt;free_cell = cdr(x);
00620     --sc-&gt;fcells;
00621     <span class="keywordflow">return</span> (x);
00622   } 
00623   <span class="keywordflow">return</span> _get_cell (sc, a, b);
00624 }
00625 
00626 
00627 <span class="comment">/* get new cell.  parameter a, b is marked by gc. */</span>
00628 <span class="keyword">static</span> pointer _get_cell(scheme *sc, pointer a, pointer b) {
00629   pointer x;
00630 
00631   <span class="keywordflow">if</span>(sc-&gt;no_memory) {
00632     <span class="keywordflow">return</span> sc-&gt;sink;
00633   }
00634   
00635   <span class="keywordflow">if</span> (sc-&gt;free_cell == sc-&gt;NIL) {
00636     gc(sc,a, b);
00637     <span class="keywordflow">if</span> (sc-&gt;fcells &lt; sc-&gt;last_cell_seg*8
00638        || sc-&gt;free_cell == sc-&gt;NIL) {
00639       <span class="comment">/* if only a few recovered, get more to avoid fruitless gc's */</span>
00640       <span class="keywordflow">if</span> (!alloc_cellseg(sc,1) &amp;&amp; sc-&gt;free_cell == sc-&gt;NIL) {
00641        sc-&gt;no_memory=1;
00642        <span class="keywordflow">return</span> sc-&gt;sink;
00643       }
00644     }
00645   }
00646   x = sc-&gt;free_cell;
00647   sc-&gt;free_cell = cdr(x);
00648   --sc-&gt;fcells;
00649   <span class="keywordflow">return</span> (x);
00650 }
00651 
00652 <span class="keyword">static</span> pointer get_consecutive_cells(scheme *sc, <span class="keywordtype">int</span> n) {
00653   pointer x;
00654 
00655   <span class="keywordflow">if</span>(sc-&gt;no_memory) {
00656     <span class="keywordflow">return</span> sc-&gt;sink;
00657   }
00658   
00659   <span class="comment">/* Are there any cells available? */</span>
00660   x=find_consecutive_cells(sc,n);
00661   <span class="keywordflow">if</span> (x == sc-&gt;NIL) {
00662     <span class="comment">/* If not, try gc'ing some */</span>
00663     gc(sc, sc-&gt;NIL, sc-&gt;NIL);
00664     x=find_consecutive_cells(sc,n);
00665     <span class="keywordflow">if</span> (x == sc-&gt;NIL) {
00666       <span class="comment">/* If there still aren't, try getting more heap */</span>
00667       <span class="keywordflow">if</span> (!alloc_cellseg(sc,1)) {
00668        sc-&gt;no_memory=1;
00669        <span class="keywordflow">return</span> sc-&gt;sink;
00670       }
00671     }
00672     x=find_consecutive_cells(sc,n);
00673     <span class="keywordflow">if</span> (x == sc-&gt;NIL) {
00674       <span class="comment">/* If all fail, report failure */</span>
00675       sc-&gt;no_memory=1;
00676       <span class="keywordflow">return</span> sc-&gt;sink;
00677     }
00678   }
00679   <span class="keywordflow">return</span> (x);
00680 }
00681 
00682 <span class="keyword">static</span> <span class="keywordtype">int</span> count_consecutive_cells(pointer x, <span class="keywordtype">int</span> needed) {
00683  <span class="keywordtype">int</span> n=1;
00684  <span class="keywordflow">while</span>(cdr(x)==x+1) {
00685      x=cdr(x);
00686      n++;
00687      <span class="keywordflow">if</span>(n&gt;needed) <span class="keywordflow">return</span> n;
00688  }
00689  <span class="keywordflow">return</span> n;
00690 }
00691 
00692 <span class="keyword">static</span> pointer find_consecutive_cells(scheme *sc, <span class="keywordtype">int</span> n) {
00693   pointer *pp;
00694   <span class="keywordtype">int</span> cnt;
00695   
00696   pp=&amp;sc-&gt;free_cell;
00697   <span class="keywordflow">while</span>(*pp!=sc-&gt;NIL) {
00698     cnt=count_consecutive_cells(*pp,n);
00699     <span class="keywordflow">if</span>(cnt&gt;=n) {
00700       pointer x=*pp;
00701       *pp=cdr(*pp+n-1);
00702       sc-&gt;fcells -= n;
00703       <span class="keywordflow">return</span> x;
00704     }
00705     pp=&amp;cdr(*pp+cnt-1);
00706   }
00707   <span class="keywordflow">return</span> sc-&gt;NIL;
00708 }
00709 
00710 <span class="comment">/* get new cons cell */</span>
00711 pointer _cons(scheme *sc, pointer a, pointer b, <span class="keywordtype">int</span> immutable) {
00712   pointer x = get_cell(sc,a, b);
00713 
00714   typeflag(x) = T_PAIR;
00715   <span class="keywordflow">if</span>(immutable) {
00716     setimmutable(x);
00717   }
00718   car(x) = a;
00719   cdr(x) = b;
00720   <span class="keywordflow">return</span> (x);
00721 }
00722 
00723 <span class="comment">/* ========== oblist implementation  ========== */</span> 
00724 
00725 <span class="preprocessor">#ifndef USE_OBJECT_LIST </span>
00726 <span class="preprocessor"></span>
00727 <span class="keyword">static</span> <span class="keywordtype">int</span> hash_fn(<span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">int</span> table_size); 
00728 
00729 <span class="keyword">static</span> pointer oblist_initial_value(scheme *sc) 
00730 { 
00731   <span class="keywordflow">return</span> mk_vector(sc, 461); <span class="comment">/* probably should be bigger */</span> 
00732 } 
00733 
00734 <span class="comment">/* returns the new symbol */</span> 
00735 <span class="keyword">static</span> pointer oblist_add_by_name(scheme *sc, <span class="keyword">const</span> <span class="keywordtype">char</span> *name) 
00736 { 
00737   pointer x; 
00738   <span class="keywordtype">int</span> location; 
00739 
00740   x = immutable_cons(sc, mk_string(sc, name), sc-&gt;NIL); 
00741   typeflag(x) = T_SYMBOL; 
00742   setimmutable(car(x)); 
00743 
00744   location = hash_fn(name, ivalue_unchecked(sc-&gt;oblist)); 
00745   set_vector_elem(sc-&gt;oblist, location, 
00746                   immutable_cons(sc, x, vector_elem(sc-&gt;oblist, location))); 
00747   <span class="keywordflow">return</span> x; 
00748 } 
00749 
00750 <span class="keyword">static</span> INLINE pointer oblist_find_by_name(scheme *sc, <span class="keyword">const</span> <span class="keywordtype">char</span> *name) 
00751 { 
00752   <span class="keywordtype">int</span> location; 
00753   pointer x; 
00754   <span class="keywordtype">char</span> *s; 
00755 
00756   location = hash_fn(name, ivalue_unchecked(sc-&gt;oblist)); 
00757   <span class="keywordflow">for</span> (x = vector_elem(sc-&gt;oblist, location); x != sc-&gt;NIL; x = cdr(x)) { 
00758     s = symname(car(x)); 
00759     <span class="comment">/* case-insensitive, per R5RS section 2. */</span> 
00760     <span class="keywordflow">if</span>(stricmp(name, s) == 0) { 
00761       <span class="keywordflow">return</span> car(x); 
00762     } 
00763   } 
00764   <span class="keywordflow">return</span> sc-&gt;NIL; 
00765 } 
00766 
00767 <span class="keyword">static</span> pointer oblist_all_symbols(scheme *sc) 
00768 { 
00769   <span class="keywordtype">int</span> i; 
00770   pointer x; 
00771   pointer ob_list = sc-&gt;NIL; 
00772 
00773   <span class="keywordflow">for</span> (i = 0; i &lt; ivalue_unchecked(sc-&gt;oblist); i++) { 
00774     <span class="keywordflow">for</span> (x  = vector_elem(sc-&gt;oblist, i); x != sc-&gt;NIL; x = cdr(x)) { 
00775       ob_list = cons(sc, x, ob_list); 
00776     } 
00777   } 
00778   <span class="keywordflow">return</span> ob_list; 
00779 } 
00780 
00781 <span class="preprocessor">#else </span>
00782 <span class="preprocessor"></span>
00783 <span class="keyword">static</span> pointer oblist_initial_value(scheme *sc) 
00784 { 
00785   <span class="keywordflow">return</span> sc-&gt;NIL; 
00786 } 
00787 
00788 <span class="keyword">static</span> INLINE pointer oblist_find_by_name(scheme *sc, <span class="keyword">const</span> <span class="keywordtype">char</span> *name) 
00789 { 
00790      pointer x; 
00791      <span class="keywordtype">char</span>    *s; 
00792 
00793      <span class="keywordflow">for</span> (x = sc-&gt;oblist; x != sc-&gt;NIL; x = cdr(x)) { 
00794         s = symname(car(x)); 
00795         <span class="comment">/* case-insensitive, per R5RS section 2. */</span> 
00796         <span class="keywordflow">if</span>(stricmp(name, s) == 0) { 
00797           <span class="keywordflow">return</span> car(x); 
00798         } 
00799      } 
00800      <span class="keywordflow">return</span> sc-&gt;NIL; 
00801 } 
00802 
00803 <span class="comment">/* returns the new symbol */</span> 
00804 <span class="keyword">static</span> pointer oblist_add_by_name(scheme *sc, <span class="keyword">const</span> <span class="keywordtype">char</span> *name) 
00805 { 
00806   pointer x; 
00807 
00808   x = immutable_cons(sc, mk_string(sc, name), sc-&gt;NIL); 
00809   typeflag(x) = T_SYMBOL; 
00810   setimmutable(car(x)); 
00811   sc-&gt;oblist = immutable_cons(sc, x, sc-&gt;oblist); 
00812   <span class="keywordflow">return</span> x; 
00813 } 
00814 <span class="keyword">static</span> pointer oblist_all_symbols(scheme *sc) 
00815 { 
00816   <span class="keywordflow">return</span> sc-&gt;oblist; 
00817 } 
00818 
00819 <span class="preprocessor">#endif </span>
00820 <span class="preprocessor"></span>
00821 <span class="keyword">static</span> pointer mk_port(scheme *sc, port *p) {
00822   pointer x = get_cell(sc, sc-&gt;NIL, sc-&gt;NIL);
00823   
00824   typeflag(x) = T_PORT|T_ATOM;
00825   x-&gt;_object._port=p;
00826   <span class="keywordflow">return</span> (x);
00827 }
00828 
00829 pointer mk_foreign_func(scheme *sc, foreign_func f) {
00830   pointer x = get_cell(sc, sc-&gt;NIL, sc-&gt;NIL);
00831   
00832   typeflag(x) = (T_FOREIGN | T_ATOM);
00833   x-&gt;_object._ff=f;
00834   <span class="keywordflow">return</span> (x);
00835 }
00836 
00837 INTERFACE pointer mk_character(scheme *sc, <span class="keywordtype">int</span> c) {
00838   pointer x = get_cell(sc,sc-&gt;NIL, sc-&gt;NIL);
00839 
00840   typeflag(x) = (T_CHARACTER | T_ATOM);
00841   ivalue_unchecked(x)= c;
00842   set_integer(x);
00843   <span class="keywordflow">return</span> (x);
00844 }
00845 
00846 <span class="comment">/* get number atom (integer) */</span>
00847 INTERFACE pointer mk_integer(scheme *sc, <span class="keywordtype">long</span> num) {
00848   pointer x = get_cell(sc,sc-&gt;NIL, sc-&gt;NIL);
00849 
00850   typeflag(x) = (T_NUMBER | T_ATOM);
00851   ivalue_unchecked(x)= num;
00852   set_integer(x);
00853   <span class="keywordflow">return</span> (x);
00854 }
00855 
00856 INTERFACE pointer mk_real(scheme *sc, <span class="keywordtype">double</span> n) {
00857   pointer x = get_cell(sc,sc-&gt;NIL, sc-&gt;NIL);
00858 
00859   typeflag(x) = (T_NUMBER | T_ATOM);
00860   rvalue_unchecked(x)= n;
00861   set_real(x);
00862   <span class="keywordflow">return</span> (x);
00863 }
00864 
00865 <span class="keyword">static</span> pointer mk_number(scheme *sc, num n) {
00866  <span class="keywordflow">if</span>(n.is_fixnum) {
00867      <span class="keywordflow">return</span> mk_integer(sc,n.value.ivalue);
00868  } <span class="keywordflow">else</span> {
00869      <span class="keywordflow">return</span> mk_real(sc,n.value.rvalue);
00870  }
00871 }
00872 
00873 <span class="comment">/* allocate name to string area */</span>
00874 <span class="keyword">static</span> <span class="keywordtype">char</span> *store_string(scheme *sc, <span class="keywordtype">int</span> len_str, <span class="keyword">const</span> <span class="keywordtype">char</span> *str, <span class="keywordtype">char</span> fill) {
00875      <span class="keywordtype">char</span> *q;
00876      
00877      q=(<span class="keywordtype">char</span>*)sc-&gt;malloc(len_str+1);
00878      <span class="keywordflow">if</span>(q==0) {
00879           sc-&gt;no_memory=1;
00880           <span class="keywordflow">return</span> sc-&gt;strbuff;
00881      }
00882      <span class="keywordflow">if</span>(str!=0) {
00883           strcpy(q, str);
00884      } <span class="keywordflow">else</span> {
00885           memset(q, fill, len_str);
00886           q[len_str]=0;
00887      }
00888      <span class="keywordflow">return</span> (q);
00889 }
00890 
00891 <span class="comment">/* get new string */</span>
00892 INTERFACE pointer mk_string(scheme *sc, <span class="keyword">const</span> <span class="keywordtype">char</span> *str) {
00893      <span class="keywordflow">return</span> mk_counted_string(sc,str,strlen(str));
00894 }
00895 
00896 INTERFACE pointer mk_counted_string(scheme *sc, <span class="keyword">const</span> <span class="keywordtype">char</span> *str, <span class="keywordtype">int</span> len) {
00897      pointer x = get_cell(sc, sc-&gt;NIL, sc-&gt;NIL);
00898 
00899      strvalue(x) = store_string(sc,len,str,0);
00900      typeflag(x) = (T_STRING | T_ATOM);
00901      strlength(x) = len;
00902      <span class="keywordflow">return</span> (x);
00903 }
00904 
00905 <span class="keyword">static</span> pointer mk_empty_string(scheme *sc, <span class="keywordtype">int</span> len, <span class="keywordtype">char</span> fill) {
00906      pointer x = get_cell(sc, sc-&gt;NIL, sc-&gt;NIL);
00907 
00908      strvalue(x) = store_string(sc,len,0,fill);
00909      typeflag(x) = (T_STRING | T_ATOM);
00910      strlength(x) = len;
00911      <span class="keywordflow">return</span> (x);
00912 }
00913 
00914 INTERFACE <span class="keyword">static</span> pointer mk_vector(scheme *sc, <span class="keywordtype">int</span> len) {
00915      pointer x=get_consecutive_cells(sc,len/2+len%2+1);
00916      typeflag(x) = (T_VECTOR | T_ATOM);
00917      ivalue_unchecked(x)=len;
00918      set_integer(x);
00919      fill_vector(x,sc-&gt;NIL);
00920      <span class="keywordflow">return</span> x;
00921 }
00922 
00923 INTERFACE <span class="keyword">static</span> <span class="keywordtype">void</span> fill_vector(pointer vec, pointer obj) {
00924      <span class="keywordtype">int</span> i;
00925      <span class="keywordtype">int</span> num=ivalue(vec)/2+ivalue(vec)%2;
00926      <span class="keywordflow">for</span>(i=0; i&lt;num; i++) {
00927           typeflag(vec+1+i) = T_PAIR;
00928           setimmutable(vec+1+i);
00929           car(vec+1+i)=obj;
00930           cdr(vec+1+i)=obj;
00931      }
00932 }
00933 
00934 INTERFACE <span class="keyword">static</span> pointer vector_elem(pointer vec, <span class="keywordtype">int</span> ielem) {
00935      <span class="keywordtype">int</span> n=ielem/2;
00936      <span class="keywordflow">if</span>(ielem%2==0) {
00937           <span class="keywordflow">return</span> car(vec+1+n);
00938      } <span class="keywordflow">else</span> {
00939           <span class="keywordflow">return</span> cdr(vec+1+n);
00940      }
00941 }
00942 
00943 INTERFACE <span class="keyword">static</span> pointer set_vector_elem(pointer vec, <span class="keywordtype">int</span> ielem, pointer a) {
00944      <span class="keywordtype">int</span> n=ielem/2;
00945      <span class="keywordflow">if</span>(ielem%2==0) {
00946           <span class="keywordflow">return</span> car(vec+1+n)=a;
00947      } <span class="keywordflow">else</span> {
00948           <span class="keywordflow">return</span> cdr(vec+1+n)=a;
00949      }
00950 }
00951 
00952 <span class="comment">/* get new symbol */</span>
00953 INTERFACE pointer mk_symbol(scheme *sc, <span class="keyword">const</span> <span class="keywordtype">char</span> *name) { 
00954      pointer x; 
00955 
00956      <span class="comment">/* first check oblist */</span> 
00957      x = oblist_find_by_name(sc, name); 
00958      <span class="keywordflow">if</span> (x != sc-&gt;NIL) { 
00959           <span class="keywordflow">return</span> (x); 
00960      } <span class="keywordflow">else</span> { 
00961           x = oblist_add_by_name(sc, name); 
00962           <span class="keywordflow">return</span> (x); 
00963      } 
00964 } 
00965 
00966 INTERFACE pointer gensym(scheme *sc) { 
00967      pointer x; 
00968      <span class="keywordtype">char</span> name[40]; 
00969 
00970      <span class="keywordflow">for</span>(; sc-&gt;gensym_cnt&lt;LONG_MAX; sc-&gt;gensym_cnt++) { 
00971           sprintf(name,<span class="stringliteral">"gensym-%ld"</span>,sc-&gt;gensym_cnt); 
00972 
00973           <span class="comment">/* first check oblist */</span> 
00974           x = oblist_find_by_name(sc, name); 
00975 
00976           <span class="keywordflow">if</span> (x != sc-&gt;NIL) { 
00977                <span class="keywordflow">continue</span>; 
00978           } <span class="keywordflow">else</span> { 
00979                x = oblist_add_by_name(sc, name); 
00980                <span class="keywordflow">return</span> (x); 
00981           } 
00982      } 
00983 
00984      <span class="keywordflow">return</span> sc-&gt;NIL; 
00985 } 
00986 
00987 <span class="comment">/* make symbol or number atom from string */</span>
00988 <span class="keyword">static</span> pointer mk_atom(scheme *sc, <span class="keywordtype">char</span> *q) {
00989      <span class="keywordtype">char</span>    c, *p;
00990      <span class="keywordtype">int</span> has_dec_point=0;
00991      <span class="keywordtype">int</span> has_fp_exp = 0;
00992 
00993 <span class="preprocessor">#if USE_COLON_HOOK</span>
00994 <span class="preprocessor"></span>     <span class="keywordflow">if</span>((p=strstr(q,<span class="stringliteral">"::"</span>))!=0) {
00995           *p=0;
00996           <span class="keywordflow">return</span> cons(sc, sc-&gt;COLON_HOOK,
00997                           cons(sc,
00998                               cons(sc,
00999                                    sc-&gt;QUOTE,
01000                                    cons(sc, mk_atom(sc,p+2), sc-&gt;NIL)),
01001                               cons(sc, mk_symbol(sc,strlwr(q)), sc-&gt;NIL)));
01002      }
01003 <span class="preprocessor">#endif</span>
01004 <span class="preprocessor"></span>
01005      p = q;
01006      c = *p++; 
01007      <span class="keywordflow">if</span> ((c == <span class="charliteral">'+'</span>) || (c == <span class="charliteral">'-'</span>)) { 
01008        c = *p++; 
01009        <span class="keywordflow">if</span> (c == <span class="charliteral">'.'</span>) { 
01010          has_dec_point=1; 
01011         c = *p++; 
01012        } 
01013        <span class="keywordflow">if</span> (!isdigit(c)) { 
01014         <span class="keywordflow">return</span> (mk_symbol(sc, strlwr(q))); 
01015        } 
01016      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (c == <span class="charliteral">'.'</span>) { 
01017        has_dec_point=1; 
01018        c = *p++; 
01019        <span class="keywordflow">if</span> (!isdigit(c)) { 
01020         <span class="keywordflow">return</span> (mk_symbol(sc, strlwr(q))); 
01021        } 
01022      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!isdigit(c)) { 
01023        <span class="keywordflow">return</span> (mk_symbol(sc, strlwr(q))); 
01024      }
01025 
01026      <span class="keywordflow">for</span> ( ; (c = *p) != 0; ++p) {
01027           <span class="keywordflow">if</span> (!isdigit(c)) {
01028                <span class="keywordflow">if</span>(c==<span class="charliteral">'.'</span>) {
01029                     <span class="keywordflow">if</span>(!has_dec_point) {
01030                          has_dec_point=1;
01031                          <span class="keywordflow">continue</span>;
01032                     }
01033                }
01034                <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((c == <span class="charliteral">'e'</span>) || (c == <span class="charliteral">'E'</span>)) {
01035                        <span class="keywordflow">if</span>(!has_fp_exp) {
01036                           has_dec_point = 1; <span class="comment">/* decimal point illegal</span>
01037 <span class="comment">                                                from now on */</span>
01038                           p++;
01039                           <span class="keywordflow">if</span> ((*p == <span class="charliteral">'-'</span>) || (*p == <span class="charliteral">'+'</span>) || isdigit(*p)) {
01040                              <span class="keywordflow">continue</span>;
01041                           }
01042                        }  
01043                }    
01044                <span class="keywordflow">return</span> (mk_symbol(sc, strlwr(q)));
01045           }
01046      }
01047      <span class="keywordflow">if</span>(has_dec_point) {
01048           <span class="keywordflow">return</span> mk_real(sc,atof(q));
01049      }
01050      <span class="keywordflow">return</span> (mk_integer(sc, atol(q)));
01051 }
01052 
01053 <span class="comment">/* make constant */</span>
01054 <span class="keyword">static</span> pointer mk_sharp_const(scheme *sc, <span class="keywordtype">char</span> *name) {
01055      <span class="keywordtype">long</span>    x;
01056      <span class="keywordtype">char</span>    tmp[256];
01057 
01058      <span class="keywordflow">if</span> (!strcmp(name, <span class="stringliteral">"t"</span>))
01059           <span class="keywordflow">return</span> (sc-&gt;T);
01060      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(name, <span class="stringliteral">"f"</span>))
01061           <span class="keywordflow">return</span> (sc-&gt;F);
01062      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*name == <span class="charliteral">'o'</span>) {<span class="comment">/* #o (octal) */</span>
01063           sprintf(tmp, <span class="stringliteral">"0%s"</span>, name+1);
01064           sscanf(tmp, <span class="stringliteral">"%lo"</span>, &amp;x);
01065           <span class="keywordflow">return</span> (mk_integer(sc, x));
01066      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*name == <span class="charliteral">'d'</span>) {    <span class="comment">/* #d (decimal) */</span>
01067           sscanf(name+1, <span class="stringliteral">"%ld"</span>, &amp;x);
01068           <span class="keywordflow">return</span> (mk_integer(sc, x));
01069      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*name == <span class="charliteral">'x'</span>) {    <span class="comment">/* #x (hex) */</span>
01070           sprintf(tmp, <span class="stringliteral">"0x%s"</span>, name+1);
01071           sscanf(tmp, <span class="stringliteral">"%lx"</span>, &amp;x);
01072           <span class="keywordflow">return</span> (mk_integer(sc, x));
01073      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*name == <span class="charliteral">'b'</span>) {    <span class="comment">/* #b (binary) */</span>
01074           x = binary_decode(name+1);
01075           <span class="keywordflow">return</span> (mk_integer(sc, x));
01076      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*name == <span class="charliteral">'\\'</span>) { <span class="comment">/* #\w (character) */</span>
01077           <span class="keywordtype">int</span> c=0;
01078           <span class="keywordflow">if</span>(stricmp(name+1,<span class="stringliteral">"space"</span>)==0) {
01079                c=<span class="charliteral">' '</span>;
01080           } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(stricmp(name+1,<span class="stringliteral">"newline"</span>)==0) {
01081                c=<span class="charliteral">'\n'</span>;
01082           } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(stricmp(name+1,<span class="stringliteral">"return"</span>)==0) {
01083                c=<span class="charliteral">'\r'</span>;
01084           } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(stricmp(name+1,<span class="stringliteral">"tab"</span>)==0) {
01085                c=<span class="charliteral">'\t'</span>;
01086      } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(name[1]==<span class="charliteral">'x'</span> &amp;&amp; name[2]!=0) {
01087           <span class="keywordtype">int</span> c1=0;
01088           <span class="keywordflow">if</span>(sscanf(name+2,<span class="stringliteral">"%x"</span>,&amp;c1)==1 &amp;&amp; c1&lt;256) {
01089                c=c1;
01090           } <span class="keywordflow">else</span> {
01091                <span class="keywordflow">return</span> sc-&gt;NIL;
01092      }
01093 <span class="preprocessor">#if USE_ASCII_NAMES</span>
01094 <span class="preprocessor"></span>          } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(is_ascii_name(name+1,&amp;c)) {
01095                <span class="comment">/* nothing */</span>
01096 <span class="preprocessor">#endif               </span>
01097 <span class="preprocessor"></span>          } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(name[2]==0) {
01098                c=name[1];
01099           } <span class="keywordflow">else</span> {
01100                <span class="keywordflow">return</span> sc-&gt;NIL;
01101           }
01102           <span class="keywordflow">return</span> mk_character(sc,c);
01103      } <span class="keywordflow">else</span>
01104           <span class="keywordflow">return</span> (sc-&gt;NIL);
01105 }
01106 
01107 <span class="comment">/* ========== garbage collector ========== */</span>
01108 
01109 <span class="comment">/*--</span>
01110 <span class="comment"> *  We use algorithm E (Knuth, The Art of Computer Programming Vol.1,</span>
01111 <span class="comment"> *  sec. 2.3.5), the Schorr-Deutsch-Waite link-inversion algorithm, </span>
01112 <span class="comment"> *  for marking. </span>
01113 <span class="comment"> */</span>
01114 <span class="keyword">static</span> <span class="keywordtype">void</span> mark(pointer a) {
01115      pointer t, q, p;
01116 
01117      t = (pointer) 0;
01118      p = a;
01119 E2:  setmark(p);
01120      <span class="keywordflow">if</span>(is_vector(p)) {
01121           <span class="keywordtype">int</span> i;
01122           <span class="keywordtype">int</span> num=ivalue_unchecked(p)/2+ivalue_unchecked(p)%2;
01123           <span class="keywordflow">for</span>(i=0; i&lt;num; i++) {
01124                <span class="comment">/* Vector cells will be treated like ordinary cells */</span>
01125                mark(p+1+i);
01126           }
01127      }
01128      <span class="keywordflow">if</span> (is_atom(p))
01129           <span class="keywordflow">goto</span> E6;
01130      <span class="comment">/* E4: down car */</span>
01131      q = car(p);
01132      <span class="keywordflow">if</span> (q &amp;&amp; !is_mark(q)) {
01133           setatom(p);  <span class="comment">/* a note that we have moved car */</span> 
01134           car(p) = t;
01135           t = p;
01136           p = q;
01137           <span class="keywordflow">goto</span> E2;
01138      }
01139  E5:  q = cdr(p); <span class="comment">/* down cdr */</span>
01140      <span class="keywordflow">if</span> (q &amp;&amp; !is_mark(q)) {
01141           cdr(p) = t;
01142           t = p;
01143           p = q;
01144           <span class="keywordflow">goto</span> E2;
01145      }
01146 E6:   <span class="comment">/* up.  Undo the link switching from steps E4 and E5. */</span> 
01147      <span class="keywordflow">if</span> (!t)
01148           <span class="keywordflow">return</span>;
01149      q = t;
01150      <span class="keywordflow">if</span> (is_atom(q)) {
01151           clratom(q);
01152           t = car(q);
01153           car(q) = p;
01154           p = q;
01155           <span class="keywordflow">goto</span> E5;
01156      } <span class="keywordflow">else</span> {
01157           t = cdr(q);
01158           cdr(q) = p;
01159           p = q;
01160           <span class="keywordflow">goto</span> E6;
01161      }
01162 }
01163 
01164 <span class="comment">/* garbage collection. parameter a, b is marked. */</span>
01165 <span class="keyword">static</span> <span class="keywordtype">void</span> gc(scheme *sc, pointer a, pointer b) {
01166   pointer p;
01167   <span class="keywordtype">int</span> i;
01168   
01169   <span class="keywordflow">if</span>(sc-&gt;gc_verbose) {
01170     putstr(sc, <span class="stringliteral">"gc..."</span>);
01171   }
01172 
01173   <span class="comment">/* mark system globals */</span>
01174   mark(sc-&gt;oblist);
01175   mark(sc-&gt;global_env);
01176 
01177   <span class="comment">/* mark current registers */</span>
01178   mark(sc-&gt;args);
01179   mark(sc-&gt;envir);
01180   mark(sc-&gt;code);
01181   dump_stack_mark(sc); 
01182   mark(sc-&gt;value);
01183   mark(sc-&gt;inport);
01184   mark(sc-&gt;save_inport);
01185   mark(sc-&gt;outport);
01186   mark(sc-&gt;loadport);
01187 
01188   <span class="comment">/* mark variables a, b */</span>
01189   mark(a);
01190   mark(b);
01191 
01192   <span class="comment">/* garbage collect */</span>
01193   clrmark(sc-&gt;NIL);
01194   sc-&gt;fcells = 0;
01195   sc-&gt;free_cell = sc-&gt;NIL;
01196   <span class="comment">/* free-list is kept sorted by address so as to maintain consecutive</span>
01197 <span class="comment">     ranges, if possible, for use with vectors. Here we scan the cells</span>
01198 <span class="comment">     (which are also kept sorted by address) downwards to build the</span>
01199 <span class="comment">     free-list in sorted order.</span>
01200 <span class="comment">  */</span>
01201   <span class="keywordflow">for</span> (i = sc-&gt;last_cell_seg; i &gt;= 0; i--) {
01202     p = sc-&gt;cell_seg[i] + CELL_SEGSIZE;
01203     <span class="keywordflow">while</span> (--p &gt;= sc-&gt;cell_seg[i]) {
01204       <span class="keywordflow">if</span> (is_mark(p)) {
01205        clrmark(p);
01206       } <span class="keywordflow">else</span> {
01207        <span class="comment">/* reclaim cell */</span>
01208         <span class="keywordflow">if</span> (typeflag(p) != 0) { 
01209           finalize_cell(sc, p); 
01210           typeflag(p) = 0; 
01211           ++sc-&gt;fcells; 
01212           car(p) = sc-&gt;NIL; 
01213         } 
01214         cdr(p) = sc-&gt;free_cell; 
01215         sc-&gt;free_cell = p; 
01216       }
01217     }
01218   }
01219   
01220   <span class="keywordflow">if</span> (sc-&gt;gc_verbose) {
01221     <span class="keywordtype">char</span> msg[80];
01222     sprintf(msg,<span class="stringliteral">"done: %ld cells were recovered.\n"</span>, sc-&gt;fcells);
01223     putstr(sc,msg);
01224   }
01225 }
01226 
01227 <span class="keyword">static</span> <span class="keywordtype">void</span> finalize_cell(scheme *sc, pointer a) {
01228   <span class="keywordflow">if</span>(is_string(a)) {
01229     sc-&gt;free(strvalue(a));
01230   } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(is_port(a)) {
01231     <span class="keywordflow">if</span>(a-&gt;_object._port-&gt;kind&amp;port_file 
01232        &amp;&amp; a-&gt;_object._port-&gt;rep.stdio.closeit) {
01233       port_close(sc,a,port_input|port_output);
01234     }
01235     sc-&gt;free(a-&gt;_object._port);
01236   }
01237 }
01238 
01239 <span class="comment">/* ========== Routines for Reading ========== */</span>
01240 
01241 <span class="keyword">static</span> <span class="keywordtype">int</span> file_push(scheme *sc, <span class="keyword">const</span> <span class="keywordtype">char</span> *fname) {
01242   FILE *fin=fopen(fname,<span class="stringliteral">"r"</span>);
01243   <span class="keywordflow">if</span>(fin!=0) {
01244     sc-&gt;file_i++;
01245     sc-&gt;load_stack[sc-&gt;file_i].kind=port_file|port_input;
01246     sc-&gt;load_stack[sc-&gt;file_i].rep.stdio.file=fin;
01247     sc-&gt;load_stack[sc-&gt;file_i].rep.stdio.closeit=1;
01248     sc-&gt;nesting_stack[sc-&gt;file_i]=0;
01249     sc-&gt;loadport-&gt;_object._port=sc-&gt;load_stack+sc-&gt;file_i;
01250   }
01251   <span class="keywordflow">return</span> fin!=0;
01252 }
01253 
01254 <span class="keyword">static</span> <span class="keywordtype">void</span> file_pop(scheme *sc) {
01255  sc-&gt;nesting=sc-&gt;nesting_stack[sc-&gt;file_i];
01256  <span class="keywordflow">if</span>(sc-&gt;file_i!=0) {
01257    port_close(sc,sc-&gt;loadport,port_input);
01258    sc-&gt;file_i--;
01259    sc-&gt;loadport-&gt;_object._port=sc-&gt;load_stack+sc-&gt;file_i;
01260    <span class="keywordflow">if</span>(file_interactive(sc)) {
01261      putstr(sc,prompt);
01262    }
01263  }
01264 }
01265 
01266 <span class="keyword">static</span> <span class="keywordtype">int</span> file_interactive(scheme *sc) {
01267  <span class="keywordflow">return</span> sc-&gt;file_i==0 &amp;&amp; sc-&gt;load_stack[0].rep.stdio.file==stdin
01268      &amp;&amp; sc-&gt;inport-&gt;_object._port-&gt;kind&amp;port_file;
01269 }
01270 
01271 <span class="keyword">static</span> port *port_rep_from_filename(scheme *sc, <span class="keyword">const</span> <span class="keywordtype">char</span> *fn, <span class="keywordtype">int</span> prop) {
01272   FILE *f;
01273   <span class="keywordtype">char</span> *rw;
01274   port *pt;
01275   <span class="keywordflow">if</span>(prop==(port_input|port_output)) {
01276     rw=<span class="stringliteral">"a+"</span>;
01277   } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(prop==port_output) {
01278     rw=<span class="stringliteral">"w"</span>;
01279   } <span class="keywordflow">else</span> {
01280     rw=<span class="stringliteral">"r"</span>;
01281   }
01282   f=fopen(fn,rw);
01283   <span class="keywordflow">if</span>(f==0) {
01284     <span class="keywordflow">return</span> 0;
01285   }
01286   pt=port_rep_from_file(sc,f,prop);
01287   pt-&gt;rep.stdio.closeit=1;
01288   <span class="keywordflow">return</span> pt;
01289 }
01290 
01291 <span class="keyword">static</span> pointer port_from_filename(scheme *sc, <span class="keyword">const</span> <span class="keywordtype">char</span> *fn, <span class="keywordtype">int</span> prop) {
01292   port *pt;
01293   pt=port_rep_from_filename(sc,fn,prop);
01294   <span class="keywordflow">if</span>(pt==0) {
01295     <span class="keywordflow">return</span> sc-&gt;NIL;
01296   }
01297   <span class="keywordflow">return</span> mk_port(sc,pt);
01298 }
01299 
01300 <span class="keyword">static</span> port *port_rep_from_file(scheme *sc, FILE *f, <span class="keywordtype">int</span> prop) {
01301   <span class="keywordtype">char</span> *rw;
01302   port *pt;
01303   pt=sc-&gt;malloc(<span class="keyword">sizeof</span>(port));
01304   <span class="keywordflow">if</span>(pt==0) {
01305     <span class="keywordflow">return</span> 0;
01306   }
01307   <span class="keywordflow">if</span>(prop==(port_input|port_output)) {
01308     rw=<span class="stringliteral">"a+"</span>;
01309   } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(prop==port_output) {
01310     rw=<span class="stringliteral">"w"</span>;
01311   } <span class="keywordflow">else</span> {
01312     rw=<span class="stringliteral">"r"</span>;
01313   }
01314   pt-&gt;kind=port_file|prop;
01315   pt-&gt;rep.stdio.file=f;
01316   pt-&gt;rep.stdio.closeit=0;
01317   <span class="keywordflow">return</span> pt;
01318 }
01319 
01320 <span class="keyword">static</span> pointer port_from_file(scheme *sc, FILE *f, <span class="keywordtype">int</span> prop) {
01321   port *pt;
01322   pt=port_rep_from_file(sc,f,prop);
01323   <span class="keywordflow">if</span>(pt==0) {
01324     <span class="keywordflow">return</span> sc-&gt;NIL;
01325   }
01326   <span class="keywordflow">return</span> mk_port(sc,pt);
01327 }
01328 
01329 <span class="keyword">static</span> port *port_rep_from_string(scheme *sc, <span class="keywordtype">char</span> *start, <span class="keywordtype">char</span> *past_the_end, <span class="keywordtype">int</span> prop) {
01330   port *pt;
01331   pt=sc-&gt;malloc(<span class="keyword">sizeof</span>(port));
01332   <span class="keywordflow">if</span>(pt==0) {
01333     <span class="keywordflow">return</span> 0;
01334   }
01335   pt-&gt;kind=port_string|prop;
01336   pt-&gt;rep.string.start=start;
01337   pt-&gt;rep.string.curr=start;
01338   pt-&gt;rep.string.past_the_end=past_the_end;
01339   <span class="keywordflow">return</span> pt;
01340 }
01341 
01342 <span class="keyword">static</span> pointer port_from_string(scheme *sc, <span class="keywordtype">char</span> *start, <span class="keywordtype">char</span> *past_the_end, <span class="keywordtype">int</span> prop) {
01343   port *pt;
01344   pt=port_rep_from_string(sc,start,past_the_end,prop);
01345   <span class="keywordflow">if</span>(pt==0) {
01346     <span class="keywordflow">return</span> sc-&gt;NIL;
01347   }
01348   <span class="keywordflow">return</span> mk_port(sc,pt);
01349 }
01350 
01351 <span class="keyword">static</span> <span class="keywordtype">void</span> port_close(scheme *sc, pointer p, <span class="keywordtype">int</span> flag) {
01352   port *pt=p-&gt;_object._port;
01353   pt-&gt;kind&amp;=~flag;
01354   <span class="keywordflow">if</span>((pt-&gt;kind &amp; (port_input|port_output))==0) {
01355     <span class="keywordflow">if</span>(pt-&gt;kind&amp;port_file) {
01356       fclose(pt-&gt;rep.stdio.file);
01357     }
01358     pt-&gt;kind=port_free;
01359   }
01360 }
01361 
01362 <span class="comment">/* get new character from input file */</span>
01363 <span class="keyword">static</span> <span class="keywordtype">int</span> inchar(scheme *sc) {
01364   <span class="keywordtype">int</span> c;
01365   port *pt;
01366  again:
01367   pt=sc-&gt;inport-&gt;_object._port;
01368   c=basic_inchar(pt);
01369   <span class="keywordflow">if</span>(c==EOF &amp;&amp; sc-&gt;inport==sc-&gt;loadport &amp;&amp; sc-&gt;file_i!=0) {
01370     file_pop(sc);
01371     <span class="keywordflow">if</span>(sc-&gt;nesting!=0) {
01372       <span class="keywordflow">return</span> EOF;
01373     }
01374     <span class="keywordflow">goto</span> again;
01375   }
01376   <span class="keywordflow">return</span> c;
01377 }
01378 
01379 <span class="keyword">static</span> <span class="keywordtype">int</span> basic_inchar(port *pt) {
01380   <span class="keywordflow">if</span>(pt-&gt;kind&amp;port_file) {
01381     <span class="keywordflow">return</span> fgetc(pt-&gt;rep.stdio.file);
01382   } <span class="keywordflow">else</span> {
01383     <span class="keywordflow">if</span>(*pt-&gt;rep.string.curr==0
01384        || pt-&gt;rep.string.curr==pt-&gt;rep.string.past_the_end) {
01385       <span class="keywordflow">return</span> EOF;
01386     } <span class="keywordflow">else</span> {
01387       <span class="keywordflow">return</span> *pt-&gt;rep.string.curr++;
01388     }
01389   }
01390 }
01391 
01392 <span class="comment">/* back character to input buffer */</span>
01393 <span class="keyword">static</span> <span class="keywordtype">void</span> backchar(scheme *sc, <span class="keywordtype">int</span> c) {
01394   port *pt;
01395   <span class="keywordflow">if</span>(c==EOF) <span class="keywordflow">return</span>;
01396   pt=sc-&gt;inport-&gt;_object._port;
01397   <span class="keywordflow">if</span>(pt-&gt;kind&amp;port_file) {
01398     ungetc(c,pt-&gt;rep.stdio.file);
01399   } <span class="keywordflow">else</span> {
01400     <span class="keywordflow">if</span>(pt-&gt;rep.string.curr!=pt-&gt;rep.string.start) {
01401       --pt-&gt;rep.string.curr;
01402     }
01403   }
01404 }
01405 
01406 INTERFACE <span class="keywordtype">void</span> putstr(scheme *sc, <span class="keyword">const</span> <span class="keywordtype">char</span> *s) {
01407   port *pt=sc-&gt;outport-&gt;_object._port;
01408   <span class="keywordflow">if</span>(pt-&gt;kind&amp;port_file) {
01409     fputs(s,pt-&gt;rep.stdio.file);
01410   } <span class="keywordflow">else</span> {
01411     <span class="keywordflow">for</span>(;*s;s++) {
01412       <span class="keywordflow">if</span>(pt-&gt;rep.string.curr!=pt-&gt;rep.string.past_the_end) {
01413        *pt-&gt;rep.string.curr++=*s;
01414       }
01415     }
01416   }
01417 }
01418 
01419 <span class="keyword">static</span> <span class="keywordtype">void</span> putchars(scheme *sc, <span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keywordtype">int</span> len) {
01420   port *pt=sc-&gt;outport-&gt;_object._port;
01421   <span class="keywordflow">if</span>(pt-&gt;kind&amp;port_file) {
01422     fwrite(s,1,len,pt-&gt;rep.stdio.file);
01423   } <span class="keywordflow">else</span> {
01424     <span class="keywordflow">for</span>(;len;len--) {
01425       <span class="keywordflow">if</span>(pt-&gt;rep.string.curr!=pt-&gt;rep.string.past_the_end) {
01426        *pt-&gt;rep.string.curr++=*s++;
01427       }
01428     }
01429   }
01430 }
01431 
01432 INTERFACE <span class="keywordtype">void</span> putcharacter(scheme *sc, <span class="keywordtype">int</span> c) {
01433   port *pt=sc-&gt;outport-&gt;_object._port;
01434   <span class="keywordflow">if</span>(pt-&gt;kind&amp;port_file) {
01435     fputc(c,pt-&gt;rep.stdio.file);
01436   } <span class="keywordflow">else</span> {
01437     <span class="keywordflow">if</span>(pt-&gt;rep.string.curr!=pt-&gt;rep.string.past_the_end) {
01438       *pt-&gt;rep.string.curr++=c;
01439     }
01440   }
01441 }
01442 
01443 <span class="comment">/* read characters up to delimiter, but cater to character constants */</span>
01444 <span class="keyword">static</span> <span class="keywordtype">char</span>   *readstr_upto(scheme *sc, <span class="keywordtype">char</span> *delim) {
01445   <span class="keywordtype">char</span>   *p = sc-&gt;strbuff;
01446 
01447   <span class="keywordflow">while</span> (!is_one_of(delim, (*p++ = inchar(sc))));
01448   <span class="keywordflow">if</span>(p==sc-&gt;strbuff+2 &amp;&amp; p[-2]==<span class="charliteral">'\\'</span>) {
01449     *p=0;
01450   } <span class="keywordflow">else</span> {
01451     backchar(sc,p[-1]);
01452     *--p = <span class="charliteral">'\0'</span>;
01453   }
01454   <span class="keywordflow">return</span> sc-&gt;strbuff;
01455 }
01456 
01457 <span class="comment">/* read string expression "xxx...xxx" */</span>
01458 <span class="keyword">static</span> pointer readstrexp(scheme *sc) {
01459   <span class="keywordtype">char</span> *p = sc-&gt;strbuff;
01460   <span class="keywordtype">int</span> c;
01461   <span class="keywordtype">int</span> c1=0;
01462   <span class="keyword">enum</span> { st_ok, st_bsl, st_x1, st_x2} state=st_ok;
01463   
01464   <span class="keywordflow">for</span> (;;) {
01465     c=inchar(sc);
01466     <span class="keywordflow">if</span>(c==EOF || p-sc-&gt;strbuff&gt;<span class="keyword">sizeof</span>(sc-&gt;strbuff)-1) {
01467       <span class="keywordflow">return</span> sc-&gt;F;
01468     }
01469     <span class="keywordflow">switch</span>(state) {
01470     <span class="keywordflow">case</span> st_ok:
01471       <span class="keywordflow">switch</span>(c) {
01472       <span class="keywordflow">case</span> <span class="charliteral">'\\'</span>:
01473        state=st_bsl;
01474        <span class="keywordflow">break</span>;
01475       <span class="keywordflow">case</span> <span class="charliteral">'"'</span>:
01476        *p=0;
01477        <span class="keywordflow">return</span> mk_counted_string(sc,sc-&gt;strbuff,p-sc-&gt;strbuff);
01478       <span class="keywordflow">default</span>:
01479        *p++=c;
01480        <span class="keywordflow">break</span>;
01481       }
01482       <span class="keywordflow">break</span>;
01483     <span class="keywordflow">case</span> st_bsl:
01484       <span class="keywordflow">switch</span>(c) {
01485       <span class="keywordflow">case</span> <span class="charliteral">'x'</span>:
01486       <span class="keywordflow">case</span> <span class="charliteral">'X'</span>:
01487        state=st_x1;
01488        c1=0;
01489        <span class="keywordflow">break</span>;
01490       <span class="keywordflow">case</span> <span class="charliteral">'n'</span>:
01491        *p++=<span class="charliteral">'\n'</span>;
01492        state=st_ok;
01493        <span class="keywordflow">break</span>;
01494       <span class="keywordflow">case</span> <span class="charliteral">'t'</span>:
01495        *p++=<span class="charliteral">'\t'</span>;
01496        state=st_ok;
01497        <span class="keywordflow">break</span>;
01498       <span class="keywordflow">case</span> <span class="charliteral">'r'</span>:
01499        *p++=<span class="charliteral">'\r'</span>;
01500        state=st_ok;
01501        <span class="keywordflow">break</span>;
01502       <span class="keywordflow">case</span> <span class="charliteral">'"'</span>:
01503        *p++=<span class="charliteral">'"'</span>;
01504        state=st_ok;
01505        <span class="keywordflow">break</span>;
01506       <span class="keywordflow">default</span>:
01507        *p++=c;
01508        state=st_ok;
01509        <span class="keywordflow">break</span>;
01510       }
01511       <span class="keywordflow">break</span>;
01512     <span class="keywordflow">case</span> st_x1:
01513     <span class="keywordflow">case</span> st_x2:
01514       c=toupper(c);
01515       <span class="keywordflow">if</span>(c&gt;=<span class="charliteral">'0'</span> &amp;&amp; c&lt;=<span class="charliteral">'F'</span>) {
01516        <span class="keywordflow">if</span>(c&lt;=<span class="charliteral">'9'</span>) {
01517          c1=(c1&lt;&lt;4)+c-<span class="charliteral">'0'</span>;
01518        } <span class="keywordflow">else</span> {
01519          c1=(c1&lt;&lt;4)+c-<span class="charliteral">'A'</span>+10;
01520        }
01521        <span class="keywordflow">if</span>(state==st_x1) {
01522          state=st_x2;
01523        } <span class="keywordflow">else</span> {
01524          *p++=c1;
01525          state=st_ok;
01526        }
01527       } <span class="keywordflow">else</span> {
01528        <span class="keywordflow">return</span> sc-&gt;F;
01529       }
01530       <span class="keywordflow">break</span>;
01531     }
01532   }
01533 }
01534 
01535 <span class="comment">/* check c is in chars */</span>
01536 <span class="keyword">static</span> INLINE <span class="keywordtype">int</span> is_one_of(<span class="keywordtype">char</span> *s, <span class="keywordtype">int</span> c) {
01537      <span class="keywordflow">if</span>(c==EOF) <span class="keywordflow">return</span> 1;
01538      <span class="keywordflow">while</span> (*s)
01539           <span class="keywordflow">if</span> (*s++ == c)
01540                <span class="keywordflow">return</span> (1);
01541      <span class="keywordflow">return</span> (0);
01542 }
01543 
01544 <span class="comment">/* skip white characters */</span>
01545 <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> skipspace(scheme *sc) {
01546      <span class="keywordtype">int</span> c;
01547      <span class="keywordflow">while</span> (isspace(c=inchar(sc)))
01548           ;
01549      <span class="keywordflow">if</span>(c!=EOF) {
01550           backchar(sc,c);
01551      }
01552 }
01553 
01554 <span class="comment">/* get token */</span>
01555 <span class="keyword">static</span> <span class="keywordtype">int</span> token(scheme *sc) {
01556      <span class="keywordtype">int</span> c;
01557      skipspace(sc);
01558      <span class="keywordflow">switch</span> (c=inchar(sc)) {
01559      <span class="keywordflow">case</span> EOF:
01560           <span class="keywordflow">return</span> (TOK_EOF);
01561      <span class="keywordflow">case</span> <span class="charliteral">'('</span>:
01562           <span class="keywordflow">return</span> (TOK_LPAREN);
01563      <span class="keywordflow">case</span> <span class="charliteral">')'</span>:
01564           <span class="keywordflow">return</span> (TOK_RPAREN);
01565      <span class="keywordflow">case</span> <span class="charliteral">'.'</span>:
01566           c=inchar(sc);
01567           <span class="keywordflow">if</span>(is_one_of(<span class="stringliteral">" \n\t"</span>,c)) {
01568                <span class="keywordflow">return</span> (TOK_DOT);
01569           } <span class="keywordflow">else</span> {
01570                backchar(sc,c);
01571               backchar(sc,<span class="charliteral">'.'</span>);
01572                <span class="keywordflow">return</span> TOK_ATOM;
01573           }
01574      <span class="keywordflow">case</span> <span class="charliteral">'\''</span>:
01575           <span class="keywordflow">return</span> (TOK_QUOTE);
01576      <span class="keywordflow">case</span> <span class="charliteral">';'</span>:
01577           <span class="keywordflow">return</span> (TOK_COMMENT);
01578      <span class="keywordflow">case</span> <span class="charliteral">'"'</span>:
01579           <span class="keywordflow">return</span> (TOK_DQUOTE);
01580      <span class="keywordflow">case</span> BACKQUOTE:
01581           <span class="keywordflow">return</span> (TOK_BQUOTE);
01582      <span class="keywordflow">case</span> <span class="charliteral">','</span>:
01583           <span class="keywordflow">if</span> ((c=inchar(sc)) == <span class="charliteral">'@'</span>)
01584                <span class="keywordflow">return</span> (TOK_ATMARK);
01585           <span class="keywordflow">else</span> {
01586                backchar(sc,c);
01587                <span class="keywordflow">return</span> (TOK_COMMA);
01588           }
01589      <span class="keywordflow">case</span> <span class="charliteral">'#'</span>:
01590           c=inchar(sc);
01591           <span class="keywordflow">if</span> (c == <span class="charliteral">'('</span>) {
01592                <span class="keywordflow">return</span> (TOK_VEC);
01593           } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(c == <span class="charliteral">'!'</span>) {
01594                <span class="keywordflow">return</span> TOK_COMMENT;
01595           } <span class="keywordflow">else</span> {
01596                backchar(sc,c);
01597                <span class="keywordflow">if</span>(is_one_of(<span class="stringliteral">" tfodxb\\"</span>,c)) {
01598                     <span class="keywordflow">return</span> TOK_SHARP_CONST;
01599                } <span class="keywordflow">else</span> {
01600                     <span class="keywordflow">return</span> (TOK_SHARP);
01601                }
01602           }
01603      <span class="keywordflow">default</span>:
01604           backchar(sc,c);
01605           <span class="keywordflow">return</span> (TOK_ATOM);
01606      }
01607 }
01608 
01609 <span class="comment">/* ========== Routines for Printing ========== */</span>
01610 <span class="preprocessor">#define   ok_abbrev(x)   (is_pair(x) &amp;&amp; cdr(x) == sc-&gt;NIL)</span>
01611 <span class="preprocessor"></span>
01612 <span class="keyword">static</span> <span class="keywordtype">void</span> printslashstring(scheme *sc, <span class="keywordtype">char</span> *p, <span class="keywordtype">int</span> len) {
01613   <span class="keywordtype">int</span> i;
01614   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *s=(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)p;
01615   putcharacter(sc,<span class="charliteral">'"'</span>);
01616   <span class="keywordflow">for</span> ( i=0; i&lt;len; i++) {
01617     <span class="keywordflow">if</span>(*s==0xff || *s==<span class="charliteral">'"'</span> || *s&lt;<span class="charliteral">' '</span> || *s==<span class="charliteral">'\\'</span>) {
01618       putcharacter(sc,<span class="charliteral">'\\'</span>);
01619       <span class="keywordflow">switch</span>(*s) {
01620       <span class="keywordflow">case</span> <span class="charliteral">'"'</span>:
01621        putcharacter(sc,<span class="charliteral">'"'</span>);
01622        <span class="keywordflow">break</span>;
01623       <span class="keywordflow">case</span> <span class="charliteral">'\n'</span>:
01624        putcharacter(sc,<span class="charliteral">'n'</span>);
01625        <span class="keywordflow">break</span>;
01626       <span class="keywordflow">case</span> <span class="charliteral">'\t'</span>:
01627        putcharacter(sc,<span class="charliteral">'t'</span>);
01628        <span class="keywordflow">break</span>;
01629       <span class="keywordflow">case</span> <span class="charliteral">'\r'</span>:
01630        putcharacter(sc,<span class="charliteral">'r'</span>);
01631        <span class="keywordflow">break</span>;
01632       <span class="keywordflow">case</span> <span class="charliteral">'\\'</span>:
01633        putcharacter(sc,<span class="charliteral">'\\'</span>);
01634        <span class="keywordflow">break</span>;
01635       <span class="keywordflow">default</span>: { 
01636          <span class="keywordtype">int</span> d=*s/16;
01637          putcharacter(sc,<span class="charliteral">'x'</span>);
01638          <span class="keywordflow">if</span>(d&lt;10) {
01639            putcharacter(sc,d+<span class="charliteral">'0'</span>);
01640          } <span class="keywordflow">else</span> {
01641            putcharacter(sc,d-10+<span class="charliteral">'A'</span>);
01642          }
01643          d=*s%16;
01644          <span class="keywordflow">if</span>(d&lt;10) {
01645            putcharacter(sc,d+<span class="charliteral">'0'</span>);
01646          } <span class="keywordflow">else</span> {
01647            putcharacter(sc,d-10+<span class="charliteral">'A'</span>);
01648          }
01649        }
01650       }
01651     } <span class="keywordflow">else</span> {
01652       putcharacter(sc,*s);
01653     }
01654     s++; 
01655   }
01656   putcharacter(sc,<span class="charliteral">'"'</span>);
01657 }
01658 
01659 
01660 <span class="comment">/* print atoms */</span>
01661 <span class="keyword">static</span> <span class="keywordtype">void</span> printatom(scheme *sc, pointer l, <span class="keywordtype">int</span> f) {
01662   <span class="keywordtype">char</span> *p;
01663   <span class="keywordtype">int</span> len;
01664   atom2str(sc,l,f,&amp;p,&amp;len);
01665   putchars(sc,p,len);
01666 }
01667 
01668 
01669 <span class="comment">/* Uses internal buffer unless string pointer is already available */</span>
01670 <span class="keyword">static</span> <span class="keywordtype">void</span> atom2str(scheme *sc, pointer l, <span class="keywordtype">int</span> f, <span class="keywordtype">char</span> **pp, <span class="keywordtype">int</span> *plen) {
01671      <span class="keywordtype">char</span> *p;
01672 
01673      <span class="keywordflow">if</span> (l == sc-&gt;NIL) {
01674           p = <span class="stringliteral">"()"</span>;
01675      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (l == sc-&gt;T) {
01676           p = <span class="stringliteral">"#t"</span>;
01677      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (l == sc-&gt;F) {
01678           p = <span class="stringliteral">"#f"</span>;
01679      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (l == sc-&gt;EOF_OBJ) {
01680           p = <span class="stringliteral">"#&lt;EOF&gt;"</span>;
01681      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_port(l)) {
01682           p = sc-&gt;strbuff;
01683           strcpy(p, <span class="stringliteral">"#&lt;PORT&gt;"</span>);
01684      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_number(l)) {
01685           p = sc-&gt;strbuff;
01686           <span class="keywordflow">if</span>(is_integer(l)) {
01687                sprintf(p, <span class="stringliteral">"%ld"</span>, ivalue_unchecked(l));
01688           } <span class="keywordflow">else</span> {
01689                sprintf(p, <span class="stringliteral">"%.10g"</span>, rvalue_unchecked(l));
01690           }
01691      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_string(l)) {
01692           <span class="keywordflow">if</span> (!f) {
01693                p = strvalue(l);
01694           } <span class="keywordflow">else</span> { <span class="comment">/* Hack, uses the fact that printing is needed */</span>
01695                *pp=sc-&gt;strbuff;
01696               *plen=0;
01697                printslashstring(sc, strvalue(l), strlength(l));
01698               <span class="keywordflow">return</span>;
01699           }
01700      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_character(l)) {
01701           <span class="keywordtype">int</span> c=charvalue(l);
01702           p = sc-&gt;strbuff;
01703           <span class="keywordflow">if</span> (!f) {
01704                p[0]=c;
01705                p[1]=0;
01706           } <span class="keywordflow">else</span> {
01707                <span class="keywordflow">switch</span>(c) {
01708                <span class="keywordflow">case</span> <span class="charliteral">' '</span>:
01709                     sprintf(p,<span class="stringliteral">"#\\space"</span>); <span class="keywordflow">break</span>;
01710                <span class="keywordflow">case</span> <span class="charliteral">'\n'</span>:
01711                     sprintf(p,<span class="stringliteral">"#\\newline"</span>); <span class="keywordflow">break</span>;
01712                <span class="keywordflow">case</span> <span class="charliteral">'\r'</span>:
01713                     sprintf(p,<span class="stringliteral">"#\\return"</span>); <span class="keywordflow">break</span>;
01714                <span class="keywordflow">case</span> <span class="charliteral">'\t'</span>:
01715                     sprintf(p,<span class="stringliteral">"#\\tab"</span>); <span class="keywordflow">break</span>;
01716                <span class="keywordflow">default</span>:
01717 <span class="preprocessor">#if USE_ASCII_NAMES</span>
01718 <span class="preprocessor"></span>                    <span class="keywordflow">if</span>(c==127) {
01719                          strcpy(p,<span class="stringliteral">"#\\del"</span>); <span class="keywordflow">break</span>;
01720                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(c&lt;32) {
01721                          strcpy(p,<span class="stringliteral">"#\\"</span>); strcat(p,charnames[c]); <span class="keywordflow">break</span>;
01722                     }
01723 <span class="preprocessor">#else</span>
01724 <span class="preprocessor"></span>                  <span class="keywordflow">if</span>(c&lt;32) {
01725                     sprintf(p,<span class="stringliteral">"#\\x%x"</span>,c); <span class="keywordflow">break</span>;
01726                   }
01727 <span class="preprocessor">#endif</span>
01728 <span class="preprocessor"></span>                    sprintf(p,<span class="stringliteral">"#\\%c"</span>,c); <span class="keywordflow">break</span>;
01729                }
01730           }
01731      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_symbol(l)) {
01732           p = symname(l);
01733      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_proc(l)) {
01734           p = sc-&gt;strbuff;
01735           sprintf(p, <span class="stringliteral">"#&lt;%s PROCEDURE %ld&gt;"</span>, procname(l),procnum(l));
01736      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_macro(l)) {
01737           p = <span class="stringliteral">"#&lt;MACRO&gt;"</span>;
01738      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_closure(l)) {
01739           p = <span class="stringliteral">"#&lt;CLOSURE&gt;"</span>;
01740      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_promise(l)) {
01741           p = <span class="stringliteral">"#&lt;PROMISE&gt;"</span>;
01742      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_foreign(l)) {
01743           p = sc-&gt;strbuff;
01744           sprintf(p, <span class="stringliteral">"#&lt;FOREIGN PROCEDURE %ld&gt;"</span>, procnum(l));
01745      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_continuation(l)) {
01746           p = <span class="stringliteral">"#&lt;CONTINUATION&gt;"</span>;
01747      } <span class="keywordflow">else</span> {
01748           p = <span class="stringliteral">"#&lt;ERROR&gt;"</span>;
01749      }
01750      *pp=p;
01751      *plen=strlen(p);
01752 }
01753 <span class="comment">/* ========== Routines for Evaluation Cycle ========== */</span>
01754 
01755 <span class="comment">/* make closure. c is code. e is environment */</span>
01756 <span class="keyword">static</span> pointer mk_closure(scheme *sc, pointer c, pointer e) {
01757      pointer x = get_cell(sc, c, e);
01758 
01759      typeflag(x) = T_CLOSURE;
01760      car(x) = c;
01761      cdr(x) = e;
01762      <span class="keywordflow">return</span> (x);
01763 }
01764 
01765 <span class="comment">/* make continuation. */</span>
01766 <span class="keyword">static</span> pointer mk_continuation(scheme *sc, pointer d) {
01767      pointer x = get_cell(sc, sc-&gt;NIL, d);
01768 
01769      typeflag(x) = T_CONTINUATION;
01770      cont_dump(x) = d;
01771      <span class="keywordflow">return</span> (x);
01772 }
01773 
01774 <span class="keyword">static</span> pointer list_star(scheme *sc, pointer d) {
01775   pointer p, q;
01776   <span class="keywordflow">if</span>(cdr(d)==sc-&gt;NIL) {
01777     <span class="keywordflow">return</span> car(d);
01778   }
01779   p=cons(sc,car(d),cdr(d));
01780   q=p;
01781   <span class="keywordflow">while</span>(cdr(cdr(p))!=sc-&gt;NIL) {
01782     d=cons(sc,car(p),cdr(p));
01783     <span class="keywordflow">if</span>(cdr(cdr(p))!=sc-&gt;NIL) {
01784       p=cdr(d);
01785     }
01786   }
01787   cdr(p)=car(cdr(p));
01788   <span class="keywordflow">return</span> q;
01789 }
01790 
01791 <span class="comment">/* reverse list -- produce new list */</span>
01792 <span class="keyword">static</span> pointer reverse(scheme *sc, pointer a) {
01793 <span class="comment">/* a must be checked by gc */</span>
01794      pointer p = sc-&gt;NIL;
01795 
01796      <span class="keywordflow">for</span> ( ; is_pair(a); a = cdr(a)) {
01797           p = cons(sc, car(a), p);
01798      }
01799      <span class="keywordflow">return</span> (p);
01800 }
01801 
01802 <span class="comment">/* reverse list --- in-place */</span>
01803 <span class="keyword">static</span> pointer reverse_in_place(scheme *sc, pointer term, pointer list) {
01804      pointer p = list, result = term, q;
01805 
01806      <span class="keywordflow">while</span> (p != sc-&gt;NIL) {
01807           q = cdr(p);
01808           cdr(p) = result;
01809           result = p;
01810           p = q;
01811      }
01812      <span class="keywordflow">return</span> (result);
01813 }
01814 
01815 <span class="comment">/* append list -- produce new list */</span>
01816 <span class="keyword">static</span> pointer append(scheme *sc, pointer a, pointer b) {
01817      pointer p = b, q;
01818 
01819      <span class="keywordflow">if</span> (a != sc-&gt;NIL) {
01820           a = reverse(sc, a);
01821           <span class="keywordflow">while</span> (a != sc-&gt;NIL) {
01822                q = cdr(a);
01823                cdr(a) = p;
01824                p = a;
01825                a = q;
01826           }
01827      }
01828      <span class="keywordflow">return</span> (p);
01829 }
01830 
01831 <span class="comment">/* equivalence of atoms */</span>
01832 <span class="keyword">static</span> <span class="keywordtype">int</span> eqv(pointer a, pointer b) {
01833      <span class="keywordflow">if</span> (is_string(a)) {
01834           <span class="keywordflow">if</span> (is_string(b))
01835                <span class="keywordflow">return</span> (strvalue(a) == strvalue(b));
01836           <span class="keywordflow">else</span>
01837                <span class="keywordflow">return</span> (0);
01838      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_number(a)) {
01839           <span class="keywordflow">if</span> (is_number(b))
01840                <span class="keywordflow">return</span> num_eq(nvalue(a),nvalue(b));
01841           <span class="keywordflow">else</span>
01842                <span class="keywordflow">return</span> (0);
01843      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_character(a)) {
01844           <span class="keywordflow">if</span> (is_character(b))
01845                <span class="keywordflow">return</span> charvalue(a)==charvalue(b);
01846           <span class="keywordflow">else</span>
01847                <span class="keywordflow">return</span> (0);
01848      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_port(a)) {
01849           <span class="keywordflow">if</span> (is_port(b))
01850                <span class="keywordflow">return</span> a==b;
01851           <span class="keywordflow">else</span>
01852                <span class="keywordflow">return</span> (0);
01853      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_proc(a)) {
01854           <span class="keywordflow">if</span> (is_proc(b))
01855                <span class="keywordflow">return</span> procnum(a)==procnum(b);
01856           <span class="keywordflow">else</span>
01857                <span class="keywordflow">return</span> (0);
01858      } <span class="keywordflow">else</span> {
01859           <span class="keywordflow">return</span> (a == b);
01860      }
01861 }
01862 
01863 <span class="comment">/* true or false value macro */</span>
01864 <span class="comment">/* () is #t in R5RS */</span>
01865 <span class="preprocessor">#define is_true(p)       ((p) != sc-&gt;F)</span>
01866 <span class="preprocessor"></span><span class="preprocessor">#define is_false(p)      ((p) == sc-&gt;F)</span>
01867 <span class="preprocessor"></span>
01868 <span class="comment">/* ========== Environment implementation  ========== */</span> 
01869 
01870 <span class="preprocessor">#if !defined(USE_ALIST_ENV) || !defined(USE_OBJECT_LIST) </span>
01871 <span class="preprocessor"></span>
01872 <span class="keyword">static</span> <span class="keywordtype">int</span> hash_fn(<span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">int</span> table_size) 
01873 { 
01874   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hashed = 0; 
01875   <span class="keyword">const</span> <span class="keywordtype">char</span> *c; 
01876   <span class="keywordtype">int</span> bits_per_int = <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> int)*8; 
01877 
01878   <span class="keywordflow">for</span> (c = key; *c; c++) { 
01879     <span class="comment">/* letters have about 5 bits in them */</span> 
01880     hashed = (hashed&lt;&lt;5) | (hashed&gt;&gt;(bits_per_int-5)); 
01881     hashed ^= *c; 
01882   } 
01883   <span class="keywordflow">return</span> hashed % table_size; 
01884 } 
01885 <span class="preprocessor">#endif </span>
01886 <span class="preprocessor"></span>
01887 <span class="preprocessor">#ifndef USE_ALIST_ENV </span>
01888 <span class="preprocessor"></span>
01889 <span class="comment">/* </span>
01890 <span class="comment"> * In this implementation, each frame of the environment may be </span>
01891 <span class="comment"> * a hash table: a vector of alists hashed by variable name. </span>
01892 <span class="comment"> * In practice, we use a vector only for the initial frame; </span>
01893 <span class="comment"> * subsequent frames are too small and transient for the lookup </span>
01894 <span class="comment"> * speed to out-weigh the cost of making a new vector. </span>
01895 <span class="comment"> */</span> 
01896 
01897 <span class="keyword">static</span> <span class="keywordtype">void</span> new_frame_in_env(scheme *sc, pointer old_env) 
01898 { 
01899   pointer new_frame; 
01900 
01901   <span class="comment">/* The interaction-environment has about 300 variables in it. */</span> 
01902   <span class="keywordflow">if</span> (old_env == sc-&gt;NIL) { 
01903     new_frame = mk_vector(sc, 461); 
01904   } <span class="keywordflow">else</span> { 
01905     new_frame = sc-&gt;NIL; 
01906   } 
01907 
01908   sc-&gt;envir = immutable_cons(sc, new_frame, old_env); 
01909   setenvironment(sc-&gt;envir); 
01910 } 
01911 
01912 <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> new_slot_spec_in_env(scheme *sc, pointer env, 
01913                                         pointer variable, pointer value) 
01914 { 
01915   pointer slot = immutable_cons(sc, variable, value); 
01916 
01917   <span class="keywordflow">if</span> (is_vector(car(env))) { 
01918     <span class="keywordtype">int</span> location = hash_fn(symname(variable), ivalue_unchecked(car(env))); 
01919 
01920     set_vector_elem(car(env), location, 
01921                     immutable_cons(sc, slot, vector_elem(car(env), location))); 
01922   } <span class="keywordflow">else</span> { 
01923     car(env) = immutable_cons(sc, slot, car(env)); 
01924   } 
01925 } 
01926 
01927 <span class="keyword">static</span> pointer find_slot_in_env(scheme *sc, pointer env, pointer hdl, <span class="keywordtype">int</span> all) 
01928 { 
01929   pointer x,y; 
01930   <span class="keywordtype">int</span> location; 
01931 
01932   <span class="keywordflow">for</span> (x = env; x != sc-&gt;NIL; x = cdr(x)) { 
01933     <span class="keywordflow">if</span> (is_vector(car(x))) { 
01934       location = hash_fn(symname(hdl), ivalue_unchecked(car(x))); 
01935       y = vector_elem(car(x), location); 
01936     } <span class="keywordflow">else</span> { 
01937       y = car(x); 
01938     } 
01939     <span class="keywordflow">for</span> ( ; y != sc-&gt;NIL; y = cdr(y)) { 
01940               <span class="keywordflow">if</span> (caar(y) == hdl) { 
01941                    <span class="keywordflow">break</span>; 
01942               } 
01943          } 
01944          <span class="keywordflow">if</span> (y != sc-&gt;NIL) { 
01945               <span class="keywordflow">break</span>; 
01946          } 
01947          <span class="keywordflow">if</span>(!all) { 
01948            <span class="keywordflow">return</span> sc-&gt;NIL; 
01949          } 
01950     } 
01951     <span class="keywordflow">if</span> (x != sc-&gt;NIL) { 
01952           <span class="keywordflow">return</span> car(y); 
01953     } 
01954     <span class="keywordflow">return</span> sc-&gt;NIL; 
01955 } 
01956 
01957 <span class="preprocessor">#else </span><span class="comment">/* USE_ALIST_ENV */</span> 
01958 
01959 <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> new_frame_in_env(scheme *sc, pointer old_env) 
01960 { 
01961   sc-&gt;envir = immutable_cons(sc, sc-&gt;NIL, old_env); 
01962   setenvironment(sc-&gt;envir); 
01963 } 
01964 
01965 <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> new_slot_spec_in_env(scheme *sc, pointer env, 
01966                                         pointer variable, pointer value) 
01967 { 
01968   car(env) = immutable_cons(sc, immutable_cons(sc, variable, value), car(env)); 
01969 } 
01970 
01971 <span class="keyword">static</span> pointer find_slot_in_env(scheme *sc, pointer env, pointer hdl, <span class="keywordtype">int</span> all) 
01972 { 
01973     pointer x,y; 
01974     <span class="keywordflow">for</span> (x = env; x != sc-&gt;NIL; x = cdr(x)) { 
01975          <span class="keywordflow">for</span> (y = car(x); y != sc-&gt;NIL; y = cdr(y)) { 
01976               <span class="keywordflow">if</span> (caar(y) == hdl) { 
01977                    <span class="keywordflow">break</span>; 
01978               } 
01979          } 
01980          <span class="keywordflow">if</span> (y != sc-&gt;NIL) { 
01981               <span class="keywordflow">break</span>; 
01982          } 
01983          <span class="keywordflow">if</span>(!all) { 
01984            <span class="keywordflow">return</span> sc-&gt;NIL; 
01985          } 
01986     } 
01987     <span class="keywordflow">if</span> (x != sc-&gt;NIL) { 
01988           <span class="keywordflow">return</span> car(y); 
01989     } 
01990     <span class="keywordflow">return</span> sc-&gt;NIL; 
01991 } 
01992 
01993 <span class="preprocessor">#endif </span><span class="comment">/* USE_ALIST_ENV else */</span> 
01994 
01995 <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> new_slot_in_env(scheme *sc, pointer variable, pointer value) 
01996 { 
01997   new_slot_spec_in_env(sc, sc-&gt;envir, variable, value); 
01998 } 
01999 
02000 <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> set_slot_in_env(scheme *sc, pointer slot, pointer value) 
02001 { 
02002   cdr(slot) = value; 
02003 } 
02004 
02005 <span class="keyword">static</span> INLINE pointer slot_value_in_env(pointer slot) 
02006 { 
02007   <span class="keywordflow">return</span> cdr(slot); 
02008 } 
02009 
02010 <span class="comment">/* ========== Evaluation Cycle ========== */</span>
02011 
02012 
02013 <span class="keyword">static</span> pointer _Error_1(scheme *sc, <span class="keyword">const</span> <span class="keywordtype">char</span> *s, pointer a) {
02014 <span class="preprocessor">#if USE_ERROR_HOOK</span>
02015 <span class="preprocessor"></span>     pointer x;
02016      pointer hdl=sc-&gt;ERROR_HOOK;
02017 
02018      x=find_slot_in_env(sc,sc-&gt;envir,hdl,1);
02019     <span class="keywordflow">if</span> (x != sc-&gt;NIL) {
02020          <span class="keywordflow">if</span>(a!=0) {
02021                sc-&gt;code = cons(sc, cons(sc, sc-&gt;QUOTE, cons(sc,(a), sc-&gt;NIL)), sc-&gt;NIL);
02022          } <span class="keywordflow">else</span> {
02023                sc-&gt;code = sc-&gt;NIL;
02024          }
02025          sc-&gt;code = cons(sc, mk_string(sc, (s)), sc-&gt;code);
02026          setimmutable(car(sc-&gt;code));
02027          sc-&gt;code = cons(sc, slot_value_in_env(x), sc-&gt;code); 
02028          sc-&gt;op = (int)OP_EVAL;
02029          <span class="keywordflow">return</span> sc-&gt;T;
02030     }
02031 <span class="preprocessor">#endif</span>
02032 <span class="preprocessor"></span>
02033     <span class="keywordflow">if</span>(a!=0) {
02034           sc-&gt;args = cons(sc, (a), sc-&gt;NIL);
02035     } <span class="keywordflow">else</span> {
02036           sc-&gt;args = sc-&gt;NIL;
02037     }
02038     sc-&gt;args = cons(sc, mk_string(sc, (s)), sc-&gt;args);
02039     setimmutable(car(sc-&gt;args));
02040     sc-&gt;op = (int)OP_ERR0;
02041     <span class="keywordflow">return</span> sc-&gt;T;
02042 }
02043 <span class="preprocessor">#define Error_1(sc,s, a) return _Error_1(sc,s,a)</span>
02044 <span class="preprocessor"></span><span class="preprocessor">#define Error_0(sc,s)    return _Error_1(sc,s,0)</span>
02045 <span class="preprocessor"></span>
02046 <span class="comment">/* Too small to turn into function */</span>
02047 <span class="preprocessor"># define  BEGIN     do {</span>
02048 <span class="preprocessor"></span><span class="preprocessor"># define  END  } while (0)</span>
02049 <span class="preprocessor"></span><span class="preprocessor">#define s_goto(sc,a) BEGIN                                  \</span>
02050 <span class="preprocessor">    sc-&gt;op = (int)(a);                                      \</span>
02051 <span class="preprocessor">    return sc-&gt;T; END</span>
02052 <span class="preprocessor"></span>
02053 <span class="preprocessor">#define s_return(sc,a) return _s_return(sc,a) </span>
02054 <span class="preprocessor"></span>
02055 <span class="preprocessor">#ifndef USE_SCHEME_STACK </span>
02056 <span class="preprocessor"></span>
02057 <span class="comment">/* this structure holds all the interpreter's registers */</span> 
02058 <span class="keyword">struct </span>dump_stack_frame { 
02059   <span class="keyword">enum</span> scheme_opcodes op; 
02060   pointer args; 
02061   pointer envir; 
02062   pointer code; 
02063 }; 
02064 
02065 <span class="preprocessor">#define STACK_GROWTH 3 </span>
02066 <span class="preprocessor"></span>
02067 <span class="keyword">static</span> <span class="keywordtype">void</span> s_save(scheme *sc, <span class="keyword">enum</span> scheme_opcodes op, pointer args, pointer code) 
02068 { 
02069   <span class="keywordtype">long</span> nframes = (long)sc-&gt;dump; 
02070   <span class="keyword">struct </span>dump_stack_frame *next_frame; 
02071 
02072   <span class="comment">/* enough room for the next frame? */</span> 
02073   <span class="keywordflow">if</span> (nframes &gt;= sc-&gt;dump_size) { 
02074     sc-&gt;dump_size += STACK_GROWTH; 
02075     <span class="comment">/* alas there is no sc-&gt;realloc */</span> 
02076     sc-&gt;dump_base = realloc(sc-&gt;dump_base, 
02077                             <span class="keyword">sizeof</span>(<span class="keyword">struct</span> dump_stack_frame) * sc-&gt;dump_size); 
02078   } 
02079   next_frame = (<span class="keyword">struct </span>dump_stack_frame *)sc-&gt;dump_base + nframes; 
02080   next_frame-&gt;op = op; 
02081   next_frame-&gt;args = args; 
02082   next_frame-&gt;envir = sc-&gt;envir; 
02083   next_frame-&gt;code = code; 
02084   sc-&gt;dump = (pointer)(nframes+1L); 
02085 } 
02086 
02087 <span class="keyword">static</span> pointer _s_return(scheme *sc, pointer a) 
02088 { 
02089   <span class="keywordtype">long</span> nframes = (long)sc-&gt;dump; 
02090   <span class="keyword">struct </span>dump_stack_frame *frame; 
02091 
02092   sc-&gt;value = (a); 
02093   <span class="keywordflow">if</span> (nframes &lt;= 0) { 
02094     <span class="keywordflow">return</span> sc-&gt;NIL; 
02095   } 
02096   nframes--; 
02097   frame = (<span class="keyword">struct </span>dump_stack_frame *)sc-&gt;dump_base + nframes; 
02098   sc-&gt;op = frame-&gt;op; 
02099   sc-&gt;args = frame-&gt;args; 
02100   sc-&gt;envir = frame-&gt;envir; 
02101   sc-&gt;code = frame-&gt;code; 
02102   sc-&gt;dump = (pointer)nframes; 
02103   <span class="keywordflow">return</span> sc-&gt;T; 
02104 } 
02105 
02106 <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> dump_stack_reset(scheme *sc) 
02107 { 
02108   <span class="comment">/* in this implementation, sc-&gt;dump is the number of frames on the stack */</span> 
02109   sc-&gt;dump = (pointer)0; 
02110 } 
02111 
02112 <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> dump_stack_initialize(scheme *sc) 
02113 { 
02114   sc-&gt;dump_size = 0; 
02115   sc-&gt;dump_base = NULL; 
02116   dump_stack_reset(sc); 
02117 } 
02118 
02119 <span class="keyword">static</span> <span class="keywordtype">void</span> dump_stack_free(scheme *sc) 
02120 { 
02121   free(sc-&gt;dump_base); 
02122   sc-&gt;dump_base = NULL; 
02123   sc-&gt;dump = (pointer)0; 
02124   sc-&gt;dump_size = 0; 
02125 } 
02126 
02127 <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> dump_stack_mark(scheme *sc) 
02128 { 
02129   <span class="keywordtype">long</span> nframes = (long)sc-&gt;dump;
02130   <span class="keywordtype">int</span> i;
02131   <span class="keywordflow">for</span>(i=0; i&lt;nframes; i++) {
02132     <span class="keyword">struct </span>dump_stack_frame *frame;
02133     frame = (<span class="keyword">struct </span>dump_stack_frame *)sc-&gt;dump_base + i;
02134     mark(frame-&gt;args);
02135     mark(frame-&gt;envir);
02136     mark(frame-&gt;code);
02137   } 
02138 } 
02139 
02140 <span class="preprocessor">#else </span>
02141 <span class="preprocessor"></span>
02142 <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> dump_stack_reset(scheme *sc) 
02143 { 
02144   sc-&gt;dump = sc-&gt;NIL; 
02145 } 
02146 
02147 <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> dump_stack_initialize(scheme *sc) 
02148 { 
02149   dump_stack_reset(sc); 
02150 } 
02151 
02152 <span class="keyword">static</span> <span class="keywordtype">void</span> dump_stack_free(scheme *sc) 
02153 { 
02154   sc-&gt;dump = sc-&gt;NIL; 
02155 } 
02156 
02157 <span class="keyword">static</span> pointer _s_return(scheme *sc, pointer a) { 
02158     sc-&gt;value = (a); 
02159     <span class="keywordflow">if</span>(sc-&gt;dump==sc-&gt;NIL) <span class="keywordflow">return</span> sc-&gt;NIL; 
02160     sc-&gt;op = ivalue(car(sc-&gt;dump)); 
02161     sc-&gt;args = cadr(sc-&gt;dump); 
02162     sc-&gt;envir = caddr(sc-&gt;dump); 
02163     sc-&gt;code = cadddr(sc-&gt;dump); 
02164     sc-&gt;dump = cddddr(sc-&gt;dump); 
02165     <span class="keywordflow">return</span> sc-&gt;T; 
02166 } 
02167 
02168 <span class="keyword">static</span> <span class="keywordtype">void</span> s_save(scheme *sc, <span class="keyword">enum</span> scheme_opcodes op, pointer args, pointer code) { 
02169     sc-&gt;dump = cons(sc, sc-&gt;envir, cons(sc, (code), sc-&gt;dump)); 
02170     sc-&gt;dump = cons(sc, (args), sc-&gt;dump); 
02171     sc-&gt;dump = cons(sc, mk_integer(sc, (<span class="keywordtype">long</span>)(op)), sc-&gt;dump); 
02172 } 
02173 
02174 <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> dump_stack_mark(scheme *sc) 
02175 { 
02176   mark(sc-&gt;dump); 
02177 } 
02178 <span class="preprocessor">#endif </span>
02179 <span class="preprocessor"></span>
02180 <span class="preprocessor">#define s_retbool(tf)    s_return(sc,(tf) ? sc-&gt;T : sc-&gt;F)</span>
02181 <span class="preprocessor"></span>
02182 <span class="keyword">static</span> pointer opexe_0(scheme *sc, <span class="keyword">enum</span> scheme_opcodes op) {
02183      pointer x, y;
02184 
02185      <span class="keywordflow">switch</span> (op) {
02186      <span class="keywordflow">case</span> OP_LOAD:       <span class="comment">/* load */</span>
02187           <span class="keywordflow">if</span>(file_interactive(sc)) {
02188                fprintf(sc-&gt;outport-&gt;_object._port-&gt;rep.stdio.file, 
02189                      <span class="stringliteral">"Loading %s\n"</span>, strvalue(car(sc-&gt;args)));
02190           }
02191           <span class="keywordflow">if</span> (!file_push(sc,strvalue(car(sc-&gt;args)))) {
02192                Error_1(sc,<span class="stringliteral">"unable to open"</span>, car(sc-&gt;args));
02193           }
02194           s_goto(sc,OP_T0LVL);
02195 
02196      <span class="keywordflow">case</span> OP_T0LVL: <span class="comment">/* top level */</span>
02197           <span class="keywordflow">if</span>(file_interactive(sc)) {
02198                putstr(sc,<span class="stringliteral">"\n"</span>);
02199           }
02200           sc-&gt;nesting=0;
02201           dump_stack_reset(sc); 
02202           sc-&gt;envir = sc-&gt;global_env;
02203          sc-&gt;save_inport=sc-&gt;inport;
02204           sc-&gt;inport = sc-&gt;loadport;
02205          s_save(sc,OP_T0LVL, sc-&gt;NIL, sc-&gt;NIL);
02206           s_save(sc,OP_VALUEPRINT, sc-&gt;NIL, sc-&gt;NIL);
02207           s_save(sc,OP_T1LVL, sc-&gt;NIL, sc-&gt;NIL);
02208           <span class="keywordflow">if</span> (file_interactive(sc)) {
02209               putstr(sc,prompt);
02210           }
02211           s_goto(sc,OP_READ_INTERNAL);
02212 
02213      <span class="keywordflow">case</span> OP_T1LVL: <span class="comment">/* top level */</span>
02214           sc-&gt;code = sc-&gt;value;
02215           sc-&gt;inport=sc-&gt;save_inport;
02216           s_goto(sc,OP_EVAL);
02217 
02218      <span class="keywordflow">case</span> OP_READ_INTERNAL:       <span class="comment">/* internal read */</span>
02219           sc-&gt;tok = token(sc);
02220           <span class="keywordflow">if</span>(sc-&gt;tok==TOK_EOF) {
02221                <span class="keywordflow">if</span>(sc-&gt;inport==sc-&gt;loadport) {
02222                     sc-&gt;args=sc-&gt;NIL;
02223                     s_goto(sc,OP_QUIT);
02224                } <span class="keywordflow">else</span> {
02225                     s_return(sc,sc-&gt;EOF_OBJ);
02226                }
02227           }
02228           s_goto(sc,OP_RDSEXPR);
02229 
02230      <span class="keywordflow">case</span> OP_GENSYM:
02231           s_return(sc, gensym(sc));
02232 
02233      <span class="keywordflow">case</span> OP_VALUEPRINT: <span class="comment">/* print evaluation result */</span>
02234           <span class="comment">/* OP_VALUEPRINT is always pushed, because when changing from</span>
02235 <span class="comment">             non-interactive to interactive mode, it needs to be</span>
02236 <span class="comment">             already on the stack */</span>
02237        <span class="keywordflow">if</span>(sc-&gt;tracing) {
02238         putstr(sc,<span class="stringliteral">"\nGives: "</span>);
02239        }
02240        <span class="keywordflow">if</span>(file_interactive(sc)) {
02241         sc-&gt;print_flag = 1;
02242         sc-&gt;args = sc-&gt;value;
02243         s_goto(sc,OP_P0LIST);
02244        } <span class="keywordflow">else</span> {
02245         s_return(sc,sc-&gt;value);
02246        }
02247 
02248      <span class="keywordflow">case</span> OP_EVAL:       <span class="comment">/* main part of evaluation */</span>
02249 <span class="preprocessor">#if USE_TRACING</span>
02250 <span class="preprocessor"></span>       <span class="keywordflow">if</span>(sc-&gt;tracing) {
02251         <span class="comment">/*s_save(sc,OP_VALUEPRINT,sc-&gt;NIL,sc-&gt;NIL);*/</span>
02252         s_save(sc,OP_REAL_EVAL,sc-&gt;args,sc-&gt;code);
02253         sc-&gt;args=sc-&gt;code;
02254         putstr(sc,<span class="stringliteral">"\nEval: "</span>);
02255         s_goto(sc,OP_P0LIST);
02256        }
02257        <span class="comment">/* fall through */</span>
02258      <span class="keywordflow">case</span> OP_REAL_EVAL:
02259 <span class="preprocessor">#endif</span>
02260 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (is_symbol(sc-&gt;code)) {    <span class="comment">/* symbol */</span>
02261                x=find_slot_in_env(sc,sc-&gt;envir,sc-&gt;code,1);
02262                <span class="keywordflow">if</span> (x != sc-&gt;NIL) {
02263                     s_return(sc,slot_value_in_env(x)); 
02264                } <span class="keywordflow">else</span> {
02265                     Error_1(sc,<span class="stringliteral">"eval: unbound variable:"</span>, sc-&gt;code);
02266                }
02267           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_pair(sc-&gt;code)) {
02268                <span class="keywordflow">if</span> (is_syntax(x = car(sc-&gt;code))) {     <span class="comment">/* SYNTAX */</span>
02269                     sc-&gt;code = cdr(sc-&gt;code);
02270                     s_goto(sc,syntaxnum(x));
02271                } <span class="keywordflow">else</span> {<span class="comment">/* first, eval top element and eval arguments */</span>
02272                     s_save(sc,OP_E0ARGS, sc-&gt;NIL, sc-&gt;code);
02273                     <span class="comment">/* If no macros =&gt; s_save(sc,OP_E1ARGS, sc-&gt;NIL, cdr(sc-&gt;code));*/</span>
02274                     sc-&gt;code = car(sc-&gt;code);
02275                     s_goto(sc,OP_EVAL);
02276                }
02277           } <span class="keywordflow">else</span> {
02278                s_return(sc,sc-&gt;code);
02279           }
02280 
02281      <span class="keywordflow">case</span> OP_E0ARGS:     <span class="comment">/* eval arguments */</span>
02282           <span class="keywordflow">if</span> (is_macro(sc-&gt;value)) {    <span class="comment">/* macro expansion */</span>
02283                s_save(sc,OP_DOMACRO, sc-&gt;NIL, sc-&gt;NIL);
02284                sc-&gt;args = cons(sc,sc-&gt;code, sc-&gt;NIL);
02285                sc-&gt;code = sc-&gt;value;
02286                s_goto(sc,OP_APPLY);
02287           } <span class="keywordflow">else</span> {
02288                sc-&gt;code = cdr(sc-&gt;code);
02289                s_goto(sc,OP_E1ARGS);
02290           }
02291 
02292      <span class="keywordflow">case</span> OP_E1ARGS:     <span class="comment">/* eval arguments */</span>
02293           sc-&gt;args = cons(sc, sc-&gt;value, sc-&gt;args);
02294           <span class="keywordflow">if</span> (is_pair(sc-&gt;code)) { <span class="comment">/* continue */</span>
02295                s_save(sc,OP_E1ARGS, sc-&gt;args, cdr(sc-&gt;code));
02296                sc-&gt;code = car(sc-&gt;code);
02297                sc-&gt;args = sc-&gt;NIL;
02298                s_goto(sc,OP_EVAL);
02299           } <span class="keywordflow">else</span> {  <span class="comment">/* end */</span>
02300                sc-&gt;args = reverse_in_place(sc, sc-&gt;NIL, sc-&gt;args); 
02301                sc-&gt;code = car(sc-&gt;args);
02302                sc-&gt;args = cdr(sc-&gt;args);
02303                s_goto(sc,OP_APPLY);
02304           }
02305 
02306 <span class="preprocessor">#if USE_TRACING</span>
02307 <span class="preprocessor"></span>     <span class="keywordflow">case</span> OP_TRACING: {
02308        <span class="keywordtype">int</span> tr=sc-&gt;tracing;
02309        sc-&gt;tracing=ivalue(car(sc-&gt;args));
02310        s_return(sc,mk_integer(sc,tr));
02311      }
02312 <span class="preprocessor">#endif</span>
02313 <span class="preprocessor"></span>
02314      <span class="keywordflow">case</span> OP_APPLY:      <span class="comment">/* apply 'code' to 'args' */</span>
02315 <span class="preprocessor">#if USE_TRACING</span>
02316 <span class="preprocessor"></span>       <span class="keywordflow">if</span>(sc-&gt;tracing) {
02317         s_save(sc,OP_REAL_APPLY,sc-&gt;args,sc-&gt;code);
02318         sc-&gt;print_flag = 1;
02319         <span class="comment">/*     sc-&gt;args=cons(sc,sc-&gt;code,sc-&gt;args);*/</span>
02320          putstr(sc,<span class="stringliteral">"\nApply to: "</span>);
02321         s_goto(sc,OP_P0LIST);
02322        }
02323        <span class="comment">/* fall through */</span>
02324      <span class="keywordflow">case</span> OP_REAL_APPLY:
02325 <span class="preprocessor">#endif</span>
02326 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (is_proc(sc-&gt;code)) {
02327                s_goto(sc,procnum(sc-&gt;code));   <span class="comment">/* PROCEDURE */</span>
02328           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_foreign(sc-&gt;code)) {
02329                x=sc-&gt;code-&gt;_object._ff(sc,sc-&gt;args);
02330                s_return(sc,x);
02331           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_closure(sc-&gt;code) || is_macro(sc-&gt;code) 
02332                    || is_promise(sc-&gt;code)) { <span class="comment">/* CLOSURE */</span>
02333            <span class="comment">/* Should not accept promise */</span>
02334                <span class="comment">/* make environment */</span>
02335                new_frame_in_env(sc, closure_env(sc-&gt;code)); 
02336                <span class="keywordflow">for</span> (x = car(closure_code(sc-&gt;code)), y = sc-&gt;args;
02337                     is_pair(x); x = cdr(x), y = cdr(y)) {
02338                     <span class="keywordflow">if</span> (y == sc-&gt;NIL) {
02339                          Error_0(sc,<span class="stringliteral">"not enough arguments"</span>);
02340                     } <span class="keywordflow">else</span> {
02341                          new_slot_in_env(sc, car(x), car(y)); 
02342                     }
02343                }
02344                <span class="keywordflow">if</span> (x == sc-&gt;NIL) {
02345                     <span class="comment">/*--</span>
02346 <span class="comment">                     * if (y != sc-&gt;NIL) {</span>
02347 <span class="comment">                     *   Error_0(sc,"too many arguments");</span>
02348 <span class="comment">                     * }</span>
02349 <span class="comment">                     */</span>
02350                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_symbol(x))
02351                     new_slot_in_env(sc, x, y); 
02352                <span class="keywordflow">else</span> {
02353                     Error_1(sc,<span class="stringliteral">"syntax error in closure: not a symbol:"</span>, x); 
02354                }
02355                sc-&gt;code = cdr(closure_code(sc-&gt;code));
02356                sc-&gt;args = sc-&gt;NIL;
02357                s_goto(sc,OP_BEGIN);
02358           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_continuation(sc-&gt;code)) { <span class="comment">/* CONTINUATION */</span>
02359                sc-&gt;dump = cont_dump(sc-&gt;code);
02360                s_return(sc,sc-&gt;args != sc-&gt;NIL ? car(sc-&gt;args) : sc-&gt;NIL);
02361           } <span class="keywordflow">else</span> {
02362                Error_0(sc,<span class="stringliteral">"illegal function"</span>);
02363           }
02364 
02365      <span class="keywordflow">case</span> OP_DOMACRO:    <span class="comment">/* do macro */</span>
02366           sc-&gt;code = sc-&gt;value;
02367           s_goto(sc,OP_EVAL);
02368 
02369      <span class="keywordflow">case</span> OP_LAMBDA:     <span class="comment">/* lambda */</span>
02370           s_return(sc,mk_closure(sc, sc-&gt;code, sc-&gt;envir));
02371 
02372      <span class="keywordflow">case</span> OP_MKCLOSURE: <span class="comment">/* make-closure */</span>
02373        x=car(sc-&gt;args);
02374        <span class="keywordflow">if</span>(car(x)==sc-&gt;LAMBDA) {
02375         x=cdr(x);
02376        }
02377        <span class="keywordflow">if</span>(cdr(sc-&gt;args)==sc-&gt;NIL) {
02378         y=sc-&gt;envir;
02379        } <span class="keywordflow">else</span> {
02380         y=cadr(sc-&gt;args);
02381        }
02382        s_return(sc,mk_closure(sc, x, y));
02383 
02384      <span class="keywordflow">case</span> OP_QUOTE:      <span class="comment">/* quote */</span>
02385           x=car(sc-&gt;code);
02386           s_return(sc,car(sc-&gt;code));
02387 
02388      <span class="keywordflow">case</span> OP_DEF0:  <span class="comment">/* define */</span>
02389           <span class="keywordflow">if</span> (is_pair(car(sc-&gt;code))) {
02390                x = caar(sc-&gt;code);
02391                sc-&gt;code = cons(sc, sc-&gt;LAMBDA, cons(sc, cdar(sc-&gt;code), cdr(sc-&gt;code)));
02392           } <span class="keywordflow">else</span> {
02393                x = car(sc-&gt;code);
02394                sc-&gt;code = cadr(sc-&gt;code);
02395           }
02396           <span class="keywordflow">if</span> (!is_symbol(x)) {
02397                Error_0(sc,<span class="stringliteral">"variable is not a symbol"</span>);
02398           }
02399           s_save(sc,OP_DEF1, sc-&gt;NIL, x);
02400           s_goto(sc,OP_EVAL);
02401 
02402      <span class="keywordflow">case</span> OP_DEF1:  <span class="comment">/* define */</span>
02403        x=find_slot_in_env(sc,sc-&gt;envir,sc-&gt;code,0);
02404           <span class="keywordflow">if</span> (x != sc-&gt;NIL) {
02405                set_slot_in_env(sc, x, sc-&gt;value); 
02406           } <span class="keywordflow">else</span> {
02407                new_slot_in_env(sc, sc-&gt;code, sc-&gt;value); 
02408           }
02409           s_return(sc,sc-&gt;code);
02410 
02411 
02412      <span class="keywordflow">case</span> OP_DEFP:  <span class="comment">/* defined? */</span>
02413           x=sc-&gt;envir;
02414           <span class="keywordflow">if</span>(cdr(sc-&gt;args)!=sc-&gt;NIL) {
02415                x=cadr(sc-&gt;args);
02416           }
02417           s_retbool(find_slot_in_env(sc,x,car(sc-&gt;args),1)!=sc-&gt;NIL);
02418 
02419      <span class="keywordflow">case</span> OP_SET0:       <span class="comment">/* set! */</span>
02420           s_save(sc,OP_SET1, sc-&gt;NIL, car(sc-&gt;code));
02421           sc-&gt;code = cadr(sc-&gt;code);
02422           s_goto(sc,OP_EVAL);
02423 
02424      <span class="keywordflow">case</span> OP_SET1:       <span class="comment">/* set! */</span>
02425        y=find_slot_in_env(sc,sc-&gt;envir,sc-&gt;code,1);
02426           <span class="keywordflow">if</span> (y != sc-&gt;NIL) {
02427                set_slot_in_env(sc, y, sc-&gt;value); 
02428                s_return(sc,sc-&gt;value);
02429           } <span class="keywordflow">else</span> {
02430                Error_1(sc,<span class="stringliteral">"set!: unbound variable:"</span>, sc-&gt;code); 
02431           }
02432 
02433 
02434      <span class="keywordflow">case</span> OP_BEGIN:      <span class="comment">/* begin */</span>
02435           <span class="keywordflow">if</span> (!is_pair(sc-&gt;code)) {
02436                s_return(sc,sc-&gt;code);
02437           }
02438           <span class="keywordflow">if</span> (cdr(sc-&gt;code) != sc-&gt;NIL) {
02439                s_save(sc,OP_BEGIN, sc-&gt;NIL, cdr(sc-&gt;code));
02440           }
02441           sc-&gt;code = car(sc-&gt;code);
02442           s_goto(sc,OP_EVAL);
02443 
02444      <span class="keywordflow">case</span> OP_IF0:        <span class="comment">/* if */</span>
02445           s_save(sc,OP_IF1, sc-&gt;NIL, cdr(sc-&gt;code));
02446           sc-&gt;code = car(sc-&gt;code);
02447           s_goto(sc,OP_EVAL);
02448 
02449      <span class="keywordflow">case</span> OP_IF1:        <span class="comment">/* if */</span>
02450           <span class="keywordflow">if</span> (is_true(sc-&gt;value))
02451                sc-&gt;code = car(sc-&gt;code);
02452           <span class="keywordflow">else</span>
02453                sc-&gt;code = cadr(sc-&gt;code);  <span class="comment">/* (if #f 1) ==&gt; () because</span>
02454 <span class="comment">                               * car(sc-&gt;NIL) = sc-&gt;NIL */</span>
02455           s_goto(sc,OP_EVAL);
02456 
02457      <span class="keywordflow">case</span> OP_LET0:       <span class="comment">/* let */</span>
02458           sc-&gt;args = sc-&gt;NIL;
02459           sc-&gt;value = sc-&gt;code;
02460           sc-&gt;code = is_symbol(car(sc-&gt;code)) ? cadr(sc-&gt;code) : car(sc-&gt;code);
02461           s_goto(sc,OP_LET1);
02462 
02463      <span class="keywordflow">case</span> OP_LET1:       <span class="comment">/* let (calculate parameters) */</span>
02464           sc-&gt;args = cons(sc, sc-&gt;value, sc-&gt;args);
02465           <span class="keywordflow">if</span> (is_pair(sc-&gt;code)) { <span class="comment">/* continue */</span>
02466                s_save(sc,OP_LET1, sc-&gt;args, cdr(sc-&gt;code));
02467                sc-&gt;code = cadar(sc-&gt;code);
02468                sc-&gt;args = sc-&gt;NIL;
02469                s_goto(sc,OP_EVAL);
02470           } <span class="keywordflow">else</span> {  <span class="comment">/* end */</span>
02471                sc-&gt;args = reverse_in_place(sc, sc-&gt;NIL, sc-&gt;args);
02472                sc-&gt;code = car(sc-&gt;args);
02473                sc-&gt;args = cdr(sc-&gt;args);
02474                s_goto(sc,OP_LET2);
02475           }
02476 
02477      <span class="keywordflow">case</span> OP_LET2:       <span class="comment">/* let */</span>
02478           new_frame_in_env(sc, sc-&gt;envir); 
02479           <span class="keywordflow">for</span> (x = is_symbol(car(sc-&gt;code)) ? cadr(sc-&gt;code) : car(sc-&gt;code), y = sc-&gt;args;
02480                y != sc-&gt;NIL; x = cdr(x), y = cdr(y)) {
02481                new_slot_in_env(sc, caar(x), car(y)); 
02482           }
02483           <span class="keywordflow">if</span> (is_symbol(car(sc-&gt;code))) {    <span class="comment">/* named let */</span>
02484                <span class="keywordflow">for</span> (x = cadr(sc-&gt;code), sc-&gt;args = sc-&gt;NIL; x != sc-&gt;NIL; x = cdr(x)) {
02485 
02486                     sc-&gt;args = cons(sc, caar(x), sc-&gt;args);
02487                }
02488                x = mk_closure(sc, cons(sc, reverse_in_place(sc, sc-&gt;NIL, sc-&gt;args), cddr(sc-&gt;code)), sc-&gt;envir); 
02489                new_slot_in_env(sc, car(sc-&gt;code), x); 
02490                sc-&gt;code = cddr(sc-&gt;code);
02491                sc-&gt;args = sc-&gt;NIL;
02492           } <span class="keywordflow">else</span> {
02493                sc-&gt;code = cdr(sc-&gt;code);
02494                sc-&gt;args = sc-&gt;NIL;
02495           }
02496           s_goto(sc,OP_BEGIN);
02497 
02498      <span class="keywordflow">case</span> OP_LET0AST:    <span class="comment">/* let* */</span>
02499           <span class="keywordflow">if</span> (car(sc-&gt;code) == sc-&gt;NIL) {
02500                new_frame_in_env(sc, sc-&gt;envir); 
02501                sc-&gt;code = cdr(sc-&gt;code);
02502                s_goto(sc,OP_BEGIN);
02503           }
02504           s_save(sc,OP_LET1AST, cdr(sc-&gt;code), car(sc-&gt;code));
02505           sc-&gt;code = cadaar(sc-&gt;code);
02506           s_goto(sc,OP_EVAL);
02507 
02508      <span class="keywordflow">case</span> OP_LET1AST:    <span class="comment">/* let* (make new frame) */</span>
02509           new_frame_in_env(sc, sc-&gt;envir); 
02510           s_goto(sc,OP_LET2AST);
02511 
02512      <span class="keywordflow">case</span> OP_LET2AST:    <span class="comment">/* let* (calculate parameters) */</span>
02513           new_slot_in_env(sc, caar(sc-&gt;code), sc-&gt;value); 
02514           sc-&gt;code = cdr(sc-&gt;code);
02515           <span class="keywordflow">if</span> (is_pair(sc-&gt;code)) { <span class="comment">/* continue */</span>
02516                s_save(sc,OP_LET2AST, sc-&gt;args, sc-&gt;code);
02517                sc-&gt;code = cadar(sc-&gt;code);
02518                sc-&gt;args = sc-&gt;NIL;
02519                s_goto(sc,OP_EVAL);
02520           } <span class="keywordflow">else</span> {  <span class="comment">/* end */</span>
02521                sc-&gt;code = sc-&gt;args;
02522                sc-&gt;args = sc-&gt;NIL;
02523                s_goto(sc,OP_BEGIN);
02524           }
02525      <span class="keywordflow">default</span>:
02526           sprintf(sc-&gt;strbuff, <span class="stringliteral">"%d: illegal operator"</span>, sc-&gt;op);
02527           Error_0(sc,sc-&gt;strbuff);
02528      }
02529      <span class="keywordflow">return</span> sc-&gt;T;
02530 }
02531 
02532 <span class="keyword">static</span> pointer opexe_1(scheme *sc, <span class="keyword">enum</span> scheme_opcodes op) {
02533      pointer x, y;
02534 
02535      <span class="keywordflow">switch</span> (op) {
02536      <span class="keywordflow">case</span> OP_LET0REC:    <span class="comment">/* letrec */</span>
02537           new_frame_in_env(sc, sc-&gt;envir); 
02538           sc-&gt;args = sc-&gt;NIL;
02539           sc-&gt;value = sc-&gt;code;
02540           sc-&gt;code = car(sc-&gt;code);
02541           s_goto(sc,OP_LET1REC);
02542 
02543      <span class="keywordflow">case</span> OP_LET1REC:    <span class="comment">/* letrec (calculate parameters) */</span>
02544           sc-&gt;args = cons(sc, sc-&gt;value, sc-&gt;args);
02545           <span class="keywordflow">if</span> (is_pair(sc-&gt;code)) { <span class="comment">/* continue */</span>
02546                s_save(sc,OP_LET1REC, sc-&gt;args, cdr(sc-&gt;code));
02547                sc-&gt;code = cadar(sc-&gt;code);
02548                sc-&gt;args = sc-&gt;NIL;
02549                s_goto(sc,OP_EVAL);
02550           } <span class="keywordflow">else</span> {  <span class="comment">/* end */</span>
02551                sc-&gt;args = reverse_in_place(sc, sc-&gt;NIL, sc-&gt;args); 
02552                sc-&gt;code = car(sc-&gt;args);
02553                sc-&gt;args = cdr(sc-&gt;args);
02554                s_goto(sc,OP_LET2REC);
02555           }
02556 
02557      <span class="keywordflow">case</span> OP_LET2REC:    <span class="comment">/* letrec */</span>
02558           <span class="keywordflow">for</span> (x = car(sc-&gt;code), y = sc-&gt;args; y != sc-&gt;NIL; x = cdr(x), y = cdr(y)) {
02559                new_slot_in_env(sc, caar(x), car(y)); 
02560           }
02561           sc-&gt;code = cdr(sc-&gt;code);
02562           sc-&gt;args = sc-&gt;NIL;
02563           s_goto(sc,OP_BEGIN);
02564 
02565      <span class="keywordflow">case</span> OP_COND0:      <span class="comment">/* cond */</span>
02566           <span class="keywordflow">if</span> (!is_pair(sc-&gt;code)) {
02567                Error_0(sc,<span class="stringliteral">"syntax error in cond"</span>);
02568           }
02569           s_save(sc,OP_COND1, sc-&gt;NIL, sc-&gt;code);
02570           sc-&gt;code = caar(sc-&gt;code);
02571           s_goto(sc,OP_EVAL);
02572 
02573      <span class="keywordflow">case</span> OP_COND1:      <span class="comment">/* cond */</span>
02574           <span class="keywordflow">if</span> (is_true(sc-&gt;value)) {
02575                <span class="keywordflow">if</span> ((sc-&gt;code = cdar(sc-&gt;code)) == sc-&gt;NIL) {
02576                     s_return(sc,sc-&gt;value);
02577                }
02578                <span class="keywordflow">if</span>(car(sc-&gt;code)==sc-&gt;FEED_TO) {
02579                     <span class="keywordflow">if</span>(!is_pair(cdr(sc-&gt;code))) {
02580                          Error_0(sc,<span class="stringliteral">"syntax error in cond"</span>);
02581                     }
02582                     x=cons(sc, sc-&gt;QUOTE, cons(sc, sc-&gt;value, sc-&gt;NIL));
02583                     sc-&gt;code=cons(sc,cadr(sc-&gt;code),cons(sc,x,sc-&gt;NIL));
02584                     s_goto(sc,OP_EVAL);
02585                }
02586                s_goto(sc,OP_BEGIN);
02587           } <span class="keywordflow">else</span> {
02588                <span class="keywordflow">if</span> ((sc-&gt;code = cdr(sc-&gt;code)) == sc-&gt;NIL) {
02589                     s_return(sc,sc-&gt;NIL);
02590                } <span class="keywordflow">else</span> {
02591                     s_save(sc,OP_COND1, sc-&gt;NIL, sc-&gt;code);
02592                     sc-&gt;code = caar(sc-&gt;code);
02593                     s_goto(sc,OP_EVAL);
02594                }
02595           }
02596 
02597      <span class="keywordflow">case</span> OP_DELAY:      <span class="comment">/* delay */</span>
02598           x = mk_closure(sc, cons(sc, sc-&gt;NIL, sc-&gt;code), sc-&gt;envir);
02599           typeflag(x)=T_PROMISE;
02600           s_return(sc,x);
02601 
02602      <span class="keywordflow">case</span> OP_AND0:       <span class="comment">/* and */</span>
02603           <span class="keywordflow">if</span> (sc-&gt;code == sc-&gt;NIL) {
02604                s_return(sc,sc-&gt;T);
02605           }
02606           s_save(sc,OP_AND1, sc-&gt;NIL, cdr(sc-&gt;code));
02607           sc-&gt;code = car(sc-&gt;code);
02608           s_goto(sc,OP_EVAL);
02609 
02610      <span class="keywordflow">case</span> OP_AND1:       <span class="comment">/* and */</span>
02611           <span class="keywordflow">if</span> (is_false(sc-&gt;value)) {
02612                s_return(sc,sc-&gt;value);
02613           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sc-&gt;code == sc-&gt;NIL) {
02614                s_return(sc,sc-&gt;value);
02615           } <span class="keywordflow">else</span> {
02616                s_save(sc,OP_AND1, sc-&gt;NIL, cdr(sc-&gt;code));
02617                sc-&gt;code = car(sc-&gt;code);
02618                s_goto(sc,OP_EVAL);
02619           }
02620 
02621      <span class="keywordflow">case</span> OP_OR0:        <span class="comment">/* or */</span>
02622           <span class="keywordflow">if</span> (sc-&gt;code == sc-&gt;NIL) {
02623                s_return(sc,sc-&gt;F);
02624           }
02625           s_save(sc,OP_OR1, sc-&gt;NIL, cdr(sc-&gt;code));
02626           sc-&gt;code = car(sc-&gt;code);
02627           s_goto(sc,OP_EVAL);
02628 
02629      <span class="keywordflow">case</span> OP_OR1:        <span class="comment">/* or */</span>
02630           <span class="keywordflow">if</span> (is_true(sc-&gt;value)) {
02631                s_return(sc,sc-&gt;value);
02632           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sc-&gt;code == sc-&gt;NIL) {
02633                s_return(sc,sc-&gt;value);
02634           } <span class="keywordflow">else</span> {
02635                s_save(sc,OP_OR1, sc-&gt;NIL, cdr(sc-&gt;code));
02636                sc-&gt;code = car(sc-&gt;code);
02637                s_goto(sc,OP_EVAL);
02638           }
02639 
02640      <span class="keywordflow">case</span> OP_C0STREAM:   <span class="comment">/* cons-stream */</span>
02641           s_save(sc,OP_C1STREAM, sc-&gt;NIL, cdr(sc-&gt;code));
02642           sc-&gt;code = car(sc-&gt;code);
02643           s_goto(sc,OP_EVAL);
02644 
02645      <span class="keywordflow">case</span> OP_C1STREAM:   <span class="comment">/* cons-stream */</span>
02646           sc-&gt;args = sc-&gt;value;  <span class="comment">/* save sc-&gt;value to register sc-&gt;args for gc */</span>
02647           x = mk_closure(sc, cons(sc, sc-&gt;NIL, sc-&gt;code), sc-&gt;envir);
02648           typeflag(x)=T_PROMISE;
02649           s_return(sc,cons(sc, sc-&gt;args, x));
02650 
02651      <span class="keywordflow">case</span> OP_MACRO0:     <span class="comment">/* macro */</span>
02652           <span class="keywordflow">if</span> (is_pair(car(sc-&gt;code))) {
02653                x = caar(sc-&gt;code);
02654                sc-&gt;code = cons(sc, sc-&gt;LAMBDA, cons(sc, cdar(sc-&gt;code), cdr(sc-&gt;code)));
02655           } <span class="keywordflow">else</span> {
02656                x = car(sc-&gt;code);
02657                sc-&gt;code = cadr(sc-&gt;code);
02658           }
02659           <span class="keywordflow">if</span> (!is_symbol(x)) {
02660                Error_0(sc,<span class="stringliteral">"variable is not a symbol"</span>);
02661           }
02662           s_save(sc,OP_MACRO1, sc-&gt;NIL, x);
02663           s_goto(sc,OP_EVAL);
02664 
02665      <span class="keywordflow">case</span> OP_MACRO1:     <span class="comment">/* macro */</span>
02666           typeflag(sc-&gt;value) = T_MACRO;
02667           x = find_slot_in_env(sc, sc-&gt;envir, sc-&gt;code, 0); 
02668           <span class="keywordflow">if</span> (x != sc-&gt;NIL) {
02669                set_slot_in_env(sc, x, sc-&gt;value); 
02670           } <span class="keywordflow">else</span> {
02671                new_slot_in_env(sc, sc-&gt;code, sc-&gt;value); 
02672           }
02673           s_return(sc,sc-&gt;code);
02674 
02675      <span class="keywordflow">case</span> OP_CASE0:      <span class="comment">/* case */</span>
02676           s_save(sc,OP_CASE1, sc-&gt;NIL, cdr(sc-&gt;code));
02677           sc-&gt;code = car(sc-&gt;code);
02678           s_goto(sc,OP_EVAL);
02679 
02680      <span class="keywordflow">case</span> OP_CASE1:      <span class="comment">/* case */</span>
02681           <span class="keywordflow">for</span> (x = sc-&gt;code; x != sc-&gt;NIL; x = cdr(x)) {
02682                <span class="keywordflow">if</span> (!is_pair(y = caar(x))) {
02683                     <span class="keywordflow">break</span>;
02684                }
02685                <span class="keywordflow">for</span> ( ; y != sc-&gt;NIL; y = cdr(y)) {
02686                     <span class="keywordflow">if</span> (eqv(car(y), sc-&gt;value)) {
02687                          <span class="keywordflow">break</span>;
02688                     }
02689                }
02690                <span class="keywordflow">if</span> (y != sc-&gt;NIL) {
02691                     <span class="keywordflow">break</span>;
02692                }
02693           }
02694           <span class="keywordflow">if</span> (x != sc-&gt;NIL) {
02695                <span class="keywordflow">if</span> (is_pair(caar(x))) {
02696                     sc-&gt;code = cdar(x);
02697                     s_goto(sc,OP_BEGIN);
02698                } <span class="keywordflow">else</span> {<span class="comment">/* else */</span>
02699                     s_save(sc,OP_CASE2, sc-&gt;NIL, cdar(x));
02700                     sc-&gt;code = caar(x);
02701                     s_goto(sc,OP_EVAL);
02702                }
02703           } <span class="keywordflow">else</span> {
02704                s_return(sc,sc-&gt;NIL);
02705           }
02706 
02707      <span class="keywordflow">case</span> OP_CASE2:      <span class="comment">/* case */</span>
02708           <span class="keywordflow">if</span> (is_true(sc-&gt;value)) {
02709                s_goto(sc,OP_BEGIN);
02710           } <span class="keywordflow">else</span> {
02711                s_return(sc,sc-&gt;NIL);
02712           }
02713 
02714      <span class="keywordflow">case</span> OP_PAPPLY:     <span class="comment">/* apply */</span>
02715           sc-&gt;code = car(sc-&gt;args);
02716          sc-&gt;args = list_star(sc,cdr(sc-&gt;args));
02717           <span class="comment">/*sc-&gt;args = cadr(sc-&gt;args);*/</span>
02718           s_goto(sc,OP_APPLY);
02719 
02720      <span class="keywordflow">case</span> OP_PEVAL: <span class="comment">/* eval */</span>
02721           <span class="keywordflow">if</span>(cdr(sc-&gt;args)!=sc-&gt;NIL) {
02722                sc-&gt;envir=cadr(sc-&gt;args);
02723           }
02724           sc-&gt;code = car(sc-&gt;args);
02725           s_goto(sc,OP_EVAL);
02726 
02727      <span class="keywordflow">case</span> OP_CONTINUATION:    <span class="comment">/* call-with-current-continuation */</span>
02728           sc-&gt;code = car(sc-&gt;args);
02729           sc-&gt;args = cons(sc, mk_continuation(sc, sc-&gt;dump), sc-&gt;NIL);
02730           s_goto(sc,OP_APPLY);
02731 
02732      <span class="keywordflow">default</span>:
02733           sprintf(sc-&gt;strbuff, <span class="stringliteral">"%d: illegal operator"</span>, sc-&gt;op);
02734           Error_0(sc,sc-&gt;strbuff);
02735      }
02736      <span class="keywordflow">return</span> sc-&gt;T;
02737 }
02738 
02739 <span class="keyword">static</span> pointer opexe_2(scheme *sc, <span class="keyword">enum</span> scheme_opcodes op) {
02740      pointer x;
02741      num v;
02742 <span class="preprocessor">#if USE_MATH</span>
02743 <span class="preprocessor"></span>     <span class="keywordtype">double</span> dd;
02744 <span class="preprocessor">#endif</span>
02745 <span class="preprocessor"></span>
02746      <span class="keywordflow">switch</span> (op) {
02747 <span class="preprocessor">#if USE_MATH</span>
02748 <span class="preprocessor"></span>     <span class="keywordflow">case</span> OP_INEX2EX:    <span class="comment">/* inexact-&gt;exact */</span>
02749           x=car(sc-&gt;args);
02750           <span class="keywordflow">if</span>(is_integer(x)) {
02751                s_return(sc,x);
02752           } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(modf(rvalue_unchecked(x),&amp;dd)==0.0) {
02753                s_return(sc,mk_integer(sc,ivalue(x)));
02754           } <span class="keywordflow">else</span> {
02755                Error_1(sc,<span class="stringliteral">"inexact-&gt;exact: not integral:"</span>,x);
02756           }
02757 
02758      <span class="keywordflow">case</span> OP_EXP:
02759           x=car(sc-&gt;args);
02760           s_return(sc, mk_real(sc, exp(rvalue(x))));
02761 
02762      <span class="keywordflow">case</span> OP_LOG:
02763           x=car(sc-&gt;args);
02764           s_return(sc, mk_real(sc, log(rvalue(x))));
02765 
02766      <span class="keywordflow">case</span> OP_SIN:
02767           x=car(sc-&gt;args);
02768           s_return(sc, mk_real(sc, sin(rvalue(x))));
02769 
02770      <span class="keywordflow">case</span> OP_COS:
02771           x=car(sc-&gt;args);
02772           s_return(sc, mk_real(sc, cos(rvalue(x))));
02773 
02774      <span class="keywordflow">case</span> OP_TAN:
02775           x=car(sc-&gt;args);
02776           s_return(sc, mk_real(sc, tan(rvalue(x))));
02777 
02778      <span class="keywordflow">case</span> OP_ASIN:
02779           x=car(sc-&gt;args);
02780           s_return(sc, mk_real(sc, asin(rvalue(x))));
02781 
02782      <span class="keywordflow">case</span> OP_ACOS:
02783           x=car(sc-&gt;args);
02784           s_return(sc, mk_real(sc, acos(rvalue(x))));
02785 
02786      <span class="keywordflow">case</span> OP_ATAN:
02787           x=car(sc-&gt;args);
02788           <span class="keywordflow">if</span>(cdr(sc-&gt;args)==sc-&gt;NIL) {
02789                s_return(sc, mk_real(sc, atan(rvalue(x))));
02790           } <span class="keywordflow">else</span> {
02791                pointer y=cadr(sc-&gt;args);
02792                s_return(sc, mk_real(sc, atan2(rvalue(x),rvalue(y))));
02793           }
02794 
02795      <span class="keywordflow">case</span> OP_SQRT:
02796           x=car(sc-&gt;args);
02797           s_return(sc, mk_real(sc, sqrt(rvalue(x))));
02798 
02799      <span class="keywordflow">case</span> OP_EXPT:
02800           x=car(sc-&gt;args);
02801           <span class="keywordflow">if</span>(cdr(sc-&gt;args)==sc-&gt;NIL) {
02802                Error_0(sc,<span class="stringliteral">"expt: needs two arguments"</span>);
02803           } <span class="keywordflow">else</span> {
02804                pointer y=cadr(sc-&gt;args);
02805                s_return(sc, mk_real(sc, pow(rvalue(x),rvalue(y))));
02806           }
02807 
02808      <span class="keywordflow">case</span> OP_FLOOR:
02809           x=car(sc-&gt;args);
02810          s_return(sc, mk_real(sc, floor(rvalue(x))));
02811 
02812      <span class="keywordflow">case</span> OP_CEILING:
02813           x=car(sc-&gt;args);
02814          s_return(sc, mk_real(sc, ceil(rvalue(x))));
02815 
02816      <span class="keywordflow">case</span> OP_TRUNCATE : {
02817          <span class="keywordtype">double</span> rvalue_of_x ;
02818           x=car(sc-&gt;args);
02819          rvalue_of_x = rvalue(x) ;
02820          <span class="keywordflow">if</span> (rvalue_of_x &gt; 0) {
02821            s_return(sc, mk_real(sc, floor(rvalue_of_x)));
02822          } <span class="keywordflow">else</span> {
02823            s_return(sc, mk_real(sc, ceil(rvalue_of_x)));
02824          }
02825      }
02826 
02827      <span class="keywordflow">case</span> OP_ROUND:
02828        x=car(sc-&gt;args);
02829        s_return(sc, mk_real(sc, round_per_R5RS(rvalue(x))));
02830 <span class="preprocessor">#endif</span>
02831 <span class="preprocessor"></span>
02832      <span class="keywordflow">case</span> OP_ADD:        <span class="comment">/* + */</span>
02833        v=num_zero;
02834        <span class="keywordflow">for</span> (x = sc-&gt;args; x != sc-&gt;NIL; x = cdr(x)) {
02835         v=num_add(v,nvalue(car(x)));
02836        }
02837        s_return(sc,mk_number(sc, v));
02838 
02839      <span class="keywordflow">case</span> OP_MUL:        <span class="comment">/* * */</span>
02840        v=num_one;
02841        <span class="keywordflow">for</span> (x = sc-&gt;args; x != sc-&gt;NIL; x = cdr(x)) {
02842         v=num_mul(v,nvalue(car(x)));
02843        }
02844        s_return(sc,mk_number(sc, v));
02845 
02846      <span class="keywordflow">case</span> OP_SUB:        <span class="comment">/* - */</span>
02847        <span class="keywordflow">if</span>(cdr(sc-&gt;args)==sc-&gt;NIL) {
02848         x=sc-&gt;args;
02849         v=num_zero;
02850        } <span class="keywordflow">else</span> {
02851         x = cdr(sc-&gt;args);
02852         v = nvalue(car(sc-&gt;args));
02853        }
02854        <span class="keywordflow">for</span> (; x != sc-&gt;NIL; x = cdr(x)) {
02855         v=num_sub(v,nvalue(car(x)));
02856        }
02857        s_return(sc,mk_number(sc, v));
02858 
02859      <span class="keywordflow">case</span> OP_DIV:        <span class="comment">/* / */</span>
02860        <span class="keywordflow">if</span>(cdr(sc-&gt;args)==sc-&gt;NIL) {
02861         x=sc-&gt;args;
02862         v=num_one;
02863        } <span class="keywordflow">else</span> {
02864         x = cdr(sc-&gt;args);
02865         v = nvalue(car(sc-&gt;args));
02866        }
02867        <span class="keywordflow">for</span> (; x != sc-&gt;NIL; x = cdr(x)) {
02868         <span class="keywordflow">if</span> (!is_zero_double(rvalue(car(x))))
02869           v=num_div(v,nvalue(car(x)));
02870         <span class="keywordflow">else</span> {
02871           Error_0(sc,<span class="stringliteral">"/: division by zero"</span>);
02872         }
02873        }
02874        s_return(sc,mk_number(sc, v));
02875 
02876      <span class="keywordflow">case</span> OP_INTDIV:        <span class="comment">/* quotient */</span>
02877           <span class="keywordflow">if</span>(cdr(sc-&gt;args)==sc-&gt;NIL) {
02878                x=sc-&gt;args;
02879                v=num_one;
02880           } <span class="keywordflow">else</span> {
02881                x = cdr(sc-&gt;args);
02882                v = nvalue(car(sc-&gt;args));
02883           }
02884           <span class="keywordflow">for</span> (; x != sc-&gt;NIL; x = cdr(x)) {
02885                <span class="keywordflow">if</span> (ivalue(car(x)) != 0)
02886                     v=num_intdiv(v,nvalue(car(x)));
02887                <span class="keywordflow">else</span> {
02888                     Error_0(sc,<span class="stringliteral">"quotient: division by zero"</span>);
02889                }
02890           }
02891           s_return(sc,mk_number(sc, v));
02892 
02893      <span class="keywordflow">case</span> OP_REM:        <span class="comment">/* remainder */</span>
02894           v = nvalue(car(sc-&gt;args));
02895           <span class="keywordflow">if</span> (ivalue(cadr(sc-&gt;args)) != 0)
02896                v=num_rem(v,nvalue(cadr(sc-&gt;args)));
02897           <span class="keywordflow">else</span> {
02898                Error_0(sc,<span class="stringliteral">"remainder: division by zero"</span>);
02899           }
02900           s_return(sc,mk_number(sc, v));
02901 
02902      <span class="keywordflow">case</span> OP_MOD:        <span class="comment">/* modulo */</span>
02903           v = nvalue(car(sc-&gt;args));
02904           <span class="keywordflow">if</span> (ivalue(cadr(sc-&gt;args)) != 0)
02905                v=num_mod(v,nvalue(cadr(sc-&gt;args)));
02906           <span class="keywordflow">else</span> {
02907                Error_0(sc,<span class="stringliteral">"modulo: division by zero"</span>);
02908           }
02909           s_return(sc,mk_number(sc, v));
02910 
02911      <span class="keywordflow">case</span> OP_CAR:        <span class="comment">/* car */</span>
02912        s_return(sc,caar(sc-&gt;args));
02913 
02914      <span class="keywordflow">case</span> OP_CDR:        <span class="comment">/* cdr */</span>
02915        s_return(sc,cdar(sc-&gt;args));
02916 
02917      <span class="keywordflow">case</span> OP_CONS:       <span class="comment">/* cons */</span>
02918           cdr(sc-&gt;args) = cadr(sc-&gt;args);
02919           s_return(sc,sc-&gt;args);
02920 
02921      <span class="keywordflow">case</span> OP_SETCAR:     <span class="comment">/* set-car! */</span>
02922        <span class="keywordflow">if</span>(!is_immutable(car(sc-&gt;args))) {
02923         caar(sc-&gt;args) = cadr(sc-&gt;args);
02924         s_return(sc,car(sc-&gt;args));
02925        } <span class="keywordflow">else</span> {
02926         Error_0(sc,<span class="stringliteral">"set-car!: unable to alter immutable pair"</span>);
02927        }
02928 
02929      <span class="keywordflow">case</span> OP_SETCDR:     <span class="comment">/* set-cdr! */</span>
02930        <span class="keywordflow">if</span>(!is_immutable(car(sc-&gt;args))) {
02931         cdar(sc-&gt;args) = cadr(sc-&gt;args);
02932         s_return(sc,car(sc-&gt;args));
02933        } <span class="keywordflow">else</span> {
02934         Error_0(sc,<span class="stringliteral">"set-cdr!: unable to alter immutable pair"</span>);
02935        }
02936 
02937      <span class="keywordflow">case</span> OP_CHAR2INT: { <span class="comment">/* char-&gt;integer */</span>
02938           <span class="keywordtype">char</span> c;
02939           c=(char)ivalue(car(sc-&gt;args));
02940           s_return(sc,mk_integer(sc,(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)c));
02941      }
02942 
02943      <span class="keywordflow">case</span> OP_INT2CHAR: { <span class="comment">/* integer-&gt;char */</span>
02944           <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c;
02945           c=(<span class="keywordtype">unsigned</span> char)ivalue(car(sc-&gt;args));
02946           s_return(sc,mk_character(sc,(<span class="keywordtype">char</span>)c));
02947      }
02948 
02949      <span class="keywordflow">case</span> OP_CHARUPCASE: {
02950           <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c;
02951           c=(<span class="keywordtype">unsigned</span> char)ivalue(car(sc-&gt;args));
02952           c=toupper(c);
02953           s_return(sc,mk_character(sc,(<span class="keywordtype">char</span>)c));
02954      }
02955 
02956      <span class="keywordflow">case</span> OP_CHARDNCASE: {
02957           <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c;
02958           c=(<span class="keywordtype">unsigned</span> char)ivalue(car(sc-&gt;args));
02959           c=tolower(c);
02960           s_return(sc,mk_character(sc,(<span class="keywordtype">char</span>)c));
02961      }
02962 
02963      <span class="keywordflow">case</span> OP_STR2SYM:  <span class="comment">/* string-&gt;symbol */</span>
02964           s_return(sc,mk_symbol(sc,strvalue(car(sc-&gt;args))));
02965 
02966      <span class="keywordflow">case</span> OP_STR2ATOM: <span class="comment">/* string-&gt;atom */</span> {
02967        <span class="keywordtype">char</span> *s=strvalue(car(sc-&gt;args));
02968        <span class="keywordflow">if</span>(*s==<span class="charliteral">'#'</span>) {
02969         s_return(sc, mk_sharp_const(sc, s+1));
02970        } <span class="keywordflow">else</span> {
02971         s_return(sc, mk_atom(sc, s));
02972        }
02973      }
02974 
02975      <span class="keywordflow">case</span> OP_SYM2STR: <span class="comment">/* symbol-&gt;string */</span>
02976           x=mk_string(sc,symname(car(sc-&gt;args)));
02977           setimmutable(x);
02978           s_return(sc,x);
02979      <span class="keywordflow">case</span> OP_ATOM2STR: <span class="comment">/* atom-&gt;string */</span>
02980        x=car(sc-&gt;args);
02981        <span class="keywordflow">if</span>(is_number(x) || is_character(x) || is_string(x) || is_symbol(x)) {
02982         <span class="keywordtype">char</span> *p;
02983         <span class="keywordtype">int</span> len;
02984         atom2str(sc,x,0,&amp;p,&amp;len);
02985         s_return(sc,mk_counted_string(sc,p,len));
02986        } <span class="keywordflow">else</span> {
02987         Error_1(sc, <span class="stringliteral">"atom-&gt;string: not an atom:"</span>, x);
02988        }
02989 
02990      <span class="keywordflow">case</span> OP_MKSTRING: { <span class="comment">/* make-string */</span>
02991           <span class="keywordtype">int</span> fill=<span class="charliteral">' '</span>;
02992           <span class="keywordtype">int</span> len;
02993 
02994           len=ivalue(car(sc-&gt;args));
02995 
02996           <span class="keywordflow">if</span>(cdr(sc-&gt;args)!=sc-&gt;NIL) {
02997                fill=charvalue(cadr(sc-&gt;args));
02998           }
02999           s_return(sc,mk_empty_string(sc,len,(<span class="keywordtype">char</span>)fill));
03000      }
03001 
03002      <span class="keywordflow">case</span> OP_STRLEN:  <span class="comment">/* string-length */</span>
03003           s_return(sc,mk_integer(sc,strlength(car(sc-&gt;args))));
03004 
03005      <span class="keywordflow">case</span> OP_STRREF: { <span class="comment">/* string-ref */</span>
03006           <span class="keywordtype">char</span> *str;
03007           <span class="keywordtype">int</span> index;
03008 
03009           str=strvalue(car(sc-&gt;args));
03010 
03011           index=ivalue(cadr(sc-&gt;args));
03012 
03013           <span class="keywordflow">if</span>(index&gt;=strlength(car(sc-&gt;args))) {
03014                Error_1(sc,<span class="stringliteral">"string-ref: out of bounds:"</span>,cadr(sc-&gt;args));
03015           }
03016 
03017           s_return(sc,mk_character(sc,((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)str)[index]));
03018      }
03019 
03020      <span class="keywordflow">case</span> OP_STRSET: { <span class="comment">/* string-set! */</span>
03021           <span class="keywordtype">char</span> *str;
03022           <span class="keywordtype">int</span> index;
03023           <span class="keywordtype">int</span> c;
03024 
03025           <span class="keywordflow">if</span>(is_immutable(car(sc-&gt;args))) {
03026                Error_1(sc,<span class="stringliteral">"string-set!: unable to alter immutable string:"</span>,car(sc-&gt;args));
03027           }
03028           str=strvalue(car(sc-&gt;args));
03029 
03030           index=ivalue(cadr(sc-&gt;args));
03031           <span class="keywordflow">if</span>(index&gt;=strlength(car(sc-&gt;args))) {
03032                Error_1(sc,<span class="stringliteral">"string-set!: out of bounds:"</span>,cadr(sc-&gt;args));
03033           }
03034 
03035           c=charvalue(caddr(sc-&gt;args));
03036 
03037           str[index]=(char)c;
03038           s_return(sc,car(sc-&gt;args));
03039      }
03040 
03041      <span class="keywordflow">case</span> OP_STRAPPEND: { <span class="comment">/* string-append */</span>
03042        <span class="comment">/* in 1.29 string-append was in Scheme in init.scm but was too slow */</span>
03043        <span class="keywordtype">int</span> len = 0;
03044        pointer newstr;
03045        <span class="keywordtype">char</span> *pos;
03046 
03047        <span class="comment">/* compute needed length for new string */</span>
03048        <span class="keywordflow">for</span> (x = sc-&gt;args; x != sc-&gt;NIL; x = cdr(x)) {
03049           len += strlength(car(x));
03050        }
03051        newstr = mk_empty_string(sc, len, <span class="charliteral">' '</span>);
03052        <span class="comment">/* store the contents of the argument strings into the new string */</span>
03053        <span class="keywordflow">for</span> (pos = strvalue(newstr), x = sc-&gt;args; x != sc-&gt;NIL;
03054            pos += strlength(car(x)), x = cdr(x)) {
03055            memcpy(pos, strvalue(car(x)), strlength(car(x)));
03056        }
03057        s_return(sc, newstr);
03058      }
03059 
03060      <span class="keywordflow">case</span> OP_SUBSTR: { <span class="comment">/* substring */</span>
03061           <span class="keywordtype">char</span> *str;
03062           <span class="keywordtype">int</span> index0;
03063           <span class="keywordtype">int</span> index1;
03064           <span class="keywordtype">int</span> len;
03065 
03066           str=strvalue(car(sc-&gt;args));
03067 
03068           index0=ivalue(cadr(sc-&gt;args));
03069 
03070           <span class="keywordflow">if</span>(index0&gt;strlength(car(sc-&gt;args))) {
03071                Error_1(sc,<span class="stringliteral">"substring: start out of bounds:"</span>,cadr(sc-&gt;args));
03072           }
03073 
03074           <span class="keywordflow">if</span>(cddr(sc-&gt;args)!=sc-&gt;NIL) {
03075                index1=ivalue(caddr(sc-&gt;args));
03076                <span class="keywordflow">if</span>(index1&gt;strlength(car(sc-&gt;args)) || index1&lt;index0) {
03077                     Error_1(sc,<span class="stringliteral">"substring: end out of bounds:"</span>,caddr(sc-&gt;args));
03078                }
03079           } <span class="keywordflow">else</span> {
03080                index1=strlength(car(sc-&gt;args));
03081           }
03082 
03083           len=index1-index0;
03084           x=mk_empty_string(sc,len,<span class="charliteral">' '</span>);
03085           memcpy(strvalue(x),str+index0,len);
03086           strvalue(x)[len]=0;
03087 
03088           s_return(sc,x);
03089      }
03090 
03091      <span class="keywordflow">case</span> OP_VECTOR: {   <span class="comment">/* vector */</span>
03092           <span class="keywordtype">int</span> i;
03093           pointer vec;
03094           <span class="keywordtype">int</span> len=list_length(sc,sc-&gt;args);
03095           <span class="keywordflow">if</span>(len&lt;0) {
03096                Error_1(sc,<span class="stringliteral">"vector: not a proper list:"</span>,sc-&gt;args);
03097           }
03098           vec=mk_vector(sc,len);
03099           <span class="keywordflow">for</span> (x = sc-&gt;args, i = 0; is_pair(x); x = cdr(x), i++) {
03100                set_vector_elem(vec,i,car(x));
03101           }
03102           s_return(sc,vec);
03103      }
03104 
03105      <span class="keywordflow">case</span> OP_MKVECTOR: { <span class="comment">/* make-vector */</span>
03106           pointer fill=sc-&gt;NIL;
03107           <span class="keywordtype">int</span> len;
03108           pointer vec;
03109 
03110           len=ivalue(car(sc-&gt;args));
03111 
03112           <span class="keywordflow">if</span>(cdr(sc-&gt;args)!=sc-&gt;NIL) {
03113                fill=cadr(sc-&gt;args);
03114           }
03115           vec=mk_vector(sc,len);
03116           <span class="keywordflow">if</span>(fill!=sc-&gt;NIL) {
03117                fill_vector(vec,fill);
03118           }
03119           s_return(sc,vec);
03120      }
03121 
03122      <span class="keywordflow">case</span> OP_VECLEN:  <span class="comment">/* vector-length */</span>
03123           s_return(sc,mk_integer(sc,ivalue(car(sc-&gt;args))));
03124 
03125      <span class="keywordflow">case</span> OP_VECREF: { <span class="comment">/* vector-ref */</span>
03126           <span class="keywordtype">int</span> index;
03127 
03128           index=ivalue(cadr(sc-&gt;args));
03129 
03130           <span class="keywordflow">if</span>(index&gt;=ivalue(car(sc-&gt;args))) {
03131                Error_1(sc,<span class="stringliteral">"vector-ref: out of bounds:"</span>,cadr(sc-&gt;args));
03132           }
03133 
03134           s_return(sc,vector_elem(car(sc-&gt;args),index));
03135      }
03136 
03137      <span class="keywordflow">case</span> OP_VECSET: {   <span class="comment">/* vector-set! */</span>
03138           <span class="keywordtype">int</span> index;
03139 
03140           <span class="keywordflow">if</span>(is_immutable(car(sc-&gt;args))) {
03141                Error_1(sc,<span class="stringliteral">"vector-set!: unable to alter immutable vector:"</span>,car(sc-&gt;args));
03142           }
03143 
03144           index=ivalue(cadr(sc-&gt;args));
03145           <span class="keywordflow">if</span>(index&gt;=ivalue(car(sc-&gt;args))) {
03146                Error_1(sc,<span class="stringliteral">"vector-set!: out of bounds:"</span>,cadr(sc-&gt;args));
03147           }
03148 
03149           set_vector_elem(car(sc-&gt;args),index,caddr(sc-&gt;args));
03150           s_return(sc,car(sc-&gt;args));
03151      }
03152 
03153      <span class="keywordflow">default</span>:
03154           sprintf(sc-&gt;strbuff, <span class="stringliteral">"%d: illegal operator"</span>, sc-&gt;op);
03155           Error_0(sc,sc-&gt;strbuff);
03156      }
03157      <span class="keywordflow">return</span> sc-&gt;T;
03158 }
03159 
03160 <span class="keyword">static</span> <span class="keywordtype">int</span> list_length(scheme *sc, pointer a) {
03161      <span class="keywordtype">int</span> v=0;
03162      pointer x;
03163      <span class="keywordflow">for</span> (x = a, v = 0; is_pair(x); x = cdr(x)) {
03164           ++v;
03165      }
03166      <span class="keywordflow">if</span>(x==sc-&gt;NIL) {
03167           <span class="keywordflow">return</span> v;
03168      }
03169      <span class="keywordflow">return</span> -1;
03170 }
03171 
03172 <span class="keyword">static</span> pointer opexe_3(scheme *sc, <span class="keyword">enum</span> scheme_opcodes op) {
03173      pointer x;
03174      num v;
03175      int (*comp_func)(num,num)=0;
03176 
03177      <span class="keywordflow">switch</span> (op) {
03178      <span class="keywordflow">case</span> OP_NOT:        <span class="comment">/* not */</span>
03179           s_retbool(is_false(car(sc-&gt;args)));
03180      <span class="keywordflow">case</span> OP_BOOLP:       <span class="comment">/* boolean? */</span>
03181           s_retbool(car(sc-&gt;args) == sc-&gt;F || car(sc-&gt;args) == sc-&gt;T);
03182      <span class="keywordflow">case</span> OP_EOFOBJP:       <span class="comment">/* boolean? */</span>
03183           s_retbool(car(sc-&gt;args) == sc-&gt;EOF_OBJ);
03184      <span class="keywordflow">case</span> OP_NULLP:       <span class="comment">/* null? */</span>
03185           s_retbool(car(sc-&gt;args) == sc-&gt;NIL);
03186      <span class="keywordflow">case</span> OP_NUMEQ:      <span class="comment">/* = */</span>
03187      <span class="keywordflow">case</span> OP_LESS:       <span class="comment">/* &lt; */</span>
03188      <span class="keywordflow">case</span> OP_GRE:        <span class="comment">/* &gt; */</span>
03189      <span class="keywordflow">case</span> OP_LEQ:        <span class="comment">/* &lt;= */</span>
03190      <span class="keywordflow">case</span> OP_GEQ:        <span class="comment">/* &gt;= */</span>
03191           <span class="keywordflow">switch</span>(op) {
03192                <span class="keywordflow">case</span> OP_NUMEQ: comp_func=num_eq; <span class="keywordflow">break</span>;
03193                <span class="keywordflow">case</span> OP_LESS:  comp_func=num_lt; <span class="keywordflow">break</span>;
03194                <span class="keywordflow">case</span> OP_GRE:   comp_func=num_gt; <span class="keywordflow">break</span>;
03195                <span class="keywordflow">case</span> OP_LEQ:   comp_func=num_le; <span class="keywordflow">break</span>;
03196                <span class="keywordflow">case</span> OP_GEQ:   comp_func=num_ge; <span class="keywordflow">break</span>;
03197               <span class="keywordflow">default</span>:
03198                  ;
03199           }
03200           x=sc-&gt;args;
03201           v=nvalue(car(x));
03202           x=cdr(x);
03203 
03204           <span class="keywordflow">for</span> (; x != sc-&gt;NIL; x = cdr(x)) {
03205                <span class="keywordflow">if</span>(!comp_func(v,nvalue(car(x)))) {
03206                     s_retbool(0);
03207                }
03208               v=nvalue(car(x));
03209           }
03210           s_retbool(1);
03211      <span class="keywordflow">case</span> OP_SYMBOLP:     <span class="comment">/* symbol? */</span>
03212           s_retbool(is_symbol(car(sc-&gt;args)));
03213      <span class="keywordflow">case</span> OP_NUMBERP:     <span class="comment">/* number? */</span>
03214           s_retbool(is_number(car(sc-&gt;args)));
03215      <span class="keywordflow">case</span> OP_STRINGP:     <span class="comment">/* string? */</span>
03216           s_retbool(is_string(car(sc-&gt;args)));
03217      <span class="keywordflow">case</span> OP_INTEGERP:     <span class="comment">/* integer? */</span>
03218           s_retbool(is_integer(car(sc-&gt;args)));
03219      <span class="keywordflow">case</span> OP_REALP:     <span class="comment">/* real? */</span>
03220           s_retbool(is_number(car(sc-&gt;args))); <span class="comment">/* All numbers are real */</span>
03221      <span class="keywordflow">case</span> OP_CHARP:     <span class="comment">/* char? */</span>
03222           s_retbool(is_character(car(sc-&gt;args)));
03223 <span class="preprocessor">#if USE_CHAR_CLASSIFIERS</span>
03224 <span class="preprocessor"></span>     <span class="keywordflow">case</span> OP_CHARAP:     <span class="comment">/* char-alphabetic? */</span>
03225           s_retbool(Cisalpha(ivalue(car(sc-&gt;args))));
03226      <span class="keywordflow">case</span> OP_CHARNP:     <span class="comment">/* char-numeric? */</span>
03227           s_retbool(Cisdigit(ivalue(car(sc-&gt;args))));
03228      <span class="keywordflow">case</span> OP_CHARWP:     <span class="comment">/* char-whitespace? */</span>
03229           s_retbool(Cisspace(ivalue(car(sc-&gt;args))));
03230      <span class="keywordflow">case</span> OP_CHARUP:     <span class="comment">/* char-upper-case? */</span>
03231           s_retbool(Cisupper(ivalue(car(sc-&gt;args))));
03232      <span class="keywordflow">case</span> OP_CHARLP:     <span class="comment">/* char-lower-case? */</span>
03233           s_retbool(Cislower(ivalue(car(sc-&gt;args))));
03234 <span class="preprocessor">#endif</span>
03235 <span class="preprocessor"></span>     <span class="keywordflow">case</span> OP_PORTP:     <span class="comment">/* port? */</span>
03236           s_retbool(is_port(car(sc-&gt;args)));
03237      <span class="keywordflow">case</span> OP_INPORTP:     <span class="comment">/* input-port? */</span>
03238           s_retbool(is_inport(car(sc-&gt;args)));
03239      <span class="keywordflow">case</span> OP_OUTPORTP:     <span class="comment">/* output-port? */</span>
03240           s_retbool(is_outport(car(sc-&gt;args)));
03241      <span class="keywordflow">case</span> OP_PROCP:       <span class="comment">/* procedure? */</span>
03242           <span class="comment">/*--</span>
03243 <span class="comment">              * continuation should be procedure by the example</span>
03244 <span class="comment">              * (call-with-current-continuation procedure?) ==&gt; #t</span>
03245 <span class="comment">                 * in R^3 report sec. 6.9</span>
03246 <span class="comment">              */</span>
03247           s_retbool(is_proc(car(sc-&gt;args)) || is_closure(car(sc-&gt;args))
03248                  || is_continuation(car(sc-&gt;args)) || is_foreign(car(sc-&gt;args)));
03249      <span class="keywordflow">case</span> OP_PAIRP:       <span class="comment">/* pair? */</span>
03250           s_retbool(is_pair(car(sc-&gt;args)));
03251      <span class="keywordflow">case</span> OP_LISTP: {     <span class="comment">/* list? */</span>
03252           pointer slow, fast;
03253           slow = fast = car(sc-&gt;args);
03254           <span class="keywordflow">while</span> (1) {
03255              <span class="keywordflow">if</span> (!is_pair(fast)) s_retbool(fast == sc-&gt;NIL);
03256              fast = cdr(fast);
03257              <span class="keywordflow">if</span> (!is_pair(fast)) s_retbool(fast == sc-&gt;NIL);
03258              fast = cdr(fast);
03259              slow = cdr(slow);
03260              <span class="keywordflow">if</span> (fast == slow) {
03261                   <span class="comment">/* the fast pointer has looped back around and caught up</span>
03262 <span class="comment">                     with the slow pointer, hence the structure is circular,</span>
03263 <span class="comment">                     not of finite length, and therefore not a list */</span>
03264                   s_retbool(0);
03265              }
03266           }
03267      }
03268      <span class="keywordflow">case</span> OP_ENVP:        <span class="comment">/* environment? */</span>
03269           s_retbool(is_environment(car(sc-&gt;args)));
03270      <span class="keywordflow">case</span> OP_VECTORP:     <span class="comment">/* vector? */</span>
03271           s_retbool(is_vector(car(sc-&gt;args)));
03272      <span class="keywordflow">case</span> OP_EQ:         <span class="comment">/* eq? */</span>
03273           s_retbool(car(sc-&gt;args) == cadr(sc-&gt;args));
03274      <span class="keywordflow">case</span> OP_EQV:        <span class="comment">/* eqv? */</span>
03275           s_retbool(eqv(car(sc-&gt;args), cadr(sc-&gt;args)));
03276      <span class="keywordflow">default</span>:
03277           sprintf(sc-&gt;strbuff, <span class="stringliteral">"%d: illegal operator"</span>, sc-&gt;op);
03278           Error_0(sc,sc-&gt;strbuff);
03279      }
03280      <span class="keywordflow">return</span> sc-&gt;T;
03281 }
03282 
03283 <span class="keyword">static</span> pointer opexe_4(scheme *sc, <span class="keyword">enum</span> scheme_opcodes op) {
03284      pointer x, y;
03285 
03286      <span class="keywordflow">switch</span> (op) {
03287      <span class="keywordflow">case</span> OP_FORCE:      <span class="comment">/* force */</span>
03288           sc-&gt;code = car(sc-&gt;args);
03289           <span class="keywordflow">if</span> (is_promise(sc-&gt;code)) {
03290                <span class="comment">/* Should change type to closure here */</span>
03291                s_save(sc, OP_SAVE_FORCED, sc-&gt;NIL, sc-&gt;code);
03292                sc-&gt;args = sc-&gt;NIL;
03293                s_goto(sc,OP_APPLY);
03294           } <span class="keywordflow">else</span> {
03295                s_return(sc,sc-&gt;code);
03296           }
03297 
03298      <span class="keywordflow">case</span> OP_SAVE_FORCED:     <span class="comment">/* Save forced value replacing promise */</span>
03299           memcpy(sc-&gt;code,sc-&gt;value,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> cell));
03300           s_return(sc,sc-&gt;value);
03301 
03302      <span class="keywordflow">case</span> OP_WRITE:      <span class="comment">/* write */</span>
03303      <span class="keywordflow">case</span> OP_DISPLAY:    <span class="comment">/* display */</span>
03304      <span class="keywordflow">case</span> OP_WRITE_CHAR: <span class="comment">/* write-char */</span>
03305           <span class="keywordflow">if</span>(is_pair(cdr(sc-&gt;args))) {
03306                <span class="keywordflow">if</span>(cadr(sc-&gt;args)!=sc-&gt;outport) {
03307                     x=cons(sc,sc-&gt;outport,sc-&gt;NIL);
03308                     s_save(sc,OP_SET_OUTPORT, x, sc-&gt;NIL);
03309                     sc-&gt;outport=cadr(sc-&gt;args);
03310                }
03311           }
03312           sc-&gt;args = car(sc-&gt;args);
03313           <span class="keywordflow">if</span>(op==OP_WRITE) {
03314                sc-&gt;print_flag = 1;
03315           } <span class="keywordflow">else</span> {
03316                sc-&gt;print_flag = 0;
03317           }
03318           s_goto(sc,OP_P0LIST);
03319 
03320      <span class="keywordflow">case</span> OP_NEWLINE:    <span class="comment">/* newline */</span>
03321           <span class="keywordflow">if</span>(is_pair(sc-&gt;args)) {
03322                <span class="keywordflow">if</span>(car(sc-&gt;args)!=sc-&gt;outport) {
03323                     x=cons(sc,sc-&gt;outport,sc-&gt;NIL);
03324                     s_save(sc,OP_SET_OUTPORT, x, sc-&gt;NIL);
03325                     sc-&gt;outport=car(sc-&gt;args);
03326                }
03327           }
03328           putstr(sc, <span class="stringliteral">"\n"</span>);
03329           s_return(sc,sc-&gt;T);
03330 
03331      <span class="keywordflow">case</span> OP_ERR0:  <span class="comment">/* error */</span>
03332           sc-&gt;retcode=-1;
03333           <span class="keywordflow">if</span> (!is_string(car(sc-&gt;args))) {
03334                sc-&gt;args=cons(sc,mk_string(sc,<span class="stringliteral">" -- "</span>),sc-&gt;args);
03335                setimmutable(car(sc-&gt;args));
03336           }
03337           putstr(sc, <span class="stringliteral">"Error: "</span>);
03338           putstr(sc, strvalue(car(sc-&gt;args)));
03339           sc-&gt;args = cdr(sc-&gt;args);
03340           s_goto(sc,OP_ERR1);
03341 
03342      <span class="keywordflow">case</span> OP_ERR1:  <span class="comment">/* error */</span>
03343           putstr(sc, <span class="stringliteral">" "</span>);
03344           <span class="keywordflow">if</span> (sc-&gt;args != sc-&gt;NIL) {
03345                s_save(sc,OP_ERR1, cdr(sc-&gt;args), sc-&gt;NIL);
03346                sc-&gt;args = car(sc-&gt;args);
03347                sc-&gt;print_flag = 1;
03348                s_goto(sc,OP_P0LIST);
03349           } <span class="keywordflow">else</span> {
03350                putstr(sc, <span class="stringliteral">"\n"</span>);
03351                <span class="keywordflow">if</span>(sc-&gt;interactive_repl) {
03352                     s_goto(sc,OP_T0LVL);
03353                } <span class="keywordflow">else</span> {
03354                     <span class="keywordflow">return</span> sc-&gt;NIL;
03355                }
03356           }
03357 
03358      <span class="keywordflow">case</span> OP_REVERSE:    <span class="comment">/* reverse */</span>
03359           s_return(sc,reverse(sc, car(sc-&gt;args)));
03360 
03361      <span class="keywordflow">case</span> OP_LIST_STAR: <span class="comment">/* list* */</span>
03362        s_return(sc,list_star(sc,sc-&gt;args));
03363 
03364      <span class="keywordflow">case</span> OP_APPEND:     <span class="comment">/* append */</span>
03365           <span class="keywordflow">if</span>(sc-&gt;args==sc-&gt;NIL) {
03366                s_return(sc,sc-&gt;NIL);
03367           }
03368           x=car(sc-&gt;args);
03369           <span class="keywordflow">if</span>(cdr(sc-&gt;args)==sc-&gt;NIL) {
03370            s_return(sc,sc-&gt;args);
03371          }
03372           <span class="keywordflow">for</span> (y = cdr(sc-&gt;args); y != sc-&gt;NIL; y = cdr(y)) {
03373                x=append(sc,x,car(y));
03374           }
03375           s_return(sc,x);
03376 
03377 <span class="preprocessor">#if USE_PLIST</span>
03378 <span class="preprocessor"></span>     <span class="keywordflow">case</span> OP_PUT:        <span class="comment">/* put */</span>
03379           <span class="keywordflow">if</span> (!hasprop(car(sc-&gt;args)) || !hasprop(cadr(sc-&gt;args))) {
03380                Error_0(sc,<span class="stringliteral">"illegal use of put"</span>);
03381           }
03382           <span class="keywordflow">for</span> (x = symprop(car(sc-&gt;args)), y = cadr(sc-&gt;args); x != sc-&gt;NIL; x = cdr(x)) {
03383                <span class="keywordflow">if</span> (caar(x) == y) {
03384                     <span class="keywordflow">break</span>;
03385                }
03386           }
03387           <span class="keywordflow">if</span> (x != sc-&gt;NIL)
03388                cdar(x) = caddr(sc-&gt;args);
03389           <span class="keywordflow">else</span>
03390                symprop(car(sc-&gt;args)) = cons(sc, cons(sc, y, caddr(sc-&gt;args)),
03391                                 symprop(car(sc-&gt;args)));
03392           s_return(sc,sc-&gt;T);
03393 
03394      <span class="keywordflow">case</span> OP_GET:        <span class="comment">/* get */</span>
03395           <span class="keywordflow">if</span> (!hasprop(car(sc-&gt;args)) || !hasprop(cadr(sc-&gt;args))) {
03396                Error_0(sc,<span class="stringliteral">"illegal use of get"</span>);
03397           }
03398           <span class="keywordflow">for</span> (x = symprop(car(sc-&gt;args)), y = cadr(sc-&gt;args); x != sc-&gt;NIL; x = cdr(x)) {
03399                <span class="keywordflow">if</span> (caar(x) == y) {
03400                     <span class="keywordflow">break</span>;
03401                }
03402           }
03403           <span class="keywordflow">if</span> (x != sc-&gt;NIL) {
03404                s_return(sc,cdar(x));
03405           } <span class="keywordflow">else</span> {
03406                s_return(sc,sc-&gt;NIL);
03407           }
03408 <span class="preprocessor">#endif </span><span class="comment">/* USE_PLIST */</span>
03409      <span class="keywordflow">case</span> OP_QUIT:       <span class="comment">/* quit */</span>
03410           <span class="keywordflow">if</span>(is_pair(sc-&gt;args)) {
03411                sc-&gt;retcode=ivalue(car(sc-&gt;args));
03412           }
03413           <span class="keywordflow">return</span> (sc-&gt;NIL);
03414 
03415      <span class="keywordflow">case</span> OP_GC:         <span class="comment">/* gc */</span>
03416           gc(sc, sc-&gt;NIL, sc-&gt;NIL);
03417           s_return(sc,sc-&gt;T);
03418 
03419      <span class="keywordflow">case</span> OP_GCVERB:          <span class="comment">/* gc-verbose */</span>
03420      {    <span class="keywordtype">int</span>  was = sc-&gt;gc_verbose;
03421           
03422           sc-&gt;gc_verbose = (car(sc-&gt;args) != sc-&gt;F);
03423           s_retbool(was);
03424      }
03425 
03426      <span class="keywordflow">case</span> OP_NEWSEGMENT: <span class="comment">/* new-segment */</span>
03427           <span class="keywordflow">if</span> (!is_pair(sc-&gt;args) || !is_number(car(sc-&gt;args))) {
03428                Error_0(sc,<span class="stringliteral">"new-segment: argument must be a number"</span>);
03429           }
03430           alloc_cellseg(sc, (<span class="keywordtype">int</span>) ivalue(car(sc-&gt;args)));
03431           s_return(sc,sc-&gt;T);
03432 
03433      <span class="keywordflow">case</span> OP_OBLIST: <span class="comment">/* oblist */</span>
03434           s_return(sc, oblist_all_symbols(sc)); 
03435 
03436      <span class="keywordflow">case</span> OP_CURR_INPORT: <span class="comment">/* current-input-port */</span>
03437           s_return(sc,sc-&gt;inport);
03438 
03439      <span class="keywordflow">case</span> OP_CURR_OUTPORT: <span class="comment">/* current-output-port */</span>
03440           s_return(sc,sc-&gt;outport);
03441 
03442      <span class="keywordflow">case</span> OP_OPEN_INFILE: <span class="comment">/* open-input-file */</span>
03443      <span class="keywordflow">case</span> OP_OPEN_OUTFILE: <span class="comment">/* open-output-file */</span>
03444      <span class="keywordflow">case</span> OP_OPEN_INOUTFILE: <span class="comment">/* open-input-output-file */</span> {
03445           <span class="keywordtype">int</span> prop=0;
03446           pointer p;
03447           <span class="keywordflow">switch</span>(op) {
03448                <span class="keywordflow">case</span> OP_OPEN_INFILE:     prop=port_input; <span class="keywordflow">break</span>;
03449                <span class="keywordflow">case</span> OP_OPEN_OUTFILE:    prop=port_output; <span class="keywordflow">break</span>;
03450                <span class="keywordflow">case</span> OP_OPEN_INOUTFILE: prop=port_input|port_output; <span class="keywordflow">break</span>;
03451               <span class="keywordflow">default</span>: 
03452                  ;
03453           }
03454           p=port_from_filename(sc,strvalue(car(sc-&gt;args)),prop);
03455           <span class="keywordflow">if</span>(p==sc-&gt;NIL) {
03456                s_return(sc,sc-&gt;F);
03457           }
03458           s_return(sc,p);
03459      }
03460      
03461 <span class="preprocessor">#if USE_STRING_PORTS</span>
03462 <span class="preprocessor"></span>     <span class="keywordflow">case</span> OP_OPEN_INSTRING: <span class="comment">/* open-input-string */</span>
03463      <span class="keywordflow">case</span> OP_OPEN_OUTSTRING: <span class="comment">/* open-output-string */</span>
03464      <span class="keywordflow">case</span> OP_OPEN_INOUTSTRING: <span class="comment">/* open-input-output-string */</span> {
03465           <span class="keywordtype">int</span> prop=0;
03466           pointer p;
03467           <span class="keywordflow">switch</span>(op) {
03468                <span class="keywordflow">case</span> OP_OPEN_INSTRING:     prop=port_input; <span class="keywordflow">break</span>;
03469                <span class="keywordflow">case</span> OP_OPEN_OUTSTRING:    prop=port_output; <span class="keywordflow">break</span>;
03470                <span class="keywordflow">case</span> OP_OPEN_INOUTSTRING:  prop=port_input|port_output; <span class="keywordflow">break</span>;
03471               <span class="keywordflow">default</span>:
03472                  ;
03473           }
03474           p=port_from_string(sc, strvalue(car(sc-&gt;args)),
03475                     strvalue(car(sc-&gt;args))+strlength(car(sc-&gt;args)), prop);
03476           <span class="keywordflow">if</span>(p==sc-&gt;NIL) {
03477                s_return(sc,sc-&gt;F);
03478           }
03479           s_return(sc,p);
03480      }
03481 <span class="preprocessor">#endif</span>
03482 <span class="preprocessor"></span>
03483      <span class="keywordflow">case</span> OP_CLOSE_INPORT: <span class="comment">/* close-input-port */</span>
03484           port_close(sc,car(sc-&gt;args),port_input);
03485           s_return(sc,sc-&gt;T);
03486 
03487      <span class="keywordflow">case</span> OP_CLOSE_OUTPORT: <span class="comment">/* close-output-port */</span>
03488           port_close(sc,car(sc-&gt;args),port_output);
03489           s_return(sc,sc-&gt;T);
03490 
03491      <span class="keywordflow">case</span> OP_INT_ENV: <span class="comment">/* interaction-environment */</span>
03492           s_return(sc,sc-&gt;global_env);
03493 
03494      <span class="keywordflow">case</span> OP_CURR_ENV: <span class="comment">/* current-environment */</span>
03495           s_return(sc,sc-&gt;envir);
03496      <span class="keywordflow">default</span>:
03497         ;
03498      }
03499      <span class="keywordflow">return</span> sc-&gt;T;
03500 }
03501 
03502 <span class="keyword">static</span> pointer opexe_5(scheme *sc, <span class="keyword">enum</span> scheme_opcodes op) {
03503      pointer x;
03504 
03505      <span class="keywordflow">if</span>(sc-&gt;nesting!=0) {
03506           <span class="keywordtype">int</span> n=sc-&gt;nesting;
03507           sc-&gt;nesting=0;
03508           sc-&gt;retcode=-1;
03509           Error_1(sc,<span class="stringliteral">"unmatched parentheses:"</span>,mk_integer(sc,n));
03510      }
03511 
03512      <span class="keywordflow">switch</span> (op) {
03513      <span class="comment">/* ========== reading part ========== */</span>
03514      <span class="keywordflow">case</span> OP_READ:
03515           <span class="keywordflow">if</span>(!is_pair(sc-&gt;args)) {
03516                s_goto(sc,OP_READ_INTERNAL);
03517           }
03518           <span class="keywordflow">if</span>(!is_inport(car(sc-&gt;args))) {
03519                Error_1(sc,<span class="stringliteral">"read: not an input port:"</span>,car(sc-&gt;args));
03520           }
03521           <span class="keywordflow">if</span>(car(sc-&gt;args)==sc-&gt;inport) {
03522                s_goto(sc,OP_READ_INTERNAL);
03523           }
03524           x=sc-&gt;inport;
03525           sc-&gt;inport=car(sc-&gt;args);
03526           x=cons(sc,x,sc-&gt;NIL);
03527           s_save(sc,OP_SET_INPORT, x, sc-&gt;NIL);
03528           s_goto(sc,OP_READ_INTERNAL);
03529 
03530      <span class="keywordflow">case</span> OP_READ_CHAR: <span class="comment">/* read-char */</span>
03531      <span class="keywordflow">case</span> OP_PEEK_CHAR: <span class="comment">/* peek-char */</span> {
03532           <span class="keywordtype">int</span> c;
03533           <span class="keywordflow">if</span>(is_pair(sc-&gt;args)) {
03534                <span class="keywordflow">if</span>(car(sc-&gt;args)!=sc-&gt;inport) {
03535                     x=sc-&gt;inport;
03536                     x=cons(sc,x,sc-&gt;NIL);
03537                     s_save(sc,OP_SET_INPORT, x, sc-&gt;NIL);
03538                     sc-&gt;inport=car(sc-&gt;args);
03539                }
03540           }
03541           c=inchar(sc);
03542           <span class="keywordflow">if</span>(c==EOF) {
03543                s_return(sc,sc-&gt;EOF_OBJ);
03544           }
03545           <span class="keywordflow">if</span>(sc-&gt;op==OP_PEEK_CHAR) {
03546                backchar(sc,c);
03547           }
03548           s_return(sc,mk_character(sc,c));
03549      }
03550 
03551      <span class="keywordflow">case</span> OP_CHAR_READY: <span class="comment">/* char-ready? */</span> {
03552           pointer p=sc-&gt;inport;
03553           <span class="keywordtype">int</span> res;
03554           <span class="keywordflow">if</span>(is_pair(sc-&gt;args)) {
03555                p=car(sc-&gt;args);
03556           }
03557           res=p-&gt;_object._port-&gt;kind&amp;port_string;
03558           s_retbool(res);
03559      }
03560 
03561      <span class="keywordflow">case</span> OP_SET_INPORT: <span class="comment">/* set-input-port */</span>
03562           sc-&gt;inport=car(sc-&gt;args);
03563           s_return(sc,sc-&gt;value);
03564 
03565      <span class="keywordflow">case</span> OP_SET_OUTPORT: <span class="comment">/* set-output-port */</span>
03566           sc-&gt;outport=car(sc-&gt;args);
03567           s_return(sc,sc-&gt;value);
03568 
03569      <span class="keywordflow">case</span> OP_RDSEXPR:
03570           <span class="keywordflow">switch</span> (sc-&gt;tok) {
03571           <span class="keywordflow">case</span> TOK_EOF:
03572                <span class="keywordflow">if</span>(sc-&gt;inport==sc-&gt;loadport) {
03573                     sc-&gt;args=sc-&gt;NIL;
03574                     s_goto(sc,OP_QUIT);
03575                } <span class="keywordflow">else</span> {
03576                     s_return(sc,sc-&gt;EOF_OBJ);
03577                }
03578           <span class="keywordflow">case</span> TOK_COMMENT: {
03579                <span class="keywordtype">int</span> c;
03580                <span class="keywordflow">while</span> ((c=inchar(sc)) != <span class="charliteral">'\n'</span> &amp;&amp; c!=EOF)
03581                     ;
03582                sc-&gt;tok = token(sc);
03583                s_goto(sc,OP_RDSEXPR);
03584           }
03585           <span class="keywordflow">case</span> TOK_VEC:
03586                s_save(sc,OP_RDVEC,sc-&gt;NIL,sc-&gt;NIL);
03587                <span class="comment">/* fall through */</span>
03588           <span class="keywordflow">case</span> TOK_LPAREN:
03589                sc-&gt;tok = token(sc);
03590                <span class="keywordflow">if</span> (sc-&gt;tok == TOK_RPAREN) {
03591                     s_return(sc,sc-&gt;NIL);
03592                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sc-&gt;tok == TOK_DOT) {
03593                     Error_0(sc,<span class="stringliteral">"syntax error: illegal dot expression"</span>);
03594                } <span class="keywordflow">else</span> {
03595                     sc-&gt;nesting_stack[sc-&gt;file_i]++;
03596                     s_save(sc,OP_RDLIST, sc-&gt;NIL, sc-&gt;NIL);
03597                     s_goto(sc,OP_RDSEXPR);
03598                }
03599           <span class="keywordflow">case</span> TOK_QUOTE:
03600                s_save(sc,OP_RDQUOTE, sc-&gt;NIL, sc-&gt;NIL);
03601                sc-&gt;tok = token(sc);
03602                s_goto(sc,OP_RDSEXPR);
03603           <span class="keywordflow">case</span> TOK_BQUOTE:
03604                sc-&gt;tok = token(sc);
03605               <span class="keywordflow">if</span>(sc-&gt;tok==TOK_VEC) {
03606                s_save(sc,OP_RDQQUOTEVEC, sc-&gt;NIL, sc-&gt;NIL);
03607                sc-&gt;tok=TOK_LPAREN;
03608                s_goto(sc,OP_RDSEXPR);
03609               } <span class="keywordflow">else</span> {
03610                s_save(sc,OP_RDQQUOTE, sc-&gt;NIL, sc-&gt;NIL);
03611               }
03612                s_goto(sc,OP_RDSEXPR);
03613           <span class="keywordflow">case</span> TOK_COMMA:
03614                s_save(sc,OP_RDUNQUOTE, sc-&gt;NIL, sc-&gt;NIL);
03615                sc-&gt;tok = token(sc);
03616                s_goto(sc,OP_RDSEXPR);
03617           <span class="keywordflow">case</span> TOK_ATMARK:
03618                s_save(sc,OP_RDUQTSP, sc-&gt;NIL, sc-&gt;NIL);
03619                sc-&gt;tok = token(sc);
03620                s_goto(sc,OP_RDSEXPR);
03621           <span class="keywordflow">case</span> TOK_ATOM:
03622                s_return(sc,mk_atom(sc, readstr_upto(sc, <span class="stringliteral">"();\t\n\r "</span>)));
03623           <span class="keywordflow">case</span> TOK_DQUOTE:
03624                x=readstrexp(sc);
03625               <span class="keywordflow">if</span>(x==sc-&gt;F) {
03626                Error_0(sc,<span class="stringliteral">"Error reading string"</span>);
03627               }
03628                setimmutable(x);
03629                s_return(sc,x);
03630           <span class="keywordflow">case</span> TOK_SHARP: {
03631                pointer f=find_slot_in_env(sc,sc-&gt;envir,sc-&gt;SHARP_HOOK,1);
03632                <span class="keywordflow">if</span>(f==sc-&gt;NIL) {
03633                     Error_0(sc,<span class="stringliteral">"undefined sharp expression"</span>);
03634                } <span class="keywordflow">else</span> {
03635                     sc-&gt;code=cons(sc,slot_value_in_env(f),sc-&gt;NIL); 
03636                     s_goto(sc,OP_EVAL);
03637                }
03638           }
03639           <span class="keywordflow">case</span> TOK_SHARP_CONST:
03640                <span class="keywordflow">if</span> ((x = mk_sharp_const(sc, readstr_upto(sc, <span class="stringliteral">"();\t\n\r "</span>))) == sc-&gt;NIL) {
03641                     Error_0(sc,<span class="stringliteral">"undefined sharp expression"</span>);
03642                } <span class="keywordflow">else</span> {
03643                     s_return(sc,x);
03644                }
03645           <span class="keywordflow">default</span>:
03646                Error_0(sc,<span class="stringliteral">"syntax error: illegal token"</span>);
03647           }
03648           <span class="keywordflow">break</span>;
03649 
03650      <span class="keywordflow">case</span> OP_RDLIST: {
03651           sc-&gt;args = cons(sc, sc-&gt;value, sc-&gt;args);
03652           sc-&gt;tok = token(sc);
03653           <span class="keywordflow">if</span> (sc-&gt;tok == TOK_COMMENT) {
03654                <span class="keywordtype">int</span> c;
03655                <span class="keywordflow">while</span> ((c=inchar(sc)) != <span class="charliteral">'\n'</span> &amp;&amp; c!=EOF)
03656                     ;
03657                sc-&gt;tok = token(sc);
03658           }
03659           <span class="keywordflow">if</span> (sc-&gt;tok == TOK_RPAREN) {
03660                <span class="keywordtype">int</span> c = inchar(sc);
03661                <span class="keywordflow">if</span> (c != <span class="charliteral">'\n'</span>) backchar(sc,c);
03662                sc-&gt;nesting_stack[sc-&gt;file_i]--;
03663                s_return(sc,reverse_in_place(sc, sc-&gt;NIL, sc-&gt;args));
03664           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sc-&gt;tok == TOK_DOT) {
03665                s_save(sc,OP_RDDOT, sc-&gt;args, sc-&gt;NIL);
03666                sc-&gt;tok = token(sc);
03667                s_goto(sc,OP_RDSEXPR);
03668           } <span class="keywordflow">else</span> {
03669                s_save(sc,OP_RDLIST, sc-&gt;args, sc-&gt;NIL);;
03670                s_goto(sc,OP_RDSEXPR);
03671           }
03672      }
03673 
03674      <span class="keywordflow">case</span> OP_RDDOT:
03675           <span class="keywordflow">if</span> (token(sc) != TOK_RPAREN) {
03676                Error_0(sc,<span class="stringliteral">"syntax error: illegal dot expression"</span>);
03677           } <span class="keywordflow">else</span> {
03678                sc-&gt;nesting_stack[sc-&gt;file_i]--;
03679                s_return(sc,reverse_in_place(sc, sc-&gt;value, sc-&gt;args));
03680           }
03681 
03682      <span class="keywordflow">case</span> OP_RDQUOTE:
03683           s_return(sc,cons(sc, sc-&gt;QUOTE, cons(sc, sc-&gt;value, sc-&gt;NIL)));
03684 
03685      <span class="keywordflow">case</span> OP_RDQQUOTE:
03686           s_return(sc,cons(sc, sc-&gt;QQUOTE, cons(sc, sc-&gt;value, sc-&gt;NIL)));
03687 
03688      <span class="keywordflow">case</span> OP_RDQQUOTEVEC:
03689        s_return(sc,cons(sc, mk_symbol(sc,<span class="stringliteral">"apply"</span>),
03690                      cons(sc, mk_symbol(sc,<span class="stringliteral">"vector"</span>), 
03691                           cons(sc,cons(sc, sc-&gt;QQUOTE, 
03692                               cons(sc,sc-&gt;value,sc-&gt;NIL)),
03693                               sc-&gt;NIL))));
03694 
03695      <span class="keywordflow">case</span> OP_RDUNQUOTE:
03696           s_return(sc,cons(sc, sc-&gt;UNQUOTE, cons(sc, sc-&gt;value, sc-&gt;NIL)));
03697 
03698      <span class="keywordflow">case</span> OP_RDUQTSP:
03699           s_return(sc,cons(sc, sc-&gt;UNQUOTESP, cons(sc, sc-&gt;value, sc-&gt;NIL)));
03700 
03701      <span class="keywordflow">case</span> OP_RDVEC:
03702           <span class="comment">/*sc-&gt;code=cons(sc,mk_proc(sc,OP_VECTOR),sc-&gt;value);</span>
03703 <span class="comment">          s_goto(sc,OP_EVAL); Cannot be quoted*/</span>
03704        <span class="comment">/*x=cons(sc,mk_proc(sc,OP_VECTOR),sc-&gt;value);</span>
03705 <span class="comment">        s_return(sc,x); Cannot be part of pairs*/</span>
03706        <span class="comment">/*sc-&gt;code=mk_proc(sc,OP_VECTOR);</span>
03707 <span class="comment">       sc-&gt;args=sc-&gt;value;</span>
03708 <span class="comment">       s_goto(sc,OP_APPLY);*/</span>
03709        sc-&gt;args=sc-&gt;value;
03710        s_goto(sc,OP_VECTOR);
03711 
03712      <span class="comment">/* ========== printing part ========== */</span>
03713      <span class="keywordflow">case</span> OP_P0LIST:
03714           <span class="keywordflow">if</span>(is_vector(sc-&gt;args)) {
03715                putstr(sc,<span class="stringliteral">"#("</span>);
03716                sc-&gt;args=cons(sc,sc-&gt;args,mk_integer(sc,0));
03717                s_goto(sc,OP_PVECFROM);
03718           } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(is_environment(sc-&gt;args)) {
03719                putstr(sc,<span class="stringliteral">"#&lt;ENVIRONMENT&gt;"</span>);
03720                s_return(sc,sc-&gt;T);
03721           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!is_pair(sc-&gt;args)) {
03722                printatom(sc, sc-&gt;args, sc-&gt;print_flag);
03723                s_return(sc,sc-&gt;T);
03724           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (car(sc-&gt;args) == sc-&gt;QUOTE &amp;&amp; ok_abbrev(cdr(sc-&gt;args))) {
03725                putstr(sc, <span class="stringliteral">"'"</span>);
03726                sc-&gt;args = cadr(sc-&gt;args);
03727                s_goto(sc,OP_P0LIST);
03728           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (car(sc-&gt;args) == sc-&gt;QQUOTE &amp;&amp; ok_abbrev(cdr(sc-&gt;args))) {
03729                putstr(sc, <span class="stringliteral">"`"</span>);
03730                sc-&gt;args = cadr(sc-&gt;args);
03731                s_goto(sc,OP_P0LIST);
03732           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (car(sc-&gt;args) == sc-&gt;UNQUOTE &amp;&amp; ok_abbrev(cdr(sc-&gt;args))) {
03733                putstr(sc, <span class="stringliteral">","</span>);
03734                sc-&gt;args = cadr(sc-&gt;args);
03735                s_goto(sc,OP_P0LIST);
03736           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (car(sc-&gt;args) == sc-&gt;UNQUOTESP &amp;&amp; ok_abbrev(cdr(sc-&gt;args))) {
03737                putstr(sc, <span class="stringliteral">",@"</span>);
03738                sc-&gt;args = cadr(sc-&gt;args);
03739                s_goto(sc,OP_P0LIST);
03740           } <span class="keywordflow">else</span> {
03741                putstr(sc, <span class="stringliteral">"("</span>);
03742                s_save(sc,OP_P1LIST, cdr(sc-&gt;args), sc-&gt;NIL);
03743                sc-&gt;args = car(sc-&gt;args);
03744                s_goto(sc,OP_P0LIST);
03745           }
03746 
03747      <span class="keywordflow">case</span> OP_P1LIST:
03748           <span class="keywordflow">if</span> (is_pair(sc-&gt;args)) {
03749            s_save(sc,OP_P1LIST, cdr(sc-&gt;args), sc-&gt;NIL);
03750            putstr(sc, <span class="stringliteral">" "</span>);
03751            sc-&gt;args = car(sc-&gt;args);
03752            s_goto(sc,OP_P0LIST);
03753          } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(is_vector(sc-&gt;args)) {
03754            s_save(sc,OP_P1LIST,sc-&gt;NIL,sc-&gt;NIL);
03755            putstr(sc, <span class="stringliteral">" . "</span>);
03756            s_goto(sc,OP_P0LIST);
03757           } <span class="keywordflow">else</span> {
03758            <span class="keywordflow">if</span> (sc-&gt;args != sc-&gt;NIL) {
03759              putstr(sc, <span class="stringliteral">" . "</span>);
03760              printatom(sc, sc-&gt;args, sc-&gt;print_flag);
03761            }
03762            putstr(sc, <span class="stringliteral">")"</span>);
03763            s_return(sc,sc-&gt;T);
03764           }
03765      <span class="keywordflow">case</span> OP_PVECFROM: {
03766           <span class="keywordtype">int</span> i=ivalue_unchecked(cdr(sc-&gt;args));
03767           pointer vec=car(sc-&gt;args);
03768           <span class="keywordtype">int</span> len=ivalue_unchecked(vec);
03769           <span class="keywordflow">if</span>(i==len) {
03770                putstr(sc,<span class="stringliteral">")"</span>);
03771                s_return(sc,sc-&gt;T);
03772           } <span class="keywordflow">else</span> {
03773                pointer elem=vector_elem(vec,i);
03774                ivalue_unchecked(cdr(sc-&gt;args))=i+1;
03775                s_save(sc,OP_PVECFROM, sc-&gt;args, sc-&gt;NIL);
03776                sc-&gt;args=elem;
03777                putstr(sc,<span class="stringliteral">" "</span>);
03778                s_goto(sc,OP_P0LIST);
03779           }
03780      }
03781 
03782      <span class="keywordflow">default</span>:
03783           sprintf(sc-&gt;strbuff, <span class="stringliteral">"%d: illegal operator"</span>, sc-&gt;op);
03784           Error_0(sc,sc-&gt;strbuff);
03785 
03786      }
03787      <span class="keywordflow">return</span> sc-&gt;T;
03788 }
03789 
03790 <span class="keyword">static</span> pointer opexe_6(scheme *sc, <span class="keyword">enum</span> scheme_opcodes op) {
03791      pointer x, y;
03792      <span class="keywordtype">long</span> v;
03793 
03794      <span class="keywordflow">switch</span> (op) {
03795      <span class="keywordflow">case</span> OP_LIST_LENGTH:     <span class="comment">/* length */</span>   <span class="comment">/* a.k */</span>
03796           v=list_length(sc,car(sc-&gt;args));
03797           <span class="keywordflow">if</span>(v&lt;0) {
03798                Error_1(sc,<span class="stringliteral">"length: not a list:"</span>,car(sc-&gt;args));
03799           }
03800           s_return(sc,mk_integer(sc, v));
03801 
03802      <span class="keywordflow">case</span> OP_ASSQ:       <span class="comment">/* assq */</span>     <span class="comment">/* a.k */</span>
03803           x = car(sc-&gt;args);
03804           <span class="keywordflow">for</span> (y = cadr(sc-&gt;args); is_pair(y); y = cdr(y)) {
03805                <span class="keywordflow">if</span> (!is_pair(car(y))) {
03806                     Error_0(sc,<span class="stringliteral">"unable to handle non pair element"</span>);
03807                }
03808                <span class="keywordflow">if</span> (x == caar(y))
03809                     <span class="keywordflow">break</span>;
03810           }
03811           <span class="keywordflow">if</span> (is_pair(y)) {
03812                s_return(sc,car(y));
03813           } <span class="keywordflow">else</span> {
03814                s_return(sc,sc-&gt;F);
03815           }
03816           
03817           
03818      <span class="keywordflow">case</span> OP_GET_CLOSURE:     <span class="comment">/* get-closure-code */</span>   <span class="comment">/* a.k */</span>
03819           sc-&gt;args = car(sc-&gt;args);
03820           <span class="keywordflow">if</span> (sc-&gt;args == sc-&gt;NIL) {
03821                s_return(sc,sc-&gt;F);
03822           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_closure(sc-&gt;args)) {
03823                s_return(sc,cons(sc, sc-&gt;LAMBDA, closure_code(sc-&gt;value)));
03824           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_macro(sc-&gt;args)) {
03825                s_return(sc,cons(sc, sc-&gt;LAMBDA, closure_code(sc-&gt;value)));
03826           } <span class="keywordflow">else</span> {
03827                s_return(sc,sc-&gt;F);
03828           }
03829      <span class="keywordflow">case</span> OP_CLOSUREP:        <span class="comment">/* closure? */</span>
03830           <span class="comment">/*</span>
03831 <span class="comment">           * Note, macro object is also a closure.</span>
03832 <span class="comment">           * Therefore, (closure? &lt;#MACRO&gt;) ==&gt; #t</span>
03833 <span class="comment">           */</span>
03834           s_retbool(is_closure(car(sc-&gt;args)));
03835      <span class="keywordflow">case</span> OP_MACROP:          <span class="comment">/* macro? */</span>
03836           s_retbool(is_macro(car(sc-&gt;args)));
03837      <span class="keywordflow">default</span>:
03838           sprintf(sc-&gt;strbuff, <span class="stringliteral">"%d: illegal operator"</span>, sc-&gt;op);
03839           Error_0(sc,sc-&gt;strbuff);
03840      }
03841      <span class="keywordflow">return</span> sc-&gt;T; <span class="comment">/* NOTREACHED */</span>
03842 }
03843 
03844 <span class="keyword">typedef</span> pointer (*dispatch_func)(scheme *, <span class="keyword">enum</span> scheme_opcodes);
03845 
03846 <span class="keyword">typedef</span> int (*test_predicate)(pointer);
03847 <span class="keyword">static</span> <span class="keywordtype">int</span> is_any(pointer p) { <span class="keywordflow">return</span> 1;}
03848 <span class="keyword">static</span> <span class="keywordtype">int</span> is_num_integer(pointer p) { 
03849   <span class="keywordflow">return</span> is_number(p) &amp;&amp; ((p)-&gt;_object._number.is_fixnum); 
03850 }
03851 <span class="keyword">static</span> <span class="keywordtype">int</span> is_nonneg(pointer p) {
03852   <span class="keywordflow">return</span> is_num_integer(p) &amp;&amp; ivalue(p)&gt;=0;
03853 }
03854 
03855 <span class="comment">/* Correspond carefully with following defines! */</span>
03856 <span class="keyword">static</span> <span class="keyword">struct </span>{
03857   test_predicate fct;
03858   <span class="keyword">const</span> <span class="keywordtype">char</span> *kind;
03859 } tests[]={
03860   {0,0}, <span class="comment">/* unused */</span>
03861   {is_any, 0},
03862   {is_string, <span class="stringliteral">"string"</span>},
03863   {is_symbol, <span class="stringliteral">"symbol"</span>},
03864   {is_port, <span class="stringliteral">"port"</span>},
03865   {0,<span class="stringliteral">"input port"</span>},
03866   {0,<span class="stringliteral">"output_port"</span>},
03867   {is_environment, <span class="stringliteral">"environment"</span>},
03868   {is_pair, <span class="stringliteral">"pair"</span>},
03869   {0, <span class="stringliteral">"pair or '()"</span>},
03870   {is_character, <span class="stringliteral">"character"</span>},
03871   {is_vector, <span class="stringliteral">"vector"</span>},
03872   {is_number, <span class="stringliteral">"number"</span>},
03873   {is_num_integer, <span class="stringliteral">"integer"</span>},
03874   {is_nonneg, <span class="stringliteral">"non-negative integer"</span>}
03875 };
03876 
03877 <span class="preprocessor">#define TST_NONE 0</span>
03878 <span class="preprocessor"></span><span class="preprocessor">#define TST_ANY "\001"</span>
03879 <span class="preprocessor"></span><span class="preprocessor">#define TST_STRING "\002"</span>
03880 <span class="preprocessor"></span><span class="preprocessor">#define TST_SYMBOL "\003"</span>
03881 <span class="preprocessor"></span><span class="preprocessor">#define TST_PORT "\004"</span>
03882 <span class="preprocessor"></span><span class="preprocessor">#define TST_INPORT "\005"</span>
03883 <span class="preprocessor"></span><span class="preprocessor">#define TST_OUTPORT "\006"</span>
03884 <span class="preprocessor"></span><span class="preprocessor">#define TST_ENVIRONMENT "\007"</span>
03885 <span class="preprocessor"></span><span class="preprocessor">#define TST_PAIR "\010"</span>
03886 <span class="preprocessor"></span><span class="preprocessor">#define TST_LIST "\011"</span>
03887 <span class="preprocessor"></span><span class="preprocessor">#define TST_CHAR "\012"</span>
03888 <span class="preprocessor"></span><span class="preprocessor">#define TST_VECTOR "\013"</span>
03889 <span class="preprocessor"></span><span class="preprocessor">#define TST_NUMBER "\014"</span>
03890 <span class="preprocessor"></span><span class="preprocessor">#define TST_INTEGER "\015"</span>
03891 <span class="preprocessor"></span><span class="preprocessor">#define TST_NATURAL "\016"</span>
03892 <span class="preprocessor"></span>
03893 <span class="keyword">typedef</span> <span class="keyword">struct </span>{
03894   dispatch_func func;
03895   <span class="keywordtype">char</span> *name;
03896   <span class="keywordtype">int</span> min_arity;
03897   <span class="keywordtype">int</span> max_arity;
03898   <span class="keywordtype">char</span> *arg_tests_encoding;
03899 } op_code_info;
03900 
03901 <span class="preprocessor">#define INF_ARG 0xffff</span>
03902 <span class="preprocessor"></span>
03903 <span class="keyword">static</span> op_code_info dispatch_table[]= { 
03904 <span class="preprocessor">#define _OP_DEF(A,B,C,D,E,OP) {A,B,C,D,E}, </span>
03905 <span class="preprocessor"></span><span class="preprocessor">#include "opdefines.h"</span> 
03906   { 0 } 
03907 }; 
03908 
03909 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *procname(pointer x) {
03910  <span class="keywordtype">int</span> n=procnum(x);
03911  <span class="keyword">const</span> <span class="keywordtype">char</span> *name=dispatch_table[n].name;
03912  <span class="keywordflow">if</span>(name==0) {
03913      name=<span class="stringliteral">"ILLEGAL!"</span>;
03914  }
03915  <span class="keywordflow">return</span> name;
03916 }
03917 
03918 <span class="comment">/* kernel of this interpreter */</span>
03919 <span class="keyword">static</span> <span class="keywordtype">void</span> Eval_Cycle(scheme *sc, <span class="keyword">enum</span> scheme_opcodes op) {
03920   <span class="keywordtype">int</span> count=0;
03921   <span class="keywordtype">int</span> old_op;
03922   
03923   sc-&gt;op = op;
03924   <span class="keywordflow">for</span> (;;) {
03925     op_code_info *pcd=dispatch_table+sc-&gt;op;
03926     <span class="keywordflow">if</span> (pcd-&gt;name!=0) { <span class="comment">/* if built-in function, check arguments */</span>
03927       <span class="keywordtype">char</span> msg[512];
03928       <span class="keywordtype">int</span> ok=1;
03929       <span class="keywordtype">int</span> n=list_length(sc,sc-&gt;args);
03930       
03931       <span class="comment">/* Check number of arguments */</span>
03932       <span class="keywordflow">if</span>(n&lt;pcd-&gt;min_arity) {
03933        ok=0;
03934        sprintf(msg,<span class="stringliteral">"%s: needs%s %d argument(s)"</span>,
03935               pcd-&gt;name,
03936               pcd-&gt;min_arity==pcd-&gt;max_arity?<span class="stringliteral">""</span>:<span class="stringliteral">" at least"</span>,
03937               pcd-&gt;min_arity);
03938       }
03939       <span class="keywordflow">if</span>(ok &amp;&amp; n&gt;pcd-&gt;max_arity) {
03940        ok=0;
03941        sprintf(msg,<span class="stringliteral">"%s: needs%s %d argument(s)"</span>,
03942               pcd-&gt;name,
03943               pcd-&gt;min_arity==pcd-&gt;max_arity?<span class="stringliteral">""</span>:<span class="stringliteral">" at most"</span>,
03944               pcd-&gt;max_arity);
03945       }
03946       <span class="keywordflow">if</span>(ok) {
03947        <span class="keywordflow">if</span>(pcd-&gt;arg_tests_encoding!=0) {
03948          <span class="keywordtype">int</span> i=0;
03949          <span class="keywordtype">int</span> j;
03950          <span class="keyword">const</span> <span class="keywordtype">char</span> *t=pcd-&gt;arg_tests_encoding;
03951          pointer arglist=sc-&gt;args;
03952          <span class="keywordflow">do</span> {
03953            pointer arg=car(arglist);
03954            j=(int)t[0];
03955            <span class="keywordflow">if</span>(j==TST_INPORT[0]) {
03956              <span class="keywordflow">if</span>(!is_inport(arg)) <span class="keywordflow">break</span>;
03957            } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(j==TST_OUTPORT[0]) {
03958              <span class="keywordflow">if</span>(!is_outport(arg)) <span class="keywordflow">break</span>;
03959             } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(j==TST_LIST[0]) {
03960               <span class="keywordflow">if</span>(arg!=sc-&gt;NIL &amp;&amp; !is_pair(arg)) <span class="keywordflow">break</span>;        
03961            } <span class="keywordflow">else</span> {
03962              <span class="keywordflow">if</span>(!tests[j].fct(arg)) <span class="keywordflow">break</span>;
03963            }
03964 
03965            <span class="keywordflow">if</span>(t[1]!=0) {<span class="comment">/* last test is replicated as necessary */</span>
03966              t++;
03967            }
03968            arglist=cdr(arglist);
03969            i++;
03970          } <span class="keywordflow">while</span>(i&lt;n);
03971          <span class="keywordflow">if</span>(i&lt;n) {
03972            ok=0;
03973            sprintf(msg,<span class="stringliteral">"%s: argument %d must be: %s"</span>,
03974                   pcd-&gt;name,
03975                   i+1,
03976                   tests[j].kind);
03977          }
03978        }
03979       }
03980       <span class="keywordflow">if</span>(!ok) {
03981        <span class="keywordflow">if</span>(_Error_1(sc,msg,0)==sc-&gt;NIL) {
03982          <span class="keywordflow">return</span>;
03983        }
03984        pcd=dispatch_table+sc-&gt;op;
03985       }
03986     }
03987     old_op=sc-&gt;op;
03988     <span class="keywordflow">if</span> (pcd-&gt;func(sc, sc-&gt;op) == sc-&gt;NIL) {
03989       <span class="keywordflow">return</span>;
03990     }
03991     <span class="keywordflow">if</span>(sc-&gt;no_memory) {
03992       fprintf(stderr,<span class="stringliteral">"No memory!\n"</span>);
03993       <span class="keywordflow">return</span>;
03994     }
03995     count++;
03996   }
03997 }
03998 
03999 <span class="comment">/* ========== Initialization of internal keywords ========== */</span>
04000 
04001 <span class="keyword">static</span> <span class="keywordtype">void</span> assign_syntax(scheme *sc, <span class="keywordtype">char</span> *name) {
04002      pointer x;
04003 
04004      x = oblist_add_by_name(sc, name); 
04005      typeflag(x) |= T_SYNTAX; 
04006 }
04007 
04008 <span class="keyword">static</span> <span class="keywordtype">void</span> assign_proc(scheme *sc, <span class="keyword">enum</span> scheme_opcodes op, <span class="keywordtype">char</span> *name) {
04009      pointer x, y;
04010 
04011      x = mk_symbol(sc, name);
04012      y = mk_proc(sc,op);
04013      new_slot_in_env(sc, x, y); 
04014 }
04015 
04016 <span class="keyword">static</span> pointer mk_proc(scheme *sc, <span class="keyword">enum</span> scheme_opcodes op) {
04017      pointer y;
04018 
04019      y = get_cell(sc, sc-&gt;NIL, sc-&gt;NIL);
04020      typeflag(y) = (T_PROC | T_ATOM);
04021      ivalue_unchecked(y) = (long) op;
04022      set_integer(y);
04023      <span class="keywordflow">return</span> y;
04024 }
04025 
04026 <span class="comment">/* Hard-coded for the given keywords. Remember to rewrite if more are added! */</span>
04027 <span class="keyword">static</span> <span class="keywordtype">int</span> syntaxnum(pointer p) {
04028      <span class="keyword">const</span> <span class="keywordtype">char</span> *s=strvalue(car(p));
04029      <span class="keywordflow">switch</span>(strlength(car(p))) {
04030      <span class="keywordflow">case</span> 2:
04031           <span class="keywordflow">if</span>(s[0]==<span class="charliteral">'i'</span>) <span class="keywordflow">return</span> OP_IF0;        <span class="comment">/* if */</span>
04032           <span class="keywordflow">else</span> <span class="keywordflow">return</span> OP_OR0;                 <span class="comment">/* or */</span> 
04033      <span class="keywordflow">case</span> 3:
04034           <span class="keywordflow">if</span>(s[0]==<span class="charliteral">'a'</span>) <span class="keywordflow">return</span> OP_AND0;      <span class="comment">/* and */</span>
04035           <span class="keywordflow">else</span> <span class="keywordflow">return</span> OP_LET0;               <span class="comment">/* let */</span>
04036      <span class="keywordflow">case</span> 4:
04037           <span class="keywordflow">switch</span>(s[3]) {
04038           <span class="keywordflow">case</span> <span class="charliteral">'e'</span>: <span class="keywordflow">return</span> OP_CASE0;         <span class="comment">/* case */</span>
04039           <span class="keywordflow">case</span> <span class="charliteral">'d'</span>: <span class="keywordflow">return</span> OP_COND0;         <span class="comment">/* cond */</span>
04040           <span class="keywordflow">case</span> <span class="charliteral">'*'</span>: <span class="keywordflow">return</span> OP_LET0AST;       <span class="comment">/* let* */</span>
04041           <span class="keywordflow">default</span>: <span class="keywordflow">return</span> OP_SET0;           <span class="comment">/* set! */</span>          
04042           }
04043      <span class="keywordflow">case</span> 5:
04044           <span class="keywordflow">switch</span>(s[2]) {
04045           <span class="keywordflow">case</span> <span class="charliteral">'g'</span>: <span class="keywordflow">return</span> OP_BEGIN;         <span class="comment">/* begin */</span>
04046           <span class="keywordflow">case</span> <span class="charliteral">'l'</span>: <span class="keywordflow">return</span> OP_DELAY;         <span class="comment">/* delay */</span>
04047           <span class="keywordflow">case</span> <span class="charliteral">'c'</span>: <span class="keywordflow">return</span> OP_MACRO0;        <span class="comment">/* macro */</span>
04048           <span class="keywordflow">default</span>: <span class="keywordflow">return</span> OP_QUOTE;          <span class="comment">/* quote */</span>
04049           }
04050      <span class="keywordflow">case</span> 6:
04051           <span class="keywordflow">switch</span>(s[2]) {
04052           <span class="keywordflow">case</span> <span class="charliteral">'m'</span>: <span class="keywordflow">return</span> OP_LAMBDA;        <span class="comment">/* lambda */</span>
04053           <span class="keywordflow">case</span> <span class="charliteral">'f'</span>: <span class="keywordflow">return</span> OP_DEF0;          <span class="comment">/* define */</span>
04054           <span class="keywordflow">default</span>: <span class="keywordflow">return</span> OP_LET0REC;        <span class="comment">/* letrec */</span>
04055           }
04056      <span class="keywordflow">default</span>:
04057           <span class="keywordflow">return</span> OP_C0STREAM;                <span class="comment">/* cons-stream */</span>
04058      }
04059 }
04060 
04061 <span class="comment">/* initialization of TinyScheme */</span>
04062 <span class="preprocessor">#if USE_INTERFACE</span>
04063 <span class="preprocessor"></span>INTERFACE <span class="keyword">static</span> pointer s_cons(scheme *sc, pointer a, pointer b) {
04064  <span class="keywordflow">return</span> cons(sc,a,b);
04065 }
04066 INTERFACE <span class="keyword">static</span> pointer s_immutable_cons(scheme *sc, pointer a, pointer b) {
04067  <span class="keywordflow">return</span> immutable_cons(sc,a,b);
04068 }
04069 
04070 <span class="keyword">static</span> <span class="keyword">struct </span>scheme_interface vtbl ={
04071   scheme_define,
04072   s_cons,
04073   s_immutable_cons,
04074   mk_integer,
04075   mk_real,
04076   mk_symbol,
04077   gensym,
04078   mk_string,
04079   mk_counted_string,
04080   mk_character,
04081   mk_vector,
04082   mk_foreign_func,
04083   putstr,
04084   putcharacter,
04085 
04086   is_string,
04087   string_value,
04088   is_number,
04089   nvalue,
04090   ivalue,
04091   rvalue,
04092   is_integer,
04093   is_real,
04094   is_character,
04095   charvalue,
04096   is_vector,
04097   ivalue,
04098   fill_vector,
04099   vector_elem,
04100   set_vector_elem,
04101   is_port,
04102   is_pair,
04103   pair_car,
04104   pair_cdr,
04105   set_car,
04106   set_cdr,
04107 
04108   is_symbol,
04109   symname,
04110 
04111   is_syntax,
04112   is_proc,
04113   is_foreign,
04114   syntaxname,
04115   is_closure,
04116   is_macro,
04117   closure_code,
04118   closure_env,
04119 
04120   is_continuation,
04121   is_promise,
04122   is_environment,
04123   is_immutable,
04124   setimmutable,
04125 
04126   scheme_load_file,
04127   scheme_load_string
04128 };
04129 <span class="preprocessor">#endif</span>
04130 <span class="preprocessor"></span>
04131 scheme *scheme_init_new() {
04132   scheme *sc=(scheme*)malloc(<span class="keyword">sizeof</span>(scheme));
04133   <span class="keywordflow">if</span>(!scheme_init(sc)) {
04134     free(sc);
04135     <span class="keywordflow">return</span> 0;
04136   } <span class="keywordflow">else</span> {
04137     <span class="keywordflow">return</span> sc;
04138   }
04139 }
04140 
04141 scheme *scheme_init_new_custom_alloc(func_alloc malloc, func_dealloc free) {
04142   scheme *sc=(scheme*)malloc(<span class="keyword">sizeof</span>(scheme));
04143   <span class="keywordflow">if</span>(!scheme_init_custom_alloc(sc,malloc,free)) {
04144     free(sc);
04145     <span class="keywordflow">return</span> 0;
04146   } <span class="keywordflow">else</span> {
04147     <span class="keywordflow">return</span> sc;
04148   }
04149 }
04150 
04151 
04152 <span class="keywordtype">int</span> scheme_init(scheme *sc) {
04153  <span class="keywordflow">return</span> scheme_init_custom_alloc(sc,malloc,free);
04154 }
04155 
04156 <span class="keywordtype">int</span> scheme_init_custom_alloc(scheme *sc, func_alloc malloc, func_dealloc free) {
04157   <span class="keywordtype">int</span> i, n=<span class="keyword">sizeof</span>(dispatch_table)/<span class="keyword">sizeof</span>(dispatch_table[0]);
04158   pointer x;
04159 
04160   num_zero.is_fixnum=1;
04161   num_zero.value.ivalue=0;
04162   num_one.is_fixnum=1;
04163   num_one.value.ivalue=1;
04164 
04165 <span class="preprocessor">#if USE_INTERFACE</span>
04166 <span class="preprocessor"></span>  sc-&gt;vptr=&amp;vtbl;
04167 <span class="preprocessor">#endif</span>
04168 <span class="preprocessor"></span>  sc-&gt;gensym_cnt=0;
04169   sc-&gt;malloc=malloc;
04170   sc-&gt;free=free;
04171   sc-&gt;last_cell_seg = -1;
04172   sc-&gt;sink = &amp;sc-&gt;_sink;
04173   sc-&gt;NIL = &amp;sc-&gt;_NIL;
04174   sc-&gt;T = &amp;sc-&gt;_HASHT;
04175   sc-&gt;F = &amp;sc-&gt;_HASHF;
04176   sc-&gt;EOF_OBJ=&amp;sc-&gt;_EOF_OBJ;
04177   sc-&gt;free_cell = &amp;sc-&gt;_NIL;
04178   sc-&gt;fcells = 0;
04179   sc-&gt;no_memory=0;
04180   sc-&gt;inport=sc-&gt;NIL;
04181   sc-&gt;outport=sc-&gt;NIL;
04182   sc-&gt;save_inport=sc-&gt;NIL;
04183   sc-&gt;loadport=sc-&gt;NIL;
04184   sc-&gt;nesting=0;
04185   sc-&gt;interactive_repl=0;
04186   
04187   <span class="keywordflow">if</span> (alloc_cellseg(sc,FIRST_CELLSEGS) != FIRST_CELLSEGS) {
04188     sc-&gt;no_memory=1;
04189     <span class="keywordflow">return</span> 0;
04190   }
04191   sc-&gt;gc_verbose = 0;
04192   dump_stack_initialize(sc); 
04193   sc-&gt;code = sc-&gt;NIL;
04194   sc-&gt;tracing=0;
04195   
04196   <span class="comment">/* init sc-&gt;NIL */</span>
04197   typeflag(sc-&gt;NIL) = (T_ATOM | MARK);
04198   car(sc-&gt;NIL) = cdr(sc-&gt;NIL) = sc-&gt;NIL;
04199   <span class="comment">/* init T */</span>
04200   typeflag(sc-&gt;T) = (T_ATOM | MARK);
04201   car(sc-&gt;T) = cdr(sc-&gt;T) = sc-&gt;T;
04202   <span class="comment">/* init F */</span>
04203   typeflag(sc-&gt;F) = (T_ATOM | MARK);
04204   car(sc-&gt;F) = cdr(sc-&gt;F) = sc-&gt;F;
04205   sc-&gt;oblist = oblist_initial_value(sc); 
04206   <span class="comment">/* init global_env */</span>
04207   new_frame_in_env(sc, sc-&gt;NIL); 
04208   sc-&gt;global_env = sc-&gt;envir; 
04209   <span class="comment">/* init else */</span>
04210   x = mk_symbol(sc,<span class="stringliteral">"else"</span>);
04211   new_slot_in_env(sc, x, sc-&gt;T); 
04212 
04213   assign_syntax(sc, <span class="stringliteral">"lambda"</span>);
04214   assign_syntax(sc, <span class="stringliteral">"quote"</span>);
04215   assign_syntax(sc, <span class="stringliteral">"define"</span>);
04216   assign_syntax(sc, <span class="stringliteral">"if"</span>);
04217   assign_syntax(sc, <span class="stringliteral">"begin"</span>);
04218   assign_syntax(sc, <span class="stringliteral">"set!"</span>);
04219   assign_syntax(sc, <span class="stringliteral">"let"</span>);
04220   assign_syntax(sc, <span class="stringliteral">"let*"</span>);
04221   assign_syntax(sc, <span class="stringliteral">"letrec"</span>);
04222   assign_syntax(sc, <span class="stringliteral">"cond"</span>);
04223   assign_syntax(sc, <span class="stringliteral">"delay"</span>);
04224   assign_syntax(sc, <span class="stringliteral">"and"</span>);
04225   assign_syntax(sc, <span class="stringliteral">"or"</span>);
04226   assign_syntax(sc, <span class="stringliteral">"cons-stream"</span>);
04227   assign_syntax(sc, <span class="stringliteral">"macro"</span>);
04228   assign_syntax(sc, <span class="stringliteral">"case"</span>);
04229   
04230   <span class="keywordflow">for</span>(i=0; i&lt;n; i++) {
04231     <span class="keywordflow">if</span>(dispatch_table[i].name!=0) {
04232       assign_proc(sc, i, dispatch_table[i].name);
04233     }
04234   }
04235 
04236   <span class="comment">/* initialization of global pointers to special symbols */</span>
04237   sc-&gt;LAMBDA = mk_symbol(sc, <span class="stringliteral">"lambda"</span>);
04238   sc-&gt;QUOTE = mk_symbol(sc, <span class="stringliteral">"quote"</span>);
04239   sc-&gt;QQUOTE = mk_symbol(sc, <span class="stringliteral">"quasiquote"</span>);
04240   sc-&gt;UNQUOTE = mk_symbol(sc, <span class="stringliteral">"unquote"</span>);
04241   sc-&gt;UNQUOTESP = mk_symbol(sc, <span class="stringliteral">"unquote-splicing"</span>);
04242   sc-&gt;FEED_TO = mk_symbol(sc, <span class="stringliteral">"=&gt;"</span>);
04243   sc-&gt;COLON_HOOK = mk_symbol(sc,<span class="stringliteral">"*colon-hook*"</span>);
04244   sc-&gt;ERROR_HOOK = mk_symbol(sc, <span class="stringliteral">"*error-hook*"</span>);
04245   sc-&gt;SHARP_HOOK = mk_symbol(sc, <span class="stringliteral">"*sharp-hook*"</span>);
04246 
04247   <span class="keywordflow">return</span> !sc-&gt;no_memory;
04248 }
04249 
04250 <span class="keywordtype">void</span> scheme_set_input_port_file(scheme *sc, FILE *fin) {
04251   sc-&gt;inport=port_from_file(sc,fin,port_input);
04252 }
04253 
04254 <span class="keywordtype">void</span> scheme_set_input_port_string(scheme *sc, <span class="keywordtype">char</span> *start, <span class="keywordtype">char</span> *past_the_end) {
04255   sc-&gt;inport=port_from_string(sc,start,past_the_end,port_input);
04256 }
04257 
04258 <span class="keywordtype">void</span> scheme_set_output_port_file(scheme *sc, FILE *fout) {
04259   sc-&gt;outport=port_from_file(sc,fout,port_output);
04260 }
04261 
04262 <span class="keywordtype">void</span> scheme_set_output_port_string(scheme *sc, <span class="keywordtype">char</span> *start, <span class="keywordtype">char</span> *past_the_end) {
04263   sc-&gt;outport=port_from_string(sc,start,past_the_end,port_output);
04264 }
04265 
04266 <span class="keywordtype">void</span> scheme_set_external_data(scheme *sc, <span class="keywordtype">void</span> *p) {
04267  sc-&gt;ext_data=p;
04268 }
04269 
04270 <span class="keywordtype">void</span> scheme_deinit(scheme *sc) {
04271   <span class="keywordtype">int</span> i;
04272 
04273   sc-&gt;oblist=sc-&gt;NIL;
04274   sc-&gt;global_env=sc-&gt;NIL;
04275   dump_stack_free(sc); 
04276   sc-&gt;envir=sc-&gt;NIL;
04277   sc-&gt;code=sc-&gt;NIL;
04278   sc-&gt;args=sc-&gt;NIL;
04279   sc-&gt;value=sc-&gt;NIL;
04280   <span class="keywordflow">if</span>(is_port(sc-&gt;inport)) {
04281     typeflag(sc-&gt;inport) = T_ATOM;
04282   }
04283   sc-&gt;inport=sc-&gt;NIL;
04284   sc-&gt;outport=sc-&gt;NIL;
04285   <span class="keywordflow">if</span>(is_port(sc-&gt;save_inport)) {
04286     typeflag(sc-&gt;save_inport) = T_ATOM;
04287   }
04288   sc-&gt;save_inport=sc-&gt;NIL;
04289   <span class="keywordflow">if</span>(is_port(sc-&gt;loadport)) {
04290     typeflag(sc-&gt;loadport) = T_ATOM;
04291   }
04292   sc-&gt;loadport=sc-&gt;NIL;
04293   sc-&gt;gc_verbose=0;
04294   gc(sc,sc-&gt;NIL,sc-&gt;NIL);
04295 
04296   <span class="keywordflow">for</span>(i=0; i&lt;=sc-&gt;last_cell_seg; i++) {
04297     sc-&gt;free(sc-&gt;alloc_seg[i]);
04298   }
04299 }
04300 
04301 <span class="keywordtype">void</span> scheme_load_file(scheme *sc, FILE *fin) {
04302   dump_stack_reset(sc); 
04303   sc-&gt;envir = sc-&gt;global_env;
04304   sc-&gt;file_i=0;
04305   sc-&gt;load_stack[0].kind=port_input|port_file;
04306   sc-&gt;load_stack[0].rep.stdio.file=fin;
04307   sc-&gt;loadport=mk_port(sc,sc-&gt;load_stack);
04308   sc-&gt;retcode=0;
04309   <span class="keywordflow">if</span>(fin==stdin) {
04310     sc-&gt;interactive_repl=1;
04311   }
04312   sc-&gt;inport=sc-&gt;loadport;
04313   Eval_Cycle(sc, OP_T0LVL);
04314   typeflag(sc-&gt;loadport)=T_ATOM;
04315   <span class="keywordflow">if</span>(sc-&gt;retcode==0) {
04316     sc-&gt;retcode=sc-&gt;nesting!=0;
04317   }
04318 }
04319 
04320 <span class="keywordtype">void</span> scheme_load_string(scheme *sc, <span class="keyword">const</span> <span class="keywordtype">char</span> *cmd) {
04321   dump_stack_reset(sc); 
04322   sc-&gt;envir = sc-&gt;global_env;
04323   sc-&gt;file_i=0;
04324   sc-&gt;load_stack[0].kind=port_input|port_string;
04325   sc-&gt;load_stack[0].rep.string.start=(<span class="keywordtype">char</span>*)cmd; <span class="comment">/* This func respects const */</span>
04326   sc-&gt;load_stack[0].rep.string.past_the_end=(<span class="keywordtype">char</span>*)cmd+strlen(cmd);
04327   sc-&gt;load_stack[0].rep.string.curr=(<span class="keywordtype">char</span>*)cmd;
04328   sc-&gt;loadport=mk_port(sc,sc-&gt;load_stack);
04329   sc-&gt;retcode=0;
04330   sc-&gt;interactive_repl=0;
04331   sc-&gt;inport=sc-&gt;loadport;
04332   Eval_Cycle(sc, OP_T0LVL);
04333   typeflag(sc-&gt;loadport)=T_ATOM;
04334   <span class="keywordflow">if</span>(sc-&gt;retcode==0) {
04335     sc-&gt;retcode=sc-&gt;nesting!=0;
04336   }
04337 }
04338 
04339 <span class="keywordtype">void</span> scheme_define(scheme *sc, pointer envir, pointer symbol, pointer value) {
04340      pointer x;
04341 
04342      x=find_slot_in_env(sc,envir,symbol,0);
04343      <span class="keywordflow">if</span> (x != sc-&gt;NIL) { 
04344           set_slot_in_env(sc, x, value); 
04345      } <span class="keywordflow">else</span> { 
04346           new_slot_spec_in_env(sc, envir, symbol, value); 
04347      } 
04348 }
04349 
04350 <span class="preprocessor">#if !STANDALONE</span>
04351 <span class="preprocessor"></span><span class="keywordtype">void</span> scheme_apply0(scheme *sc, <span class="keyword">const</span> <span class="keywordtype">char</span> *procname) {
04352      pointer carx=mk_symbol(sc,procname);
04353      pointer cdrx=sc-&gt;NIL;
04354 
04355      dump_stack_reset(sc); 
04356      sc-&gt;envir = sc-&gt;global_env;
04357      sc-&gt;code = cons(sc,carx,cdrx);
04358      sc-&gt;interactive_repl=0;
04359      sc-&gt;retcode=0;
04360      Eval_Cycle(sc,OP_EVAL);
04361      }
04362 
04363 <span class="keywordtype">void</span> scheme_call(scheme *sc, pointer func, pointer args) { 
04364    dump_stack_reset(sc); 
04365    sc-&gt;envir = sc-&gt;global_env; 
04366    sc-&gt;args = args; 
04367    sc-&gt;code = func; 
04368    sc-&gt;interactive_repl =0; 
04369    sc-&gt;retcode = 0; 
04370    Eval_Cycle(sc, OP_APPLY); 
04371 } 
04372 <span class="preprocessor">#endif</span>
04373 <span class="preprocessor"></span>
04374 <span class="comment">/* ========== Main ========== */</span>
04375 
04376 <span class="preprocessor">#if STANDALONE</span>
04377 <span class="preprocessor"></span>
04378 <span class="preprocessor">#ifdef macintosh</span>
04379 <span class="preprocessor"></span><span class="keywordtype">int</span> main()
04380 {
04381      <span class="keyword">extern</span> MacTS_main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv);
04382      <span class="keywordtype">char</span>**    argv;
04383      <span class="keywordtype">int</span> argc = ccommand(&amp;argv);
04384      MacTS_main(argc,argv);
04385      <span class="keywordflow">return</span> 0;
04386 }
04387 <span class="keywordtype">int</span> MacTS_main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {
04388 <span class="preprocessor">#else</span>
04389 <span class="preprocessor"></span><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {
04390 <span class="preprocessor">#endif</span>
04391 <span class="preprocessor"></span>  scheme sc;
04392   FILE *fin = 0;
04393   <span class="keywordtype">char</span> *file_name=InitFile;
04394   <span class="keywordtype">int</span> retcode;
04395   <span class="keywordtype">int</span> isfile=1;
04396   
04397   <span class="keywordflow">if</span>(argc==1) {
04398     printf(banner);
04399   }
04400   <span class="keywordflow">if</span>(argc==2 &amp;&amp; strcmp(argv[1],<span class="stringliteral">"-?"</span>)==0) {
04401     printf(<span class="stringliteral">"Usage: %s [-? | &lt;file1&gt; &lt;file2&gt; ... | -1 &lt;file&gt; &lt;arg1&gt; &lt;arg2&gt; ...]\n\tUse - as filename for stdin.\n"</span>,argv[0]);
04402     <span class="keywordflow">return</span> 1;
04403   }
04404   <span class="keywordflow">if</span>(!scheme_init(&amp;sc)) {
04405     fprintf(stderr,<span class="stringliteral">"Could not initialize!\n"</span>);
04406     <span class="keywordflow">return</span> 2;
04407   }
04408   scheme_set_input_port_file(&amp;sc, stdin);
04409   scheme_set_output_port_file(&amp;sc, stdout);
04410 <span class="preprocessor">#if USE_DL</span>
04411 <span class="preprocessor"></span>  scheme_define(&amp;sc,sc.global_env,mk_symbol(&amp;sc,<span class="stringliteral">"load-extension"</span>),mk_foreign_func(&amp;sc, scm_load_ext));
04412 <span class="preprocessor">#endif</span>
04413 <span class="preprocessor"></span>  argv++;
04414   <span class="keywordflow">if</span>(access(file_name,0)!=0) {
04415     <span class="keywordtype">char</span> *p=getenv(<span class="stringliteral">"TINYSCHEMEINIT"</span>);
04416     <span class="keywordflow">if</span>(p!=0) {
04417       file_name=p;
04418     }
04419   }
04420   <span class="keywordflow">do</span> {
04421     <span class="keywordflow">if</span>(strcmp(file_name,<span class="stringliteral">"-"</span>)==0) {
04422       fin=stdin;
04423     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strcmp(file_name,<span class="stringliteral">"-1"</span>)==0 || strcmp(file_name,<span class="stringliteral">"-c"</span>)==0) {
04424       pointer args=sc.NIL;
04425       isfile=file_name[1]==<span class="charliteral">'1'</span>;
04426       file_name=*argv++;
04427       <span class="keywordflow">if</span>(strcmp(file_name,<span class="stringliteral">"-"</span>)==0) {
04428        fin=stdin;
04429       } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(isfile) {
04430        fin=fopen(file_name,<span class="stringliteral">"r"</span>);
04431       }
04432       <span class="keywordflow">for</span>(;*argv;argv++) {
04433        pointer value=mk_string(&amp;sc,*argv);
04434        args=cons(&amp;sc,value,args);
04435       }
04436       args=reverse_in_place(&amp;sc,sc.NIL,args);
04437       scheme_define(&amp;sc,sc.global_env,mk_symbol(&amp;sc,<span class="stringliteral">"*args*"</span>),args);
04438 
04439     } <span class="keywordflow">else</span> {
04440       fin=fopen(file_name,<span class="stringliteral">"r"</span>);
04441     }
04442     <span class="keywordflow">if</span>(isfile &amp;&amp; fin==0) {
04443       fprintf(stderr,<span class="stringliteral">"Could not open file %s\n"</span>,file_name);
04444     } <span class="keywordflow">else</span> {
04445       <span class="keywordflow">if</span>(isfile) {
04446        scheme_load_file(&amp;sc,fin);
04447       } <span class="keywordflow">else</span> {
04448        scheme_load_string(&amp;sc,file_name);
04449       }
04450       <span class="keywordflow">if</span>(!isfile || fin!=stdin) {
04451        <span class="keywordflow">if</span>(sc.retcode!=0) {
04452          fprintf(stderr,<span class="stringliteral">"Errors encountered reading %s\n"</span>,file_name);
04453        }
04454        <span class="keywordflow">if</span>(isfile) {
04455          fclose(fin);
04456        }
04457       }
04458     }
04459     file_name=*argv++;
04460   } <span class="keywordflow">while</span>(file_name!=0);
04461   <span class="keywordflow">if</span>(argc==1) {
04462     scheme_load_file(&amp;sc,stdin);
04463   }
04464   retcode=sc.retcode;
04465   scheme_deinit(&amp;sc);
04466   
04467   <span class="keywordflow">return</span> retcode;
04468 }
04469 
04470 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Oct 13 16:09:21 2004 for gerbv by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.8-20040928 </small></address>
</body>
</html>
