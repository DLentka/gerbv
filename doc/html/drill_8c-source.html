<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gerbv: src/drill.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8-20040928 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a></div>
<h1>drill.c</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * gEDA - GNU Electronic Design Automation</span>
00003 <span class="comment"> * drill.c</span>
00004 <span class="comment"> * Copyright (C) 2000-2003 Andreas Andersson</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> * $Id$</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
00009 <span class="comment"> * it under the terms of the GNU General Public License as published by</span>
00010 <span class="comment"> * the Free Software Foundation; either version 2 of the License, or</span>
00011 <span class="comment"> * (at your option) any later version.</span>
00012 <span class="comment"> *</span>
00013 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
00014 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00015 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00016 <span class="comment"> * GNU General Public License for more details.</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
00019 <span class="comment"> * along with this program; if not, write to the Free Software</span>
00020 <span class="comment"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA</span>
00021 <span class="comment"> */</span>
00022 
00023 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00024 <span class="preprocessor"></span><span class="preprocessor">#include &lt;config.h&gt;</span>
00025 <span class="preprocessor">#endif</span>
00026 <span class="preprocessor"></span>
00027 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00028 
00029 <span class="preprocessor">#ifdef HAVE_STRING_H</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#include &lt;string.h&gt;</span>
00031 <span class="preprocessor">#endif</span>
00032 <span class="preprocessor"></span>
00033 <span class="preprocessor">#include &lt;math.h&gt;</span>  <span class="comment">/* pow() */</span>
00034 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00035 
00036 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00037 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
00038 
00039 <span class="preprocessor">#ifdef HAVE_UNISTD_H</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#include &lt;unistd.h&gt;</span>
00041 <span class="preprocessor">#endif</span>
00042 <span class="preprocessor"></span>
00043 
00044 <span class="preprocessor">#include "drill.h"</span>
00045 <span class="preprocessor">#include "gerb_error.h"</span>
00046 <span class="preprocessor">#include "tooltable.h"</span>
00047 
00048 <span class="preprocessor">#define NOT_IMPL(fd, s) do { \</span>
00049 <span class="preprocessor">                             GERB_MESSAGE("Not Implemented:%s\n", s); \</span>
00050 <span class="preprocessor">                           } while(0)</span>
00051 <span class="preprocessor"></span>
00052 <span class="comment">/* I couldn't possibly code without these */</span>
00053 <span class="preprocessor">#undef TRUE</span>
00054 <span class="preprocessor"></span><span class="preprocessor">#define TRUE 1</span>
00055 <span class="preprocessor"></span><span class="preprocessor">#undef FALSE</span>
00056 <span class="preprocessor"></span><span class="preprocessor">#define FALSE 0</span>
00057 <span class="preprocessor"></span>
00058 <span class="preprocessor">#undef max</span>
00059 <span class="preprocessor"></span><span class="preprocessor">#define max(a,b) ((a) &gt; (b) ? (a) : (b))</span>
00060 <span class="preprocessor"></span><span class="preprocessor">#undef min</span>
00061 <span class="preprocessor"></span><span class="preprocessor">#define min(a,b) ((a) &lt; (b) ? (a) : (b))</span>
00062 <span class="preprocessor"></span>
00063 <span class="keyword">enum</span> drill_file_section_t {DRILL_NONE, DRILL_HEADER, DRILL_DATA};
00064 <span class="keyword">enum</span> drill_coordinate_mode_t {DRILL_MODE_ABSOLUTE, DRILL_MODE_INCREMENTAL};
00065 
00066 <span class="keyword">enum</span> drill_m_code_t {DRILL_M_UNKNOWN, DRILL_M_NOT_IMPLEMENTED,
00067                    DRILL_M_END, DRILL_M_ENDREWIND,
00068                    DRILL_M_MESSAGE, DRILL_M_LONGMESSAGE,
00069                    DRILL_M_HEADER, DRILL_M_ENDHEADER,
00070                    DRILL_M_METRIC, DRILL_M_IMPERIAL,
00071                    DRILL_M_BEGINPATTERN, DRILL_M_ENDPATTERN,
00072                    DRILL_M_CANNEDTEXT, DRILL_M_TIPCHECK};
00073 
00074 <span class="keyword">enum</span> drill_g_code_t {DRILL_G_ABSOLUTE, DRILL_G_INCREMENTAL,
00075                    DRILL_G_ZEROSET, DRILL_G_UNKNOWN,
00076                    DRILL_G_ROUT, DRILL_G_DRILL,
00077                    DRILL_G_LINEARMOVE, DRILL_G_CWMOVE, DRILL_G_CCWMOVE};
00078 
00079 <span class="keyword">typedef</span> <span class="keyword">struct </span>drill_state {
00080     <span class="keywordtype">double</span> curr_x;
00081     <span class="keywordtype">double</span> curr_y;
00082     <span class="keywordtype">int</span> current_tool;
00083     <span class="keywordtype">int</span> curr_section;
00084     <span class="keywordtype">int</span> coordinate_mode;
00085     <span class="keywordtype">double</span> origin_x;
00086     <span class="keywordtype">double</span> origin_y;
00087     <span class="keyword">enum</span> unit_t unit;
00088 } drill_state_t;
00089 
00090 <span class="comment">/* Local function prototypes */</span>
00091 <span class="keyword">static</span> <span class="keyword">enum</span> unit_t drill_guess_format(gerb_file_t *fd, gerb_image_t *image);
00092 <span class="keyword">static</span> <span class="keywordtype">int</span> drill_parse_G_code(gerb_file_t *fd, gerb_image_t *image);
00093 <span class="keyword">static</span> <span class="keywordtype">int</span> drill_parse_M_code(gerb_file_t *fd, gerb_image_t *image);
00094 <span class="keyword">static</span> <span class="keywordtype">int</span> drill_parse_T_code(gerb_file_t *fd, drill_state_t *state, gerb_image_t *image);
00095 <span class="keyword">static</span> <span class="keywordtype">void</span> drill_parse_coordinate(gerb_file_t *fd, <span class="keywordtype">char</span> firstchar, <span class="keywordtype">double</span> scale_factor, drill_state_t *state);
00096 <span class="keyword">static</span> drill_state_t *new_state(drill_state_t *state);
00097 <span class="keyword">static</span> <span class="keywordtype">double</span> read_double(gerb_file_t *fd, <span class="keywordtype">double</span> scale_factor);
00098 <span class="keyword">static</span> <span class="keywordtype">void</span> eat_line(gerb_file_t *fd);
00099 
00100 gerb_image_t *
00101 parse_drillfile(gerb_file_t *fd)
00102 {
00103     drill_state_t *state = NULL;
00104     gerb_image_t *image = NULL;
00105     gerb_net_t *curr_net = NULL;
00106     <span class="keywordtype">int</span> read;
00107     <span class="keywordtype">double</span> x_scale = 1, y_scale = 1;
00108 
00109     state = new_state(state);
00110     <span class="keywordflow">if</span> (state == NULL)
00111        GERB_FATAL_ERROR(<span class="stringliteral">"malloc state failed\n"</span>);
00112 
00113     image = new_gerb_image(image);
00114     <span class="keywordflow">if</span> (image == NULL)
00115        GERB_FATAL_ERROR(<span class="stringliteral">"malloc image failed\n"</span>);
00116     curr_net = image-&gt;netlist;
00117 
00118     state-&gt;unit = drill_guess_format(fd, image);
00119 
00120     <span class="keywordflow">if</span> (image &amp;&amp; image-&gt;format ){
00121        x_scale = pow(10.0, (<span class="keywordtype">double</span>)image-&gt;format-&gt;x_dec);
00122        y_scale = pow(10.0, (<span class="keywordtype">double</span>)image-&gt;format-&gt;y_dec);
00123     }
00124 
00125     <span class="keywordflow">while</span> ((read = gerb_fgetc(fd)) != EOF) {
00126 
00127        <span class="keywordflow">switch</span> ((char)read) {
00128        <span class="keywordflow">case</span> <span class="charliteral">';'</span> :
00129            <span class="comment">/* Comment found. Eat rest of line */</span>
00130            eat_line(fd);
00131            <span class="keywordflow">break</span>;
00132        <span class="keywordflow">case</span> <span class="charliteral">'F'</span> :
00133            <span class="comment">/* Z axis feed speed. Silently ignored */</span>
00134            eat_line(fd);
00135            <span class="keywordflow">break</span>;
00136        <span class="keywordflow">case</span> <span class="charliteral">'G'</span>:
00137            <span class="comment">/* Most G codes aren't used, for now */</span>
00138            <span class="keywordflow">switch</span>(drill_parse_G_code(fd, image)) {
00139            <span class="keywordflow">case</span> DRILL_G_ROUT :
00140               GERB_COMPILE_ERROR(<span class="stringliteral">"Rout mode data is not supported\n"</span>);
00141               <span class="keywordflow">break</span>;
00142            <span class="keywordflow">case</span> DRILL_G_DRILL :
00143               <span class="keywordflow">break</span>;
00144            <span class="keywordflow">case</span> DRILL_G_ABSOLUTE :
00145               state-&gt;coordinate_mode = DRILL_MODE_ABSOLUTE;
00146               <span class="keywordflow">break</span>;
00147            <span class="keywordflow">case</span> DRILL_G_INCREMENTAL :
00148               state-&gt;coordinate_mode = DRILL_MODE_INCREMENTAL;
00149               <span class="keywordflow">break</span>;
00150            <span class="keywordflow">case</span> DRILL_G_ZEROSET :
00151               <span class="keywordflow">if</span>((read = gerb_fgetc(fd)) == EOF)
00152                   GERB_COMPILE_ERROR(<span class="stringliteral">"Unexpected EOF\n"</span>);
00153               drill_parse_coordinate(fd, (<span class="keywordtype">char</span>)read, 1.0 / x_scale, state);
00154               state-&gt;origin_x = state-&gt;curr_x;
00155               state-&gt;origin_y = state-&gt;curr_y;
00156               <span class="keywordflow">break</span>;
00157            <span class="keywordflow">default</span> :
00158               eat_line(fd);
00159               <span class="keywordflow">break</span>;
00160            }
00161            <span class="keywordflow">break</span>;
00162        <span class="keywordflow">case</span> <span class="charliteral">'M'</span>:
00163            <span class="keywordflow">switch</span>(drill_parse_M_code(fd, image)) {
00164            <span class="keywordflow">case</span> DRILL_M_HEADER :
00165               state-&gt;curr_section = DRILL_HEADER;
00166               <span class="keywordflow">break</span>;
00167            <span class="keywordflow">case</span> DRILL_M_ENDHEADER :
00168               state-&gt;curr_section = DRILL_DATA;
00169               <span class="keywordflow">break</span>;
00170            <span class="keywordflow">case</span> DRILL_M_METRIC :
00171               <span class="comment">/* This is taken care of elsewhere */</span>
00172               <span class="keywordflow">break</span>;
00173            <span class="keywordflow">case</span> DRILL_M_IMPERIAL :
00174               <span class="comment">/* This is taken care of elsewhere */</span>
00175               <span class="keywordflow">break</span>;
00176            <span class="keywordflow">case</span> DRILL_M_LONGMESSAGE :
00177            <span class="keywordflow">case</span> DRILL_M_MESSAGE :
00178               <span class="comment">/* Until we have a console, these are ignored */</span>
00179            <span class="keywordflow">case</span> DRILL_M_CANNEDTEXT :
00180               <span class="comment">/* Ignored, probably permanently */</span>
00181               eat_line(fd);
00182               <span class="keywordflow">break</span>;
00183            <span class="keywordflow">case</span> DRILL_M_NOT_IMPLEMENTED :
00184            <span class="keywordflow">case</span> DRILL_M_ENDPATTERN :
00185            <span class="keywordflow">case</span> DRILL_M_TIPCHECK :
00186               <span class="keywordflow">break</span>;
00187            <span class="keywordflow">case</span> DRILL_M_END :
00188               <span class="comment">/* M00 has optional arguments */</span>
00189               eat_line(fd);
00190            <span class="keywordflow">case</span> DRILL_M_ENDREWIND :
00191               free(state);
00192               <span class="keywordflow">return</span> image;
00193               <span class="keywordflow">break</span>;
00194            <span class="keywordflow">default</span>:
00195               GERB_COMPILE_ERROR(<span class="stringliteral">"Strange M code found.\n"</span>);
00196            }
00197            <span class="keywordflow">break</span>;
00198 
00199        <span class="keywordflow">case</span> <span class="charliteral">'S'</span>:
00200            <span class="comment">/* Spindle speed. Silently ignored */</span>
00201            eat_line(fd);
00202            <span class="keywordflow">break</span>;
00203        <span class="keywordflow">case</span> <span class="charliteral">'T'</span>:
00204            drill_parse_T_code(fd, state, image);
00205            <span class="keywordflow">break</span>;
00206        <span class="keywordflow">case</span> <span class="charliteral">'X'</span>:
00207        <span class="keywordflow">case</span> <span class="charliteral">'Y'</span>:
00208            <span class="comment">/* Hole coordinate found. Do some parsing */</span>
00209            drill_parse_coordinate(fd, read, 1.0 / x_scale, state);
00210 
00211            curr_net-&gt;next = (gerb_net_t *)malloc(<span class="keyword">sizeof</span>(gerb_net_t));
00212            curr_net = curr_net-&gt;next;
00213            memset((<span class="keywordtype">void</span> *)curr_net, 0, <span class="keyword">sizeof</span>(gerb_net_t));
00214 
00215            curr_net-&gt;start_x = (double)state-&gt;curr_x;
00216            curr_net-&gt;start_y = (double)state-&gt;curr_y;
00217            <span class="comment">/* KLUDGE. This function isn't allowed to return anything</span>
00218 <span class="comment">              but inches */</span>
00219            <span class="keywordflow">if</span>(state-&gt;unit == MM) {
00220               (double)curr_net-&gt;start_x /= 25.4;
00221               (double)curr_net-&gt;start_y /= 25.4;
00222               <span class="comment">/* KLUDGE. All images, regardless of input format,</span>
00223 <span class="comment">                 are returned in INCH format */</span>
00224               curr_net-&gt;unit = INCH;
00225            }
00226 
00227            curr_net-&gt;stop_x = curr_net-&gt;start_x - state-&gt;origin_x;
00228            curr_net-&gt;stop_y = curr_net-&gt;start_y - state-&gt;origin_y;
00229            curr_net-&gt;aperture = state-&gt;current_tool;
00230            curr_net-&gt;aperture_state = FLASH;
00231 
00232            <span class="comment">/* Find min and max of image.</span>
00233 <span class="comment">              Mustn't forget (again) to add the hole radius */</span>
00234            image-&gt;info-&gt;min_x =
00235               min(image-&gt;info-&gt;min_x,
00236                   (curr_net-&gt;start_x -
00237                    image-&gt;aperture[state-&gt;current_tool]-&gt;parameter[0] / 2));
00238            image-&gt;info-&gt;min_y =
00239               min(image-&gt;info-&gt;min_y,
00240                   (curr_net-&gt;start_y -
00241                    image-&gt;aperture[state-&gt;current_tool]-&gt;parameter[0] / 2));
00242            image-&gt;info-&gt;max_x =
00243               max(image-&gt;info-&gt;max_x,
00244                   (curr_net-&gt;start_x +
00245                    image-&gt;aperture[state-&gt;current_tool]-&gt;parameter[0] / 2));
00246            image-&gt;info-&gt;max_y =
00247               max(image-&gt;info-&gt;max_y,
00248                   (curr_net-&gt;start_y +
00249                    image-&gt;aperture[state-&gt;current_tool]-&gt;parameter[0] / 2));
00250            <span class="keywordflow">break</span>;
00251        <span class="keywordflow">case</span> <span class="charliteral">'%'</span>:
00252            state-&gt;curr_section = DRILL_DATA;
00253            <span class="keywordflow">break</span>;
00254        <span class="keywordflow">case</span> 10 :   <span class="comment">/* White space */</span>
00255        <span class="keywordflow">case</span> 13 :
00256        <span class="keywordflow">case</span> <span class="charliteral">' '</span> :
00257        <span class="keywordflow">case</span> <span class="charliteral">'\t'</span> :
00258            <span class="keywordflow">break</span>;
00259        <span class="keywordflow">default</span>:
00260            <span class="keywordflow">if</span>(state-&gt;curr_section == DRILL_HEADER) {
00261               <span class="comment">/* Unrecognised crap in the header is thrown away */</span>
00262               eat_line(fd);
00263            } <span class="keywordflow">else</span> {
00264               GERB_COMPILE_ERROR(
00265                      <span class="stringliteral">"Warning: Found ill fitting character '%c' [0x%02x] inside data, ignoring\n"</span>,
00266                      read, read);
00267            }
00268        }
00269     }
00270 
00271     GERB_COMPILE_ERROR(<span class="stringliteral">"Warning: File is missing drill End-Of-File\n"</span>);
00272 
00273     <span class="keywordflow">return</span> image;
00274 } <span class="comment">/* parse_drillfile */</span>
00275 
00276 <span class="comment">/* Guess the format of the input file.</span>
00277 <span class="comment">   Rewinds file when done */</span>
00278 <span class="keyword">static</span> <span class="keyword">enum</span> unit_t
00279 drill_guess_format(gerb_file_t *fd, gerb_image_t *image)
00280 {
00281     <span class="keywordtype">int</span> inch_score = 0;
00282     <span class="keywordtype">int</span> metric_score = 0;
00283     <span class="keywordtype">int</span> length, max_length = 0;
00284     <span class="keywordtype">int</span> leading_zeros, max_leading_zeros = 0;
00285     <span class="keywordtype">int</span> trailing_zeros, max_trailing_zeros = 0;
00286     <span class="keywordtype">int</span> read;
00287     drill_state_t *state = NULL;
00288     <span class="keywordtype">int</span> done = FALSE;
00289     <span class="keywordtype">int</span> i;
00290     <span class="keyword">enum</span> unit_t unit;
00291 
00292     state = new_state(state);
00293     <span class="keywordflow">if</span> (state == NULL)
00294        GERB_FATAL_ERROR(<span class="stringliteral">"malloc state failed\n"</span>);
00295 
00296     image-&gt;format = (gerb_format_t *)malloc(<span class="keyword">sizeof</span>(gerb_format_t));
00297     <span class="keywordflow">if</span> (image-&gt;format == NULL) 
00298        GERB_FATAL_ERROR(<span class="stringliteral">"malloc format failed\n"</span>);
00299     memset((<span class="keywordtype">void</span> *)image-&gt;format, 0, <span class="keyword">sizeof</span>(gerb_format_t));
00300 
00301     <span class="comment">/* This is just a special case of the normal parser */</span>
00302     <span class="keywordflow">while</span> ((read = gerb_fgetc(fd)) != EOF &amp;&amp; !done) {
00303        <span class="keywordflow">switch</span> ((char)read) {
00304        <span class="keywordflow">case</span> <span class="charliteral">';'</span> :
00305        <span class="keywordflow">case</span> <span class="charliteral">'F'</span> :
00306        <span class="keywordflow">case</span> <span class="charliteral">'G'</span>:
00307        <span class="keywordflow">case</span> <span class="charliteral">'S'</span>:
00308        <span class="keywordflow">case</span> <span class="charliteral">'T'</span>:
00309            eat_line(fd);
00310            <span class="keywordflow">break</span>;
00311        <span class="keywordflow">case</span> <span class="charliteral">'M'</span>:
00312            <span class="keywordflow">switch</span>(drill_parse_M_code(fd, image)) {
00313            <span class="keywordflow">case</span> DRILL_M_METRIC :
00314               metric_score += 10;
00315               <span class="keywordflow">break</span>;
00316            <span class="keywordflow">case</span> DRILL_M_IMPERIAL :
00317               inch_score += 10;
00318               <span class="keywordflow">break</span>;
00319            <span class="keywordflow">case</span> DRILL_M_END :
00320               done = TRUE;
00321            <span class="keywordflow">default</span>:
00322               <span class="keywordflow">break</span>;
00323            }
00324            <span class="keywordflow">break</span>;
00325 
00326        <span class="keywordflow">case</span> <span class="charliteral">'X'</span>:
00327        <span class="keywordflow">case</span> <span class="charliteral">'Y'</span>:
00328            <span class="comment">/* How many leading zeros? */</span>
00329            length = 0;
00330            leading_zeros = 0;
00331            trailing_zeros = 0;
00332            {
00333               <span class="comment">/* This state machine is a bit ugly, so it'll probably</span>
00334 <span class="comment">                 have to be rewritten sometime */</span>
00335               <span class="keywordtype">int</span> local_state = 0;
00336               <span class="keywordflow">while</span> ((read = gerb_fgetc(fd)) != EOF &amp;&amp;
00337                      (isdigit(read) || read == <span class="charliteral">'+'</span> || read == <span class="charliteral">'-'</span>
00338                      || read == <span class="charliteral">','</span> || read == <span class="charliteral">'.'</span>)) {
00339                   <span class="keywordflow">if</span>(read != <span class="charliteral">'+'</span> &amp;&amp; read != <span class="charliteral">'-'</span> 
00340                      &amp;&amp; read != <span class="charliteral">','</span> &amp;&amp; read != <span class="charliteral">'.'</span>) length ++;
00341                   <span class="keywordflow">switch</span> (local_state) {
00342                   <span class="keywordflow">case</span> 0:
00343                      <span class="keywordflow">if</span>(read == <span class="charliteral">'0'</span>) {
00344                          leading_zeros++;
00345                      } <span class="keywordflow">else</span> {
00346                          local_state++;
00347                      }
00348                      <span class="keywordflow">break</span>;
00349                   <span class="keywordflow">case</span> 1:
00350                      <span class="keywordflow">if</span>(read ==<span class="charliteral">'0'</span>) {
00351                          trailing_zeros++;
00352                      }
00353                   }
00354               }
00355            }
00356            max_length = max(max_length, length);
00357            max_leading_zeros = max(max_leading_zeros, leading_zeros);
00358            max_trailing_zeros = max(max_trailing_zeros, trailing_zeros);
00359            <span class="keywordflow">break</span>;
00360 
00361        <span class="keywordflow">case</span> <span class="charliteral">'%'</span>:
00362            state-&gt;curr_section = DRILL_HEADER;
00363            <span class="keywordflow">break</span>;
00364        <span class="keywordflow">case</span> 10 :   <span class="comment">/* White space */</span>
00365        <span class="keywordflow">case</span> 13 :
00366        <span class="keywordflow">case</span> <span class="charliteral">' '</span> :
00367        <span class="keywordflow">case</span> <span class="charliteral">'\t'</span> :
00368        <span class="keywordflow">default</span>:
00369            <span class="keywordflow">break</span>;
00370        }
00371     }
00372 
00373     <span class="comment">/* Unfortunately, inches seem more common, so that's the default */</span>
00374     <span class="keywordflow">if</span>(metric_score &gt; inch_score) {
00375        unit = MM;
00376     } <span class="keywordflow">else</span> {
00377        unit = INCH;
00378     }
00379 
00380     <span class="comment">/* Knowing about trailing zero suppression is more important,</span>
00381 <span class="comment">       so it takes precedence here. */</span>
00382     <span class="keywordflow">if</span> (max_trailing_zeros == 0) {
00383        <span class="comment">/* No trailing zero anywhere. It's probable they're suppressed */</span>
00384        image-&gt;format-&gt;omit_zeros = TRAILING;
00385     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(max_leading_zeros == 0) {
00386        <span class="comment">/* No leading zero anywhere. It's probable they're suppressed */</span>
00387        image-&gt;format-&gt;omit_zeros = LEADING;
00388     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (max_trailing_zeros &gt;= max_leading_zeros ) {
00389        image-&gt;format-&gt;omit_zeros = TRAILING;
00390     } <span class="keywordflow">else</span> {
00391        image-&gt;format-&gt;omit_zeros = LEADING;
00392     }
00393 
00394     <span class="comment">/* Almost every file seems to use 2.x format (where x is 3-4) */</span>
00395     image-&gt;format-&gt;x_dec = max_length - 2;
00396     image-&gt;format-&gt;y_dec = max_length - 2;
00397 
00398     <span class="comment">/* A bit of a kludge (Or maybe wild ass guess would be more correct.</span>
00399 <span class="comment">       It seems to work, though.) It tries to cover all cases I've</span>
00400 <span class="comment">       found where the format has to be adjusted from the above</span>
00401 <span class="comment">       calculation. */</span>
00402     <span class="keywordflow">if</span>( (image-&gt;format-&gt;omit_zeros == LEADING ||
00403         (max_leading_zeros == 0 &amp;&amp; max_trailing_zeros == 0) ) &amp;&amp;
00404        image-&gt;format-&gt;x_dec &lt;=3 &amp;&amp; unit == INCH) {
00405 
00406        image-&gt;format-&gt;x_dec += 1;
00407        image-&gt;format-&gt;y_dec += 1;
00408     }
00409 
00410     <span class="comment">/* Restore the necessary things back to their default state */</span>
00411     <span class="keywordflow">for</span> (i = 0; i &lt; APERTURE_MAX; i++) {
00412        <span class="keywordflow">if</span> (image-&gt;aperture[i] != NULL) {
00413            free(image-&gt;aperture[i]);
00414            image-&gt;aperture[i] = NULL;
00415        }
00416     }
00417 
00418     free(state);
00419     fd-&gt;ptr = 0;
00420 
00421     <span class="keywordflow">return</span> unit;
00422 }
00423 
00424 
00425 <span class="comment">/*</span>
00426 <span class="comment"> * Checks for signs that this is a drill file</span>
00427 <span class="comment"> * Returns 1 if it is, 0 if not.</span>
00428 <span class="comment"> */</span>
00429 <span class="keywordtype">int</span>
00430 drill_file_p(gerb_file_t *fd)
00431 {
00432     <span class="keywordtype">int</span> read;
00433 
00434     <span class="keywordflow">while</span> ((read = gerb_fgetc(fd)) != EOF) {
00435         <span class="keywordflow">switch</span> ((char)read) {
00436         <span class="keywordflow">case</span> <span class="charliteral">'M'</span>:
00437             <span class="keywordflow">if</span>(gerb_fgetc(fd) == <span class="charliteral">'4'</span>) {
00438               <span class="keywordflow">if</span>(gerb_fgetc(fd) == <span class="charliteral">'8'</span>) {
00439                 <span class="comment">/* Drill file header command found,</span>
00440 <span class="comment">                   this could very well be a drill file */</span>
00441               fd-&gt;ptr = 0;
00442                 <span class="keywordflow">return</span> 1;
00443               }
00444            }
00445            eat_line(fd);
00446             <span class="keywordflow">break</span>;
00447        <span class="keywordflow">case</span> <span class="charliteral">'T'</span>:
00448            <span class="comment">/* Something that looks like a tool definition found.</span>
00449 <span class="comment">              Special case to allow files from Orcad, which sucks. */</span>
00450            fd-&gt;ptr = 0;
00451            <span class="keywordflow">return</span> 1;
00452        <span class="keywordflow">case</span> <span class="charliteral">'X'</span>:
00453        <span class="keywordflow">case</span> <span class="charliteral">'Y'</span>:
00454            <span class="comment">/* First coordinate reached without finding any sign of this</span>
00455 <span class="comment">              being a drill file. Stop parsing and return. */</span>
00456            fd-&gt;ptr = 0;
00457            <span class="keywordflow">return</span> 0;
00458        <span class="keywordflow">case</span> 10 :  <span class="comment">/* Ignore CR/LF */</span>
00459        <span class="keywordflow">case</span> 13 :
00460            <span class="keywordflow">break</span>;
00461         <span class="keywordflow">default</span> : <span class="comment">/* Eat every line that starts with something uninteresting */</span>
00462             eat_line(fd);
00463             <span class="keywordflow">break</span>;
00464         }
00465     }
00466     <span class="comment">/* This is, in all likelyhood, not a drill file */</span>
00467     fd-&gt;ptr = 0;
00468     <span class="keywordflow">return</span> 0;
00469 }
00470 
00471 
00472 <span class="comment">/* Parse tool definition. This can get a bit tricky since it can</span>
00473 <span class="comment">   appear in the header and/or data section.</span>
00474 <span class="comment">   Returns tool number on success, -1 on error */</span>
00475 <span class="keyword">static</span> <span class="keywordtype">int</span>
00476 drill_parse_T_code(gerb_file_t *fd, drill_state_t *state, gerb_image_t *image)
00477 {
00478     <span class="keywordtype">int</span> tool_num;
00479     <span class="keywordtype">int</span> done = FALSE;
00480     <span class="keywordtype">int</span> temp;
00481     <span class="keywordtype">double</span> size;
00482 
00483     <span class="comment">/* Sneak a peek at what's hiding after the 'T'. Ugly fix for</span>
00484 <span class="comment">       broken headers from Orcad, which is crap */</span>
00485     temp = gerb_fgetc(fd);
00486     <span class="keywordflow">if</span>( !(isdigit(temp) != 0 || temp == <span class="charliteral">'+'</span> || temp ==<span class="charliteral">'-'</span>) ) {
00487        <span class="keywordflow">if</span>(temp != EOF) {
00488            GERB_COMPILE_ERROR(
00489                   <span class="stringliteral">"Warning: Junk text found in place of tool definition.\n"</span>
00490                   <span class="stringliteral">"         Please ask your CAD vendor to stop doing that.\n"</span>);
00491            eat_line(fd);
00492        }
00493        <span class="keywordflow">return</span> -1;
00494     }
00495     gerb_ungetc(fd);
00496 
00497     tool_num = gerb_fgetint(fd, NULL);
00498     <span class="keywordflow">if</span> ((tool_num &lt; TOOL_MIN) || (tool_num &gt;= TOOL_MAX)) 
00499        GERB_COMPILE_ERROR(<span class="stringliteral">"Tool out of bounds: %d\n"</span>, tool_num);
00500 
00501     <span class="comment">/* Set the current tool to the correct one */</span>
00502     state-&gt;current_tool = tool_num;
00503 
00504     <span class="comment">/* Check for a size definition */</span>
00505     temp = gerb_fgetc(fd);
00506 
00507     <span class="keywordflow">while</span>(!done) {
00508        
00509        <span class="keywordflow">switch</span>((char)temp) {
00510        <span class="keywordflow">case</span> <span class="charliteral">'C'</span>:
00511 
00512            size = read_double(fd, 1);
00513 
00514            <span class="keywordflow">if</span>(state-&gt;unit == MM) {
00515               size /= 25.4;
00516            } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(size &gt;= 4.0) {
00517               <span class="comment">/* If the drill size is &gt;= 4 inches, assume that this</span>
00518 <span class="comment">                 must be wrong and that the units are mils.</span>
00519 <span class="comment">                 The limit being 4 inches is because the smallest drill</span>
00520 <span class="comment">                 I've ever seen used is 0,3mm(about 12mil). Half of that</span>
00521 <span class="comment">                 seemed a bit too small a margin, so a third it is */</span>
00522               GERB_COMPILE_WARNING(<span class="stringliteral">"Read a tool diameter of %g. "</span>, size);
00523               GERB_COMPILE_WARNING(<span class="stringliteral">"Assuming this is mils and your CAD tool is broken.\n"</span>);
00524               size /= 1000.0;
00525            }
00526 
00527            <span class="keywordflow">if</span>(size &lt;= 0 || size &gt;= 10000) {
00528               GERB_COMPILE_ERROR(<span class="stringliteral">"Tool is wrong size: %g\n"</span>, size);
00529            } <span class="keywordflow">else</span> {
00530               <span class="keywordflow">if</span>(image-&gt;aperture[tool_num] != NULL) {
00531                   GERB_COMPILE_ERROR(<span class="stringliteral">"Tool is already defined\n"</span>);
00532               } <span class="keywordflow">else</span> {
00533                   image-&gt;aperture[tool_num] =
00534                      (gerb_aperture_t *)malloc(<span class="keyword">sizeof</span>(gerb_aperture_t));
00535                   <span class="keywordflow">if</span> (image-&gt;aperture[tool_num] == NULL) {
00536                      GERB_FATAL_ERROR(<span class="stringliteral">"malloc tool failed\n"</span>);
00537                   }
00538                   <span class="comment">/* There's really no way of knowing what unit the tools</span>
00539 <span class="comment">                     are defined in without sneaking a peek in the rest of</span>
00540 <span class="comment">                     the file first. That's done in drill_guess_format() */</span>
00541                   image-&gt;aperture[tool_num]-&gt;parameter[0] = size;
00542                   image-&gt;aperture[tool_num]-&gt;type = CIRCLE;
00543                   image-&gt;aperture[tool_num]-&gt;nuf_parameters = 1;
00544                   image-&gt;aperture[tool_num]-&gt;unit = INCH;
00545               }
00546            }
00547            <span class="keywordflow">break</span>;
00548 
00549        <span class="keywordflow">case</span> <span class="charliteral">'F'</span>:
00550        <span class="keywordflow">case</span> <span class="charliteral">'S'</span> :
00551            <span class="comment">/* Silently ignored. They're not important. */</span>
00552            gerb_fgetint(fd, NULL);
00553            <span class="keywordflow">break</span>;
00554 
00555        <span class="keywordflow">default</span>:
00556            <span class="comment">/* Stop when finding anything but what's expected</span>
00557 <span class="comment">              (and put it back) */</span>
00558            gerb_ungetc(fd);
00559            done = TRUE;
00560            <span class="keywordflow">break</span>;
00561        }
00562        <span class="keywordflow">if</span>( (temp = gerb_fgetc(fd)) == EOF) {
00563            GERB_COMPILE_ERROR(<span class="stringliteral">"(very) Unexpected end of file found\n"</span>);
00564        }
00565     }
00566 
00567     <span class="comment">/* Catch the tools that aren't defined.</span>
00568 <span class="comment">       This isn't strictly a good thing, but at least something is shown */</span>
00569     <span class="keywordflow">if</span>(image-&gt;aperture[tool_num] == NULL) {
00570         <span class="keywordtype">double</span> dia;
00571 
00572        image-&gt;aperture[tool_num] =
00573            (gerb_aperture_t *)malloc(<span class="keyword">sizeof</span>(gerb_aperture_t));
00574        <span class="keywordflow">if</span> (image-&gt;aperture[tool_num] == NULL) {
00575            GERB_FATAL_ERROR(<span class="stringliteral">"malloc tool failed\n"</span>);
00576        }
00577 
00578         <span class="comment">/* See if we have the tool table */</span>
00579         dia = GetToolDiameter_Inches(tool_num);
00580         <span class="keywordflow">if</span> (dia &lt;= 0) {
00581             <span class="comment">/*</span>
00582 <span class="comment">             * There is no tool. So go out and make some.</span>
00583 <span class="comment">             * This size calculation is, of course, totally bogus.</span>
00584 <span class="comment">             */</span>
00585             dia = (double)(16 + 8 * tool_num) / 1000;
00586             <span class="comment">/*</span>
00587 <span class="comment">             * Oooh, this is sooo ugly. But some CAD systems seem to always</span>
00588 <span class="comment">             * use T00 at the end of the file while others that don't have</span>
00589 <span class="comment">             * tool definitions inside the file never seem to use T00 at all.</span>
00590 <span class="comment">             */</span>
00591             <span class="keywordflow">if</span>(tool_num != 0) {
00592                 GERB_COMPILE_ERROR(
00593                   <span class="stringliteral">"Warning: Tool %02d used without being defined\n"</span>,
00594                   tool_num);
00595                 GERB_COMPILE_ERROR(<span class="stringliteral">"Setting a default size of %g\"\n"</span>, dia);
00596             }
00597        }
00598 
00599        image-&gt;aperture[tool_num]-&gt;type = CIRCLE;
00600        image-&gt;aperture[tool_num]-&gt;nuf_parameters = 1;
00601         image-&gt;aperture[tool_num]-&gt;parameter[0] = dia;
00602     }
00603     
00604     <span class="keywordflow">return</span> tool_num;
00605 } <span class="comment">/* drill_parse_T_code */</span>
00606 
00607 
00608 <span class="keyword">static</span> <span class="keywordtype">int</span>
00609 drill_parse_M_code(gerb_file_t *fd, gerb_image_t *image)
00610 {
00611     <span class="keywordtype">char</span> op[3] = <span class="stringliteral">"  "</span>;
00612     <span class="keywordtype">int</span>  read[3];
00613 
00614     read[0] = gerb_fgetc(fd);
00615     read[1] = gerb_fgetc(fd);
00616 
00617     <span class="keywordflow">if</span> ((read[0] == EOF) || (read[1] == EOF))
00618        GERB_COMPILE_WARNING(<span class="stringliteral">"Unexpected EOF found.\n"</span>);
00619 
00620     op[0] = read[0], op[1] = read[1], op[3] = 0;
00621  
00622     <span class="keywordflow">if</span> (strncmp(op, <span class="stringliteral">"00"</span>, 2) == 0) {
00623        <span class="keywordflow">return</span> DRILL_M_END;
00624     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(op, <span class="stringliteral">"01"</span>, 2) == 0) {
00625        <span class="keywordflow">return</span> DRILL_M_ENDPATTERN;
00626     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(op, <span class="stringliteral">"18"</span>, 2) == 0) {
00627        <span class="keywordflow">return</span> DRILL_M_TIPCHECK;
00628     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(op, <span class="stringliteral">"25"</span>, 2) == 0 || strncmp(op, <span class="stringliteral">"31"</span>, 2) == 0) {
00629        <span class="keywordflow">return</span> DRILL_M_BEGINPATTERN;
00630     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(op, <span class="stringliteral">"30"</span>, 2) == 0) {
00631        <span class="keywordflow">return</span> DRILL_M_ENDREWIND;
00632     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(op, <span class="stringliteral">"45"</span>, 2) == 0) {
00633        <span class="keywordflow">return</span> DRILL_M_LONGMESSAGE;
00634     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(op, <span class="stringliteral">"47"</span>, 2) == 0) {
00635        <span class="keywordflow">return</span> DRILL_M_MESSAGE;
00636     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(op, <span class="stringliteral">"48"</span>, 2) == 0) {
00637        <span class="keywordflow">return</span> DRILL_M_HEADER;
00638     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(op, <span class="stringliteral">"71"</span>, 2) == 0) {
00639        eat_line(fd);
00640        <span class="keywordflow">return</span> DRILL_M_METRIC;
00641     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(op, <span class="stringliteral">"72"</span>, 2) == 0) {
00642        eat_line(fd);
00643        <span class="keywordflow">return</span> DRILL_M_IMPERIAL;
00644     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(op, <span class="stringliteral">"95"</span>, 2) == 0) {
00645        <span class="keywordflow">return</span> DRILL_M_ENDHEADER;
00646     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(op, <span class="stringliteral">"97"</span>, 2) == 0 || strncmp(op, <span class="stringliteral">"98"</span>, 2) == 0) {
00647        <span class="keywordflow">return</span> DRILL_M_CANNEDTEXT;
00648     }
00649 
00650     <span class="keywordflow">return</span> DRILL_M_UNKNOWN;
00651 
00652 } <span class="comment">/* drill_parse_M_code */</span>
00653 
00654 <span class="keyword">static</span> <span class="keywordtype">int</span>
00655 drill_parse_G_code(gerb_file_t *fd, gerb_image_t *image)
00656 {
00657     <span class="keywordtype">char</span> op[3] = <span class="stringliteral">"  "</span>;
00658     <span class="keywordtype">int</span>  read[3];
00659 
00660     read[0] = gerb_fgetc(fd);
00661     read[1] = gerb_fgetc(fd);
00662 
00663     <span class="keywordflow">if</span> ((read[0] == EOF) || (read[1] == EOF))
00664        GERB_COMPILE_ERROR(<span class="stringliteral">"Unexpected EOF found.\n"</span>);
00665 
00666     op[0] = read[0], op[1] = read[1], op[3] = 0;
00667 
00668     <span class="keywordflow">if</span> (strncmp(op, <span class="stringliteral">"00"</span>, 2) == 0) {
00669        <span class="keywordflow">return</span> DRILL_G_ROUT;
00670     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(op, <span class="stringliteral">"01"</span>, 2) == 0) {
00671        <span class="keywordflow">return</span> DRILL_G_LINEARMOVE;
00672     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(op, <span class="stringliteral">"02"</span>, 2) == 0) {
00673        <span class="keywordflow">return</span> DRILL_G_CWMOVE;
00674     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(op, <span class="stringliteral">"03"</span>, 2) == 0) {
00675        <span class="keywordflow">return</span> DRILL_G_CCWMOVE;
00676     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(op, <span class="stringliteral">"05"</span>, 2) == 0) {
00677        <span class="keywordflow">return</span> DRILL_G_DRILL;
00678     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(op, <span class="stringliteral">"90"</span>, 2) == 0) {
00679        <span class="keywordflow">return</span> DRILL_G_ABSOLUTE;
00680     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(op, <span class="stringliteral">"91"</span>, 2) == 0) {
00681        <span class="keywordflow">return</span> DRILL_G_INCREMENTAL;
00682     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(op, <span class="stringliteral">"93"</span>, 2) == 0) {
00683        <span class="keywordflow">return</span> DRILL_G_ZEROSET;
00684     }
00685     <span class="keywordflow">return</span> DRILL_G_UNKNOWN;
00686 
00687 } <span class="comment">/* drill_parse_G_code */</span>
00688 
00689 
00690 <span class="comment">/* Parse on drill file coordinate.</span>
00691 <span class="comment">   Returns nothing, but modifies state */</span>
00692 <span class="keyword">static</span> <span class="keywordtype">void</span>
00693 drill_parse_coordinate(gerb_file_t *fd, <span class="keywordtype">char</span> firstchar,
00694                      <span class="keywordtype">double</span> scale_factor, drill_state_t *state)
00695 
00696 {
00697     <span class="keywordtype">char</span> read;
00698 
00699     <span class="keywordflow">if</span>(state-&gt;coordinate_mode == DRILL_MODE_ABSOLUTE) {
00700        <span class="keywordflow">if</span>(firstchar == <span class="charliteral">'X'</span>) {
00701            state-&gt;curr_x = read_double(fd, scale_factor);
00702            <span class="keywordflow">if</span>((read = (char)gerb_fgetc(fd)) == <span class="charliteral">'Y'</span>) {
00703               state-&gt;curr_y = read_double(fd, scale_factor);
00704            }
00705        } <span class="keywordflow">else</span> {
00706            state-&gt;curr_y = read_double(fd, scale_factor);
00707        }
00708     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(state-&gt;coordinate_mode == DRILL_MODE_INCREMENTAL) {
00709        <span class="keywordflow">if</span>(firstchar == <span class="charliteral">'X'</span>) {
00710            state-&gt;curr_x += read_double(fd, scale_factor);
00711            <span class="keywordflow">if</span>((read = (char)gerb_fgetc(fd)) == <span class="charliteral">'Y'</span>) {
00712               state-&gt;curr_y += read_double(fd, scale_factor);
00713            }
00714        } <span class="keywordflow">else</span> {
00715            state-&gt;curr_y += read_double(fd, scale_factor);
00716        }
00717     }
00718 
00719 } <span class="comment">/* drill_parse_coordinate */</span>
00720 
00721 
00722 <span class="comment">/* Allocates and returns a new drill_state structure</span>
00723 <span class="comment">   Returns state pointer on success, NULL on ERROR */</span>
00724 <span class="keyword">static</span> drill_state_t *
00725 new_state(drill_state_t *state)
00726 {
00727     state = (drill_state_t *)malloc(<span class="keyword">sizeof</span>(drill_state_t));
00728     <span class="keywordflow">if</span> (state != NULL) {
00729        <span class="comment">/* Init structure */</span>
00730        memset((<span class="keywordtype">void</span> *)state, 0, <span class="keyword">sizeof</span>(drill_state_t));
00731        state-&gt;curr_section = DRILL_NONE;
00732        state-&gt;coordinate_mode = DRILL_MODE_ABSOLUTE;
00733        state-&gt;origin_x = 0.0;
00734        state-&gt;origin_y = 0.0;
00735     }
00736     <span class="keywordflow">return</span> state;
00737 } <span class="comment">/* new_state */</span>
00738 
00739 
00740 <span class="comment">/* Reads one double from fd and returns it.</span>
00741 <span class="comment">   If a decimal point is found, the scale factor is not used. */</span>
00742 <span class="keyword">static</span> <span class="keywordtype">double</span>
00743 read_double(gerb_file_t *fd, <span class="keywordtype">double</span> scale_factor)
00744 {
00745     <span class="keywordtype">int</span> read;
00746     <span class="keywordtype">char</span> temp[0x20];
00747     <span class="keywordtype">int</span> i = 0;
00748     <span class="keywordtype">double</span> result = 0;
00749     <span class="keywordtype">int</span> decimal_point = FALSE;
00750 
00751     memset(temp, 0, <span class="keyword">sizeof</span>(temp));
00752 
00753     read = gerb_fgetc(fd);
00754     <span class="keywordflow">while</span>(read != EOF &amp;&amp; i &lt; <span class="keyword">sizeof</span>(temp) &amp;&amp;
00755          (isdigit(read) || read == <span class="charliteral">'.'</span> || read == <span class="charliteral">'+'</span> || read == <span class="charliteral">'-'</span>)) {
00756        <span class="keywordflow">if</span>(read == <span class="charliteral">','</span> || read == <span class="charliteral">'.'</span>) decimal_point = TRUE;
00757        temp[i++] = (char)read;
00758        read = gerb_fgetc(fd);
00759     }
00760 
00761     gerb_ungetc(fd);
00762     result = strtod(temp, NULL);
00763     <span class="keywordflow">if</span>(!decimal_point) result *= scale_factor;
00764 
00765     <span class="keywordflow">return</span> result;
00766 } <span class="comment">/* read_double */</span>
00767 
00768 
00769 <span class="comment">/* Eats all characters up to and including </span>
00770 <span class="comment">   the first one of CR or LF */</span>
00771 <span class="keyword">static</span> <span class="keywordtype">void</span>
00772 eat_line(gerb_file_t *fd)
00773 {
00774     <span class="keywordtype">int</span> read = gerb_fgetc(fd);
00775     
00776     <span class="keywordflow">while</span>(read != 10 &amp;&amp; read != 13) {
00777        <span class="keywordflow">if</span> (read == EOF) <span class="keywordflow">return</span>;
00778        read = gerb_fgetc(fd);
00779     }
00780 } <span class="comment">/* eat_line */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Oct 13 16:09:18 2004 for gerbv by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.8-20040928 </small></address>
</body>
</html>
