<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gerbv: src/scheme-private.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8-20040928 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a></div>
<h1>scheme-private.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/* scheme-private.h */</span>
00002 
00003 <span class="preprocessor">#ifndef _SCHEME_PRIVATE_H</span>
00004 <span class="preprocessor"></span><span class="preprocessor">#define _SCHEME_PRIVATE_H</span>
00005 <span class="preprocessor"></span>
00006 <span class="preprocessor">#include "scheme.h"</span>
00007 <span class="comment">/*------------------ Ugly internals -----------------------------------*/</span>
00008 <span class="comment">/*------------------ Of interest only to FFI users --------------------*/</span>
00009 
00010 
00011 <span class="keyword">enum</span> scheme_port_kind { 
00012   port_free=0, 
00013   port_file=1, 
00014   port_string=2, 
00015   port_input=16, 
00016   port_output=32 
00017 };
00018 
00019 <span class="keyword">typedef</span> <span class="keyword">struct </span>port {
00020   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> kind;
00021   <span class="keyword">union </span>{
00022     <span class="keyword">struct </span>{
00023       FILE *file;
00024       <span class="keywordtype">int</span> closeit;
00025     } stdio;
00026     <span class="keyword">struct </span>{
00027       <span class="keywordtype">char</span> *start;
00028       <span class="keywordtype">char</span> *past_the_end;
00029       <span class="keywordtype">char</span> *curr;
00030     } string;
00031   } rep;
00032 } port;
00033 
00034 <span class="comment">/* cell structure */</span>
00035 <span class="keyword">struct </span>cell {
00036   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _flag;
00037   <span class="keyword">union </span>{
00038     <span class="keyword">struct </span>{
00039       <span class="keywordtype">char</span>   *_svalue;
00040       <span class="keywordtype">int</span>   _length;
00041     } _string;
00042     num _number;
00043     port *_port;
00044     foreign_func _ff;
00045     <span class="keyword">struct </span>{
00046       <span class="keyword">struct </span>cell *_car;
00047       <span class="keyword">struct </span>cell *_cdr;
00048     } _cons;
00049   } _object;
00050 };
00051 
00052 <span class="keyword">struct </span>scheme {
00053 <span class="comment">/* arrays for segments */</span>
00054 func_alloc malloc;
00055 func_dealloc free;
00056 
00057 <span class="comment">/* return code */</span>
00058 <span class="keywordtype">int</span> retcode;
00059 <span class="keywordtype">int</span> tracing;
00060 
00061 <span class="preprocessor">#define CELL_SEGSIZE    5000  </span><span class="comment">/* # of cells in one segment */</span>
00062 <span class="preprocessor">#define CELL_NSEGMENT   10    </span><span class="comment">/* # of segments for cells */</span>
00063 <span class="keywordtype">char</span> *alloc_seg[CELL_NSEGMENT];
00064 pointer cell_seg[CELL_NSEGMENT];
00065 <span class="keywordtype">int</span>     last_cell_seg;
00066 
00067 <span class="comment">/* We use 4 registers. */</span>
00068 pointer args;            <span class="comment">/* register for arguments of function */</span>
00069 pointer envir;           <span class="comment">/* stack register for current environment */</span>
00070 pointer code;            <span class="comment">/* register for current code */</span>
00071 pointer dump;            <span class="comment">/* stack register for next evaluation */</span>
00072 
00073 <span class="keywordtype">int</span> interactive_repl;    <span class="comment">/* are we in an interactive REPL? */</span>
00074 
00075 <span class="keyword">struct </span>cell _sink;
00076 pointer sink;            <span class="comment">/* when mem. alloc. fails */</span>
00077 <span class="keyword">struct </span>cell _NIL;
00078 pointer NIL;             <span class="comment">/* special cell representing empty cell */</span>
00079 <span class="keyword">struct </span>cell _HASHT;
00080 pointer T;               <span class="comment">/* special cell representing #t */</span>
00081 <span class="keyword">struct </span>cell _HASHF;
00082 pointer F;               <span class="comment">/* special cell representing #f */</span>
00083 <span class="keyword">struct </span>cell _EOF_OBJ;
00084 pointer EOF_OBJ;         <span class="comment">/* special cell representing end-of-file object */</span>
00085 pointer oblist;          <span class="comment">/* pointer to symbol table */</span>
00086 pointer global_env;      <span class="comment">/* pointer to global environment */</span>
00087 
00088 <span class="comment">/* global pointers to special symbols */</span>
00089 pointer LAMBDA;               <span class="comment">/* pointer to syntax lambda */</span>
00090 pointer QUOTE;           <span class="comment">/* pointer to syntax quote */</span>
00091 
00092 pointer QQUOTE;               <span class="comment">/* pointer to symbol quasiquote */</span>
00093 pointer UNQUOTE;         <span class="comment">/* pointer to symbol unquote */</span>
00094 pointer UNQUOTESP;       <span class="comment">/* pointer to symbol unquote-splicing */</span>
00095 pointer FEED_TO;         <span class="comment">/* =&gt; */</span>
00096 pointer COLON_HOOK;      <span class="comment">/* *colon-hook* */</span>
00097 pointer ERROR_HOOK;      <span class="comment">/* *error-hook* */</span>
00098 pointer SHARP_HOOK;  <span class="comment">/* *sharp-hook* */</span>
00099 
00100 pointer free_cell;       <span class="comment">/* pointer to top of free cells */</span>
00101 <span class="keywordtype">long</span>    fcells;          <span class="comment">/* # of free cells */</span>
00102 
00103 pointer inport;
00104 pointer outport;
00105 pointer save_inport;
00106 pointer loadport;
00107 
00108 <span class="preprocessor">#define MAXFIL 64</span>
00109 <span class="preprocessor"></span>port load_stack[MAXFIL];     <span class="comment">/* Stack of open files for port -1 (LOADing) */</span>
00110 <span class="keywordtype">int</span> nesting_stack[MAXFIL];
00111 <span class="keywordtype">int</span> file_i;
00112 <span class="keywordtype">int</span> nesting;
00113 
00114 <span class="keywordtype">char</span>    gc_verbose;      <span class="comment">/* if gc_verbose is not zero, print gc status */</span>
00115 <span class="keywordtype">char</span>    no_memory;       <span class="comment">/* Whether mem. alloc. has failed */</span>
00116 
00117 <span class="preprocessor">#define LINESIZE 1024</span>
00118 <span class="preprocessor"></span><span class="keywordtype">char</span>    linebuff[LINESIZE];
00119 <span class="keywordtype">char</span>    strbuff[256];
00120 
00121 FILE *tmpfp;
00122 <span class="keywordtype">int</span> tok;
00123 <span class="keywordtype">int</span> print_flag;
00124 pointer value;
00125 <span class="keywordtype">int</span> op;
00126 
00127 <span class="keywordtype">void</span> *ext_data;     <span class="comment">/* For the benefit of foreign functions */</span>
00128 <span class="keywordtype">long</span> gensym_cnt;
00129 
00130 <span class="keyword">struct </span>scheme_interface *vptr;
00131 <span class="keywordtype">void</span> *dump_base;      <span class="comment">/* pointer to base of allocated dump stack */</span>
00132 <span class="keywordtype">int</span> dump_size;               <span class="comment">/* number of frames allocated for dump stack */</span>
00133 };
00134 
00135 <span class="preprocessor">#define cons(sc,a,b) _cons(sc,a,b,0)</span>
00136 <span class="preprocessor"></span><span class="preprocessor">#define immutable_cons(sc,a,b) _cons(sc,a,b,1)</span>
00137 <span class="preprocessor"></span>
00138 <span class="keywordtype">int</span> is_string(pointer p);
00139 <span class="keywordtype">char</span> *string_value(pointer p);
00140 <span class="keywordtype">int</span> is_number(pointer p);
00141 num nvalue(pointer p);
00142 <span class="keywordtype">long</span> ivalue(pointer p);
00143 <span class="keywordtype">double</span> rvalue(pointer p);
00144 <span class="keywordtype">int</span> is_integer(pointer p);
00145 <span class="keywordtype">int</span> is_real(pointer p);
00146 <span class="keywordtype">int</span> is_character(pointer p);
00147 <span class="keywordtype">long</span> charvalue(pointer p);
00148 <span class="keywordtype">int</span> is_vector(pointer p);
00149 
00150 <span class="keywordtype">int</span> is_port(pointer p);
00151 
00152 <span class="keywordtype">int</span> is_pair(pointer p);
00153 pointer pair_car(pointer p);
00154 pointer pair_cdr(pointer p);
00155 pointer set_car(pointer p, pointer q);
00156 pointer set_cdr(pointer p, pointer q);
00157 
00158 <span class="keywordtype">int</span> is_symbol(pointer p);
00159 <span class="keywordtype">char</span> *symname(pointer p);
00160 <span class="keywordtype">int</span> hasprop(pointer p);
00161 
00162 <span class="keywordtype">int</span> is_syntax(pointer p);
00163 <span class="keywordtype">int</span> is_proc(pointer p);
00164 <span class="keywordtype">int</span> is_foreign(pointer p);
00165 <span class="keywordtype">char</span> *syntaxname(pointer p);
00166 <span class="keywordtype">int</span> is_closure(pointer p);
00167 <span class="preprocessor">#ifdef USE_MACRO</span>
00168 <span class="preprocessor"></span><span class="keywordtype">int</span> is_macro(pointer p);
00169 <span class="preprocessor">#endif</span>
00170 <span class="preprocessor"></span>pointer closure_code(pointer p);
00171 pointer closure_env(pointer p);
00172 
00173 <span class="keywordtype">int</span> is_continuation(pointer p);
00174 <span class="keywordtype">int</span> is_promise(pointer p);
00175 <span class="keywordtype">int</span> is_environment(pointer p);
00176 <span class="keywordtype">int</span> is_immutable(pointer p);
00177 <span class="keywordtype">void</span> setimmutable(pointer p);
00178 
00179 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Oct 13 16:09:19 2004 for gerbv by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.8-20040928 </small></address>
</body>
</html>
