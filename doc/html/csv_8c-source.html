<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gerbv: src/csv.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8-20040928 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a></div>
<h1>csv.c</h1><a href="csv_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/* csv - read write comma separated value format</span>
00002 <span class="comment"> * Copyright (c) 2003 Michael B. Allen &lt;mba2000 ioplex.com&gt;</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * The MIT License</span>
00005 <span class="comment"> * </span>
00006 <span class="comment"> * Permission is hereby granted, free of charge, to any person obtaining a</span>
00007 <span class="comment"> * copy of this software and associated documentation files (the "Software"),</span>
00008 <span class="comment"> * to deal in the Software without restriction, including without limitation</span>
00009 <span class="comment"> * the rights to use, copy, modify, merge, publish, distribute, sublicense,</span>
00010 <span class="comment"> * and/or sell copies of the Software, and to permit persons to whom the</span>
00011 <span class="comment"> * Software is furnished to do so, subject to the following conditions:</span>
00012 <span class="comment"> * </span>
00013 <span class="comment"> * The above copyright notice and this permission notice shall be included</span>
00014 <span class="comment"> * in all copies or substantial portions of the Software.</span>
00015 <span class="comment"> * </span>
00016 <span class="comment"> * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
00017 <span class="comment"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
00018 <span class="comment"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL</span>
00019 <span class="comment"> * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR</span>
00020 <span class="comment"> * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,</span>
00021 <span class="comment"> * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR</span>
00022 <span class="comment"> * OTHER DEALINGS IN THE SOFTWARE.</span>
00023 <span class="comment"> */</span>
00024 
00025 <span class="comment">/* We (Juergen Haas and Tomasz Motylewski) execute our rights given above</span>
00026 <span class="comment"> * to distribute and sublicence this file (csv.c) and csv.h, csv_defines.h</span>
00027 <span class="comment"> * under General Pulic Licence version 2 or any later version.</span>
00028 <span class="comment"> *</span>
00029 <span class="comment"> * This file is derived from libmba : A library of generic C modules</span>
00030 <span class="comment"> * http://www.ioplex.com/~miallen/libmba/dl/libmba-0.8.9.tar.gz</span>
00031 <span class="comment"> */</span>
00032 
00038 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#include &lt;config.h&gt;</span>
00040 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_CONFIG_H */</span>
00041 
00042 <span class="preprocessor">#ifdef USE_GTK2</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00044 <span class="preprocessor">#include &lt;string.h&gt;</span>
00045 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00046 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00047 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00048 <span class="preprocessor">#include &lt;wchar.h&gt;</span>
00049 <span class="preprocessor">#include &lt;wctype.h&gt;</span>
00050 <span class="comment">/*#include "msgno.h"*/</span>
00051 <span class="preprocessor">#include "csv.h"</span>
00052 <span class="preprocessor">#include "<a class="code" href="csv__defines_8h.html">csv_defines.h</a>"</span>
00053 <span class="preprocessor">#include "gerb_error.h"</span>
00054 <span class="preprocessor">#define ST_START     1</span>
00055 <span class="preprocessor"></span><span class="preprocessor">#define ST_COLLECT   2</span>
00056 <span class="preprocessor"></span><span class="preprocessor">#define ST_TAILSPACE 3</span>
00057 <span class="preprocessor"></span><span class="preprocessor">#define ST_END_QUOTE 4</span>
00058 <span class="preprocessor"></span><span class="preprocessor">#define istspace iswspace</span>
00059 <span class="preprocessor"></span>
00060 
00061 <span class="keyword">struct </span>sinput {
00062        FILE *in;
00063        <span class="keyword">const</span> <span class="keywordtype">char</span> *src;
00064        size_t sn;
00065        size_t count;
00066 };
00067 
00068 
00069 <span class="keyword">struct </span>winput {
00070        <span class="keyword">const</span> <span class="keywordtype">wchar_t</span> *src;
00071        size_t sn;
00072        size_t count;
00073 };
00074 
00075 
00076 <span class="keyword">static</span> <span class="keywordtype">int</span>
00077 snextch(<span class="keyword">struct</span> sinput *in)
00078 {
00079        <span class="keywordtype">int</span> ch;
00080 
00081        <span class="keywordflow">if</span> (in-&gt;in) {
00082               <span class="keywordflow">if</span> ((ch = fgetc(in-&gt;in)) == EOF) {
00083                      <span class="keywordflow">if</span> (ferror(in-&gt;in)) {
00084                             GERB_MESSAGE(<span class="stringliteral">"errno:%d"</span>, errno);
00085                             <span class="keywordflow">return</span> -1;
00086                      }
00087                      <span class="keywordflow">return</span> 0;
00088               }
00089        } <span class="keywordflow">else</span> {
00090               <span class="keywordflow">if</span> (in-&gt;sn == 0) {
00091                      <span class="keywordflow">return</span> 0;
00092               }
00093               ch = (<span class="keywordtype">unsigned</span> char) *(in-&gt;src)++;
00094               in-&gt;sn--;
00095        }
00096        in-&gt;count++;
00097 
00098        <span class="keywordflow">return</span> ch;
00099 }<span class="comment">/* snextch */</span>
00100 
00101 
00102 <span class="keyword">static</span> <span class="keywordtype">int</span>
00103 wnextch(<span class="keyword">struct</span> winput *in)
00104 {
00105        <span class="keywordtype">int</span> ch;
00106 
00107        <span class="keywordflow">if</span> (in-&gt;sn == 0) {
00108               <span class="keywordflow">return</span> 0;
00109        }
00110        ch = *(in-&gt;src)++;
00111        in-&gt;sn--;
00112        in-&gt;count++;
00113 
00114        <span class="keywordflow">return</span> ch;
00115 }<span class="comment">/* wnextch */</span>
00116 
00117 <span class="keyword">static</span> <span class="keywordtype">int</span>
00118 csv_parse_str(<span class="keyword">struct</span> sinput *in, <span class="keywordtype">char</span> *buf, size_t bn, <span class="keywordtype">char</span> *row[], <span class="keywordtype">int</span> rn, <span class="keywordtype">int</span> sep, <span class="keywordtype">int</span> flags)
00119 {
00120        <span class="keywordtype">int</span> trim, quotes, ch, state, r, j, t, inquotes;
00121 
00122        trim = flags &amp; CSV_TRIM;
00123        quotes = flags &amp; CSV_QUOTES;
00124        state = ST_START;
00125        inquotes = 0;
00126        ch = r = j = t = 0;
00127 
00128        memset(row, 0, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *) * rn);
00129 
00130        <span class="keywordflow">while</span> (rn &amp;&amp; bn &amp;&amp; (ch = snextch(in)) &gt; 0) {
00131               <span class="keywordflow">switch</span> (state) {
00132                      <span class="keywordflow">case</span> ST_START:
00133                             <span class="keywordflow">if</span> (ch != <span class="charliteral">'\n'</span> &amp;&amp; ch != sep &amp;&amp; isspace(ch)) {
00134                                    <span class="keywordflow">if</span> (!trim) {
00135                                           buf[j++] = ch; bn--;
00136                                           t = j;
00137                                    }
00138                                    <span class="keywordflow">break</span>;
00139                             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (quotes &amp;&amp; ch == <span class="charliteral">'"'</span>) {
00140                                    j = t = 0;
00141                                    state = ST_COLLECT;
00142                                    inquotes = 1;
00143                                    <span class="keywordflow">break</span>;
00144                             }
00145                             state = ST_COLLECT;
00146                      <span class="keywordflow">case</span> ST_COLLECT:
00147                             <span class="keywordflow">if</span> (inquotes) {
00148                                    <span class="keywordflow">if</span> (ch == <span class="charliteral">'"'</span>) {
00149                                           state = ST_END_QUOTE;
00150                                           <span class="keywordflow">break</span>;
00151                                    }
00152                             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch == sep || ch == <span class="charliteral">'\n'</span>) {
00153                                    row[r++] = buf; rn--;
00154                                    buf[t] = <span class="charliteral">'\0'</span>; bn--;
00155                                    buf += t + 1;
00156                                    j = t = 0;
00157 
00158                                    state = ST_START;
00159                                    inquotes = 0;
00160                                    <span class="keywordflow">if</span> (ch == <span class="charliteral">'\n'</span>) {
00161                                           rn = 0;
00162                                    }
00163                                    <span class="keywordflow">break</span>;
00164                             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (quotes &amp;&amp; ch == <span class="charliteral">'"'</span>) {
00165                                    errno = EILSEQ;
00166                                    GERB_MESSAGE(<span class="stringliteral">"%d: unexpected quote in element"</span>,errno);
00167                                    <span class="keywordflow">return</span> -1;
00168                             }
00169                             buf[j++] = ch; bn--;
00170                             <span class="keywordflow">if</span> (!trim || isspace(ch) == 0) {
00171                                    t = j;
00172                             }
00173                             <span class="keywordflow">break</span>;
00174                      <span class="keywordflow">case</span> ST_TAILSPACE:
00175                      <span class="keywordflow">case</span> ST_END_QUOTE:
00176                             <span class="keywordflow">if</span> (ch == sep || ch == <span class="charliteral">'\n'</span>) {
00177                                    row[r++] = buf; rn--;
00178                                    buf[j] = <span class="charliteral">'\0'</span>; bn--;
00179                                    buf += j + 1;
00180                                    j = t =  0;
00181                                    state = ST_START;
00182                                    inquotes = 0;
00183                                    <span class="keywordflow">if</span> (ch == <span class="charliteral">'\n'</span>) {
00184                                           rn = 0;
00185                                    }
00186                                    <span class="keywordflow">break</span>;
00187                             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (quotes &amp;&amp; ch == <span class="charliteral">'"'</span> &amp;&amp; state != ST_TAILSPACE) {
00188                                    buf[j++] = <span class="charliteral">'"'</span>;      bn--;          <span class="comment">/* nope, just an escaped quote */</span>
00189                                    t = j;
00190                                    state = ST_COLLECT;
00191                                    <span class="keywordflow">break</span>;
00192                             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isspace(ch)) {
00193                                    state = ST_TAILSPACE;
00194                                    <span class="keywordflow">break</span>;
00195                             }
00196                             errno = EILSEQ;
00197                             GERB_MESSAGE(<span class="stringliteral">"%d: bad end quote in element"</span>, errno);
00198                             <span class="keywordflow">return</span> -1;
00199               }
00200        }
00201        <span class="keywordflow">if</span> (ch &lt;= 0) {
00202               <span class="comment">/* treat EOF as EOL, so the last record is accepted even when</span>
00203 <span class="comment">                 \n is not present. Some users parse strings, not lines */</span>
00204               <span class="keywordflow">if</span>(state == ST_TAILSPACE || state == ST_END_QUOTE
00205                      || (state == ST_COLLECT &amp;&amp; ! inquotes)) {
00206                      row[r++] = buf; rn--;
00207                      buf[j] = <span class="charliteral">'\0'</span>; bn--;
00208                      buf += j + 1;
00209                      inquotes = 0;
00210                      rn = 0;
00211               } <span class="keywordflow">else</span> {
00212        <span class="comment">//            AMSG("");</span>
00213                      <span class="keywordflow">return</span> -1;
00214               }
00215        }
00216        <span class="keywordflow">if</span> (bn == 0) {
00217               errno = E2BIG;
00218               GERB_MESSAGE(<span class="stringliteral">"E2BIG %d "</span>, errno);
00219               <span class="keywordflow">return</span> -1;
00220        }
00221        <span class="keywordflow">if</span> (rn) {
00222               <span class="keywordflow">if</span> (inquotes) {
00223                      errno = EILSEQ;
00224                      GERB_MESSAGE(<span class="stringliteral">"EILSEQ %d "</span>, errno);
00225                      <span class="keywordflow">return</span> -1;
00226               }
00227               row[r] = buf;
00228               buf[t] = <span class="charliteral">'\0'</span>;
00229        }
00230 
00231        <span class="keywordflow">return</span> in-&gt;count;
00232 }<span class="comment">/* csv_parse_str */</span>
00233 
00234 
00235 <span class="keyword">static</span> <span class="keywordtype">int</span>
00236 csv_parse_wcs(<span class="keyword">struct</span> winput *in, <span class="keywordtype">wchar_t</span> *buf, size_t bn, <span class="keywordtype">wchar_t</span> *row[], <span class="keywordtype">int</span> rn, wint_t sep, <span class="keywordtype">int</span> flags)
00237 {
00238        <span class="keywordtype">int</span> trim, quotes, state, r, j, t, inquotes;
00239        wint_t ch;
00240 
00241        trim = flags &amp; CSV_TRIM;
00242        quotes = flags &amp; CSV_QUOTES;
00243        state = ST_START;
00244        inquotes = 0;
00245        ch = r = j = t = 0;
00246 
00247        memset(row, 0, <span class="keyword">sizeof</span>(<span class="keywordtype">wchar_t</span> *) * rn);
00248 
00249        <span class="keywordflow">while</span> (rn &amp;&amp; bn &amp;&amp; (ch = wnextch(in)) &gt; 0) {
00250               <span class="keywordflow">switch</span> (state) {
00251                      <span class="keywordflow">case</span> ST_START:
00252                             <span class="keywordflow">if</span> (ch != L<span class="charliteral">'\n'</span> &amp;&amp; ch != sep &amp;&amp; iswspace(ch)) {
00253                                    <span class="keywordflow">if</span> (!trim) {
00254                                           buf[j++] = ch; bn--;
00255                                           t = j;
00256                                    }
00257                                    <span class="keywordflow">break</span>;
00258                             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (quotes &amp;&amp; ch == L<span class="charliteral">'"'</span>) {
00259                                    j = t = 0;
00260                                    state = ST_COLLECT;
00261                                    inquotes = 1;
00262                                    <span class="keywordflow">break</span>;
00263                             }
00264                             state = ST_COLLECT;
00265                      <span class="keywordflow">case</span> ST_COLLECT:
00266                             <span class="keywordflow">if</span> (inquotes) {
00267                                    <span class="keywordflow">if</span> (ch == L<span class="charliteral">'"'</span>) {
00268                                           state = ST_END_QUOTE;
00269                                           <span class="keywordflow">break</span>;
00270                                    }
00271                             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch == sep || ch == L<span class="charliteral">'\n'</span>) {
00272                                    row[r++] = buf; rn--;
00273                                    buf[t] = L<span class="charliteral">'\0'</span>; bn--;
00274                                    buf += t + 1;
00275                                    j = t = 0;
00276                                    state = ST_START;
00277                                    inquotes = 0;
00278                                    <span class="keywordflow">if</span> (ch == L<span class="charliteral">'\n'</span>) {
00279                                           rn = 0;
00280                                    }
00281                                    <span class="keywordflow">break</span>;
00282                             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (quotes &amp;&amp; ch == L<span class="charliteral">'"'</span>) {
00283                                    errno = EILSEQ;
00284                                    GERB_MESSAGE(<span class="stringliteral">"%d: unexpected quote in element"</span>, errno);
00285                                    <span class="keywordflow">return</span> -1;
00286                             }
00287                             buf[j++] = ch; bn--;
00288                             <span class="keywordflow">if</span> (!trim || iswspace(ch) == 0) {
00289                                    t = j;
00290                             }
00291                             <span class="keywordflow">break</span>;
00292                      <span class="keywordflow">case</span> ST_TAILSPACE:
00293                      <span class="keywordflow">case</span> ST_END_QUOTE:
00294                             <span class="keywordflow">if</span> (ch == sep || ch == L<span class="charliteral">'\n'</span>) {
00295                                    row[r++] = buf; rn--;
00296                                    buf[j] = L<span class="charliteral">'\0'</span>; bn--;
00297                                    buf += j + 1;
00298                                    j = t =  0;
00299                                    state = ST_START;
00300                                    inquotes = 0;
00301                                    <span class="keywordflow">if</span> (ch == L<span class="charliteral">'\n'</span>) {
00302                                           rn = 0;
00303                                    }
00304                                    <span class="keywordflow">break</span>;
00305                             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (quotes &amp;&amp; ch == L<span class="charliteral">'"'</span> &amp;&amp; state != ST_TAILSPACE) {
00306                                    buf[j++] = L<span class="charliteral">'"'</span>; bn--;              <span class="comment">/* nope, just an escaped quote */</span>
00307                                    t = j;
00308                                    state = ST_COLLECT;
00309                                    <span class="keywordflow">break</span>;
00310                             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (iswspace(ch)) {
00311                                    state = ST_TAILSPACE;
00312                                    <span class="keywordflow">break</span>;
00313                             }
00314                             errno = EILSEQ;
00315                             GERB_MESSAGE(<span class="stringliteral">"%d: bad end quote in element "</span>, errno);
00316                             <span class="keywordflow">return</span> -1;
00317               }
00318        }
00319        <span class="keywordflow">if</span> (ch &lt;= 0) {
00320               <span class="comment">/* treat EOF as EOL, so the last record is accepted even when</span>
00321 <span class="comment">                 \n is not present. Some users parse strings, not lines */</span>
00322               <span class="keywordflow">if</span>(state == ST_TAILSPACE || state == ST_END_QUOTE
00323                      || (state == ST_COLLECT &amp;&amp; ! inquotes)) {
00324                      row[r++] = buf; rn--;
00325                      buf[j] = L<span class="charliteral">'\0'</span>; bn--;
00326                      buf += j + 1;
00327                      inquotes = 0;
00328                      rn = 0;
00329               } <span class="keywordflow">else</span> {
00330        <span class="comment">//            AMSG("");</span>
00331                      <span class="keywordflow">return</span> -1;
00332               }
00333        }
00334        <span class="keywordflow">if</span> (bn == 0) {
00335               errno = E2BIG;
00336        GERB_MESSAGE(<span class="stringliteral">"%d"</span>, errno);
00337               <span class="keywordflow">return</span> -1;
00338        }
00339        <span class="keywordflow">if</span> (rn) {
00340               <span class="keywordflow">if</span> (inquotes) {
00341                      errno = EILSEQ;
00342               GERB_MESSAGE(<span class="stringliteral">"%d"</span>, errno);
00343                      <span class="keywordflow">return</span> -1;
00344               }
00345               row[r] = buf;
00346               buf[t] = L<span class="charliteral">'\0'</span>;
00347        }
00348 
00349        <span class="keywordflow">return</span> in-&gt;count;
00350 }<span class="comment">/*csv_row_parse_wcs*/</span>
00351 
00352 
00353 <span class="keywordtype">int</span>
00354 csv_row_parse_wcs(<span class="keyword">const</span> <span class="keywordtype">wchar_t</span> *src, size_t sn, <span class="keywordtype">wchar_t</span> *buf, size_t bn, <span class="keywordtype">wchar_t</span> *row[], <span class="keywordtype">int</span> rn, <span class="keywordtype">int</span> sep, <span class="keywordtype">int</span> trim)
00355 {
00356        <span class="keyword">struct </span>winput input;
00357        input.src = src;
00358        input.sn = sn;
00359        input.count = 0;
00360        <span class="keywordflow">return</span> csv_parse_wcs(&amp;input, buf, bn, row, rn, (wint_t)sep, trim);
00361 }<span class="comment">/*csv_row_parse_wcs*/</span>
00362 
00363 
00364 <span class="keywordtype">int</span>
00365 csv_row_parse_str(<span class="keyword">const</span> <span class="keywordtype">char</span> *src, size_t sn, <span class="keywordtype">char</span> *buf, size_t bn, <span class="keywordtype">char</span> *row[], <span class="keywordtype">int</span> rn, <span class="keywordtype">int</span> sep, <span class="keywordtype">int</span> trim)
00366 {
00367        <span class="keyword">struct </span>sinput input;
00368        input.in = NULL;
00369        input.src = src;
00370        input.sn = sn;
00371        input.count = 0;
00372        <span class="keywordflow">return</span> csv_parse_str(&amp;input, buf, bn, row, rn, sep, trim);
00373 }<span class="comment">/*csv_row_parse_str*/</span>
00374 
00375 
00376 <span class="keywordtype">int</span>
00377 csv_row_fread(FILE *in, <span class="keywordtype">char</span> *buf, size_t bn, <span class="keywordtype">char</span> *row[], <span class="keywordtype">int</span> numcols, <span class="keywordtype">int</span> sep, <span class="keywordtype">int</span> trim)
00378 {
00379        <span class="keyword">struct </span>sinput input;
00380        input.in = in;
00381        input.count = 0;
00382        <span class="keywordflow">return</span> csv_parse_str(&amp;input, buf, bn, row, numcols, sep, trim);
00383 }<span class="comment">/*csv_row_fread*/</span>
00384 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Oct 13 16:09:18 2004 for gerbv by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.8-20040928 </small></address>
</body>
</html>
